<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>盛国存</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shengguocun.com/"/>
  <updated>2018-09-19T13:51:15.000Z</updated>
  <id>https://www.shengguocun.com/</id>
  
  <author>
    <name>ShengGuocun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vanilla （lua web framework）中文文档 [2018.09.19]</title>
    <link href="https://www.shengguocun.com//blog/2018/09/19/quick-start-Vanilla-lua-web-framework/"/>
    <id>https://www.shengguocun.com//blog/2018/09/19/quick-start-Vanilla-lua-web-framework/</id>
    <published>2018-09-19T13:18:21.000Z</published>
    <updated>2018-09-19T13:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p><em>香草/Vanilla是一个基于Openresty实现的高性能Web应用开发框架.</em></p><p><img src="http://m1.sinaimg.cn/maxwidth.300/m1.sinaimg.cn/120d7329960e19cf073f264751e8d959_2043_2241.png" alt="Vanilla"></p><p><strong>邮件列表</strong></p><ul><li>vanilla-en  <a href="&#109;&#x61;&#x69;&#x6c;&#x74;&#x6f;&#58;&#x76;&#97;&#x6e;&#x69;&#x6c;&#x6c;&#97;&#45;&#101;&#x6e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d;">&#x76;&#97;&#x6e;&#x69;&#x6c;&#x6c;&#97;&#45;&#101;&#x6e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d;</a></li><li>vanilla-devel  <a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x76;&#x61;&#x6e;&#x69;&#x6c;&#x6c;&#x61;&#x2d;&#100;&#101;&#x76;&#x65;&#x6c;&#x40;&#x67;&#111;&#111;&#103;&#108;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109;">&#x76;&#x61;&#x6e;&#x69;&#x6c;&#x6c;&#x61;&#x2d;&#100;&#101;&#x76;&#x65;&#x6c;&#x40;&#x67;&#111;&#111;&#103;&#108;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109;</a></li><li>vanilla中文邮件列表  <a href="&#109;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x76;&#x61;&#x6e;&#105;&#108;&#x6c;&#x61;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#x65;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#99;&#111;&#x6d;">&#x76;&#x61;&#x6e;&#105;&#108;&#x6c;&#x61;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#x65;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#99;&#111;&#x6d;</a></li></ul><p><strong>推荐始终使用最新版的Vanilla</strong></p><p><em>当前Vanilla最新版本0.1.0.rc6，支持命令：</em></p><ul><li>vanilla-0.1.0.rc6（<em>你没看错，自0.1.0.rc5起，vanilla的命令行和框架代码都带着版本号，方便多版本共存，也方便框架升级</em>）</li><li>v-console-0.1.0.rc6</li></ul><p><strong>特性</strong></p><ul><li>提供很多优良组件诸如：bootstrap、 router、 controllers、 models、 views。</li><li>强劲的插件体系。</li><li>多 Application 部署。</li><li>多版本框架共存，支持便捷的框架升级。</li><li>一键 nginx 配置、 应用部署。</li><li>便捷的服务批量管理。</li><li>你只需关注自身业务逻辑。</li></ul><h3 id="0-1、安装"><a href="#0-1、安装" class="headerlink" title="0.1、安装"></a>0.1、安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./setup-framework -v <span class="variable">$VANILLA_PROJ_ROOT</span> -o <span class="variable">$OPENRESTY_ROOT</span>        <span class="comment">#运行 ./setup-framework -h 查看更多参数细节</span></span><br></pre></td></tr></table></figure><h3 id="0-2、快速开始"><a href="#0-2、快速开始" class="headerlink" title="0.2、快速开始"></a>0.2、快速开始</h3><p><strong>部署你的第一个Vanilla Application</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./setup-vanilal-demoapp  [-a <span class="variable">$VANILLA_APP_ROOT</span> -u <span class="variable">$VANILLA_APP_USER</span> -g <span class="variable">$VANILLA_APP_GROUP</span> -e <span class="variable">$VANILLA_RUNNING_ENV</span>]    <span class="comment">#运行 ./setup-vanilal-demoapp -h 查看更多参数细节</span></span><br></pre></td></tr></table></figure><p><strong>启动你的 Vanilla 服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="variable">$VANILLA_APP_ROOT</span>/va-appname-service start</span><br></pre></td></tr></table></figure><p><strong>社区组织</strong></p><p><strong>QQ群&amp;&amp;微信公众号</strong></p><ul><li><em>Openresty/Vanilla 开发 1 群：205773855</em></li><li><em>Openresty/Vanilla 开发 2 群：419191655</em></li><li><em>Openresty 技术交流 1 群：34782325</em></li><li><em>Openresty 技术交流 2 群：481213820</em></li><li><em>Openresty 技术交流 3 群：124613000</em></li><li><em>Vanilla开发微信公众号:Vanilla-OpenResty(Vanilla相关资讯、文档推送)</em></li></ul><h2 id="1、快速上手"><a href="#1、快速上手" class="headerlink" title="1、快速上手"></a>1、快速上手</h2><h3 id="1-1、Hello-World"><a href="#1-1、Hello-World" class="headerlink" title="1.1、Hello World"></a>1.1、Hello World</h3><h4 id="1-1-1、Vanilla-的安装"><a href="#1-1-1、Vanilla-的安装" class="headerlink" title="1.1.1、Vanilla 的安装"></a>1.1.1、Vanilla 的安装</h4><p><strong>安装准备</strong></p><ol><li>安装好 OpenResty</li><li>Vanilla Github 地址：<a href="https://github.com/idevz/vanilla" target="_blank" rel="noopener">https://github.com/idevz/vanilla</a></li></ol><p><strong>安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.git clone 最新 Vanilla 版本（或者下载相应的 Vanilla release 版本）</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/idevz/vanilla.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到 Vanilla 文件夹</span></span><br><span class="line"><span class="built_in">cd</span> vanilla</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.编译 vanilla： ./setup-framework -v $VANILLA_PROJ_ROOT -o $OPENRESTY_ROOT 其中 $VANILLA_PROJ_ROOT 为 vanilla 框架安装目录。 -o 为 openresty 安装目录</span></span><br><span class="line"></span><br><span class="line">./setup-framework -v /application/vanilla -o /application/openresty</span><br></pre></td></tr></table></figure><p><em>经过这 3 步如果没有报错，则安装 vanilla 成功</em></p><p><strong>创建 vanilla 项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 创建 vanilla 的运行用户</span></span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin -M nginx</span><br><span class="line"></span><br><span class="line">id nginx <span class="comment"># 可以查看到创建的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、创建 vanilla 项目, -a 为 项目路径，-u 为执行用户 -g 为用户组 （在根目录 /home/webserver 下创建名为 cms 的项目）</span></span><br><span class="line"></span><br><span class="line">./setup-vanilla-demoapp -a /home/webserver/cms -u nginx -g nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、删掉默认 Nginx 服务</span></span><br><span class="line"></span><br><span class="line">pkill -9 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、切换到项目文件夹 编辑项目配置文件，改成你要的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/webserver/cms</span><br><span class="line"><span class="built_in">cd</span> nginx_conf</span><br><span class="line">vim va-nginx.conf</span><br><span class="line">vim va-nginx-development.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、同步配置文件到运行目录</span></span><br><span class="line"></span><br><span class="line">./va-cms-service initconf dev -f <span class="comment">#开发模式</span></span><br><span class="line">./va-cms-service initconf -f <span class="comment">#生产模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、启动项目（2选1）</span></span><br><span class="line"></span><br><span class="line">./va-cms-service start dev  <span class="comment"># 启动开发模式</span></span><br><span class="line">./va-cms-service start  <span class="comment"># 启动生产模式</span></span><br></pre></td></tr></table></figure><p><em>服务启动后，开发环境默认启动在 9110 端口，<a href="http://localhost:9110" target="_blank" rel="noopener">http://localhost:9110</a> 即可访问</em></p><p><strong>vanilla 常用命令</strong></p><ol><li><p>启动项目： <code>./va-cms-service start</code> 或者 <code>./va-orcms-service start dev</code></p></li><li><p>重启项目  <code>./va-cms-service restart</code> 或者 <code>./va-orcms-service restart dev</code></p></li><li><p>停止项目： <code>./va-cms-service stop</code> 或者 <code>./va-orcms-service stop dev</code></p></li><li><p>创建配置文件 <code>./va-cms-service initconf dev -f</code></p></li></ol><h3 id="1-2、如何调试"><a href="#1-2、如何调试" class="headerlink" title="1.2、如何调试"></a>1.2、如何调试</h3><h4 id="1-2-1、Vanilla-的-调试"><a href="#1-2-1、Vanilla-的-调试" class="headerlink" title="1.2.1、Vanilla 的 调试"></a>1.2.1、Vanilla 的 调试</h4><p><em>除了查看 nginx 错误日志辅助开发外，为了方便 Vanilla 项目的开发和调试，Vanilla 提供了诸如 <code>print_r</code> 之类的对象输出方法，以及详细友好的页面报错输出，你不需要到服务器日志去查看，就能所见即所得的开发调试代码.</em></p><p><strong>sprint_r，print_r，lprint_r，err_log</strong></p><ul><li><strong>sprint_r</strong></li></ul><p><em>将 LUA 对象等格式化为易读的字符串返回</em></p><ul><li><strong>print_r</strong></li></ul><p><em>类似 <code>ngx.say</code> 的效果，将对象、变量等以易读的格式进行输出，适用于 Vanilla 开发的 Web 服务</em></p><ul><li><strong>lprint_r</strong></li></ul><p><em><code>print_r</code> 的 CLI 版本，适用于 v-console 命令行环境</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╰─○ v-console-0.1.0.rc6</span><br><span class="line">Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio</span><br><span class="line">v-console&gt;a=&#123;&#125;</span><br><span class="line">v-console&gt;a.v1=<span class="string">'a_v1'</span></span><br><span class="line">v-console&gt;a.v2=<span class="string">'a_v2'</span></span><br><span class="line">v-console&gt;lprint_r(a)</span><br><span class="line">&#123;</span><br><span class="line">  v2 = <span class="string">"a_v2"</span>,</span><br><span class="line">  v1 = <span class="string">"a_v1"</span></span><br><span class="line">&#125;</span><br><span class="line">v-console&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>err_log</strong></li></ul><p><em>err_log 方法是对 <code>ngx.ERR</code> 的封装，将 <code>msg</code> 记录到 nginx 错误日志</em></p><h3 id="1-3、如何新增一个Controller"><a href="#1-3、如何新增一个Controller" class="headerlink" title="1.3、如何新增一个Controller"></a>1.3、如何新增一个Controller</h3><h4 id="1-3-1、Vanilla-的-controller"><a href="#1-3-1、Vanilla-的-controller" class="headerlink" title="1.3.1、Vanilla 的 controller"></a>1.3.1、Vanilla 的 controller</h4><p><em>vanilla 的 controller 是业务处理的关键，vanilla 通过对 URI 的路由，找到本次请求对应的 controller 和 action。</em></p><ul><li><strong>最简单的 Controller</strong></li></ul><p><em>自动生成的 demo 中默认生成了 IndexController 和 index action（<code>function IndexController:index()</code>），默认使用简单路由协议（<code>vanilla.v.routes.simple</code>）对 URI 进行路由</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self:getView()</span><br><span class="line">    <span class="keyword">local</span> p = &#123;&#125;</span><br><span class="line">    p[<span class="string">'vanilla'</span>] = <span class="string">'Welcome To Vanilla...'</span> .. user_service:get()</span><br><span class="line">    p[<span class="string">'zhoujing'</span>] = <span class="string">'Power by Openresty'</span></span><br><span class="line">    <span class="comment">-- view:assign(p)</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> view:render(<span class="string">'index/index.html'</span>, p) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> view:display()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure><p><strong>以上代码解释</strong></p><p><em>关于上面的 controller 实例代码，我们只需关注下面几点</em></p><ul><li>IndexController:index （index Controller 中的 index Action），通过 <code>self:getView()</code> 方法获取视图实例</li><li>可以通过先调用 <code>view:assign(p)</code> 将所需要的参数传入视图，再调用 <code>view:display()</code> 进行模板渲染，或者可以直接调用 <code>view:render(&#39;index/index.html&#39;, p)</code> 方法，指定需要渲染的模板，并同时传入相应的参数</li><li>模板参数都是与 LUA 数组的形式进行传递</li><li>每个 action 的返回值都必须是字符串，所以可以知道 <code>view:display()</code> 和 <code>view:render()</code> 方法都是返回字符串</li><li>IndexController:action_b （index Controller 中的 action_b Action，这里注意，action 的方法名必须小写），使用默认的简单路由协议，访问 URI 为 <code>curl http://localhost:9110/index/action_b</code></li></ul><p><em>注：目前 vanilla 所默认使用的模板引擎是 appo 老师开发的 <a href="https://github.com/bungle/lua-resty-template" target="_blank" rel="noopener">resty-template</a>，模板详细的使用文档请移步 appo 老师处参阅。</em></p><h4 id="1-3-2、新添加一个-Controller"><a href="#1-3-2、新添加一个-Controller" class="headerlink" title="1.3.2、新添加一个 Controller"></a>1.3.2、新添加一个 Controller</h4><p><em>给 Vanilla 添加一个新的 Controller 非常简单，只需要在项目的 controllers 目录，实现一个 LUA 包，包导入的函数即为各个 action， 文件名与 controller 同名。例如添加一个名为 idevz 的 controller， 且实现一个名为 dohello 的 action（）。</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IdevzController = &#123;&#125;</span><br><span class="line"><span class="comment">-- curl http://localhost:9110/idevz/dohello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IdevzController:dohello</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'do-hello-action.'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> IdevzController</span><br></pre></td></tr></table></figure><h3 id="1-4、如何使用Models-Dao"><a href="#1-4、如何使用Models-Dao" class="headerlink" title="1.4、如何使用Models/Dao"></a>1.4、如何使用Models/Dao</h3><h4 id="1-4-1、Vanilla-的-DAO"><a href="#1-4-1、Vanilla-的-DAO" class="headerlink" title="1.4.1、Vanilla 的 DAO"></a>1.4.1、Vanilla 的 DAO</h4><p><em>vanilla 的 DAO 预设为项目对数据源的封装，一切对数据源的操作都可以封装成 DAO，方便维护、管理、缓存等。 Vanilla 的 DAO 在项目的 models/dao 路径下，一般使用 <code>LoadModel</code> 方法进行加载</em></p><p><strong>最简单的 DAO</strong></p><p><em>由自动生成的 demo 中默认生成了 TableDao，可以看出 TableDao 只是一个普通的 LUA 包。</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> TableDao = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableDao:set</span><span class="params">(key, value)</span></span></span><br><span class="line">    self.__cache[key] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableDao:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> instance = &#123;</span><br><span class="line">        set = self.set,</span><br><span class="line">        __cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(instance, TableDao)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableDao:__index</span><span class="params">(key)</span></span></span><br><span class="line">    <span class="keyword">local</span> out = <span class="built_in">rawget</span>(<span class="built_in">rawget</span>(self, <span class="string">'__cache'</span>), key)</span><br><span class="line">    <span class="keyword">if</span> out <span class="keyword">then</span> <span class="keyword">return</span> out <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> TableDao</span><br></pre></td></tr></table></figure><p><strong>以上代码解释</strong></p><p><em>DAO 可以是任何对数据层访问封装的 LUA 包，实现方式非常自由。</em></p><h3 id="1-5、如何使用Models-Service"><a href="#1-5、如何使用Models-Service" class="headerlink" title="1.5、如何使用Models/Service"></a>1.5、如何使用Models/Service</h3><h4 id="1-5-1、Vanilla-的-Service"><a href="#1-5-1、Vanilla-的-Service" class="headerlink" title="1.5.1、Vanilla 的 Service"></a>1.5.1、Vanilla 的 Service</h4><p><em>vanilla 的 Service 预设为项目对某些通用业务逻辑封装为独立的 Service，方便维护、管理、缓存等。 Vanilla 的 Service 在项目的 models/service 路径下，一般使用 <code>LoadModel</code> 方法进行加载</em></p><p><strong>最简单的 Service</strong></p><p><em>由自动生成的 demo 中默认生成了 UserService，可以看出 UserService 也只是一个普通的 LUA 包。不过 Service 一般调用更底层的 DAO ，并对之做必要封装，并将相关的 Service 暴露给 Controller 使用</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> table_dao = LoadApplication(<span class="string">'models.dao.table'</span>):new()</span><br><span class="line"><span class="keyword">local</span> UserService = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserService:get</span><span class="params">()</span></span></span><br><span class="line">    table_dao:set(<span class="string">'zhou'</span>, <span class="string">'UserService res'</span>)</span><br><span class="line">    <span class="keyword">return</span> table_dao.zhou</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UserService</span><br></pre></td></tr></table></figure><p><strong>以上代码解释</strong></p><p><em>Service 可以是任何对数据层访问封装的 LUA 包</em></p><h2 id="2、APIs"><a href="#2、APIs" class="headerlink" title="2、APIs"></a>2、APIs</h2><h3 id="2-1、配置"><a href="#2-1、配置" class="headerlink" title="2.1、配置"></a>2.1、配置</h3><h4 id="2-1-1、配置"><a href="#2-1-1、配置" class="headerlink" title="2.1.1、配置"></a>2.1.1、配置</h4><p><em>香草/Vanilla的配置由以下三个部分组成.</em></p><ul><li><em>App配置</em></li><li><em>Nginx配置</em></li><li><em>WAF配置</em></li></ul><blockquote><ul><li><strong>App配置</strong></li></ul></blockquote><p><strong>应用基础配置（config/application.lua）</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Appconf.sysconf = &#123;<span class="comment">--系统预加载配置文件</span></span><br><span class="line">    <span class="string">'v_resource'</span>,</span><br><span class="line">&#125;</span><br><span class="line">Appconf.name = <span class="string">'app_name'</span><span class="comment">--app名称，执行vanilla new命令时给定的应用名</span></span><br><span class="line"></span><br><span class="line">Appconf.route=<span class="string">'vanilla.v.routes.simple'</span><span class="comment">--路由器，指定URL路由方式，目的解析出需要执行的controller与action</span></span><br><span class="line">Appconf.bootstrap=<span class="string">'application.bootstrap'</span><span class="comment">--初始化bootstrap（用来对应用进行初始化操作）</span></span><br><span class="line">Appconf.app=&#123;&#125;<span class="comment">--app相关配置</span></span><br><span class="line">Appconf.app.root=<span class="string">'./'</span><span class="comment">--当前vanilla start命令执行路径</span></span><br><span class="line"></span><br><span class="line">Appconf.controller=&#123;&#125;<span class="comment">--当前app的controller相关配置</span></span><br><span class="line">Appconf.controller.<span class="built_in">path</span>=Appconf.app.root .. <span class="string">'application/controllers/'</span><span class="comment">--controller文件所在路径（使用默认生成路径即可）</span></span><br><span class="line"></span><br><span class="line">Appconf.view=&#123;&#125;<span class="comment">--当前app的视图层相关配置</span></span><br><span class="line">Appconf.view.<span class="built_in">path</span>=Appconf.app.root .. <span class="string">'application/views/'</span><span class="comment">--模板路径</span></span><br><span class="line">Appconf.view.suffix=<span class="string">'.html'</span><span class="comment">--模板后缀</span></span><br><span class="line">Appconf.view.auto_render=<span class="literal">true</span><span class="comment">--是否开启自动渲染</span></span><br></pre></td></tr></table></figure><p><strong>应用基础配置的引用</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如上的配置，可以在代码中通过 Registry['APP_CONF'] 表来进行获取，比如获取 APP_NAME</span></span><br><span class="line"><span class="keyword">local</span> app_name = Registry[<span class="string">'APP_CONF'</span>][<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure><p><strong>错误处理配置（config/errors.lua）</strong></p><p><em>根据errors.lua文件中实例，配置用户级别错误码.</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Errors = &#123;</span><br><span class="line">    [<span class="number">1000</span>] = &#123; <span class="built_in">status</span> = <span class="number">500</span>, message = <span class="string">"Controller Err."</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Restful 路由协议配置（config/restful.lua）</strong></p><p><em>根据 URI 需要来自定义路由协议的配置</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> restful = &#123;</span><br><span class="line">    v1=&#123;&#125;,</span><br><span class="line">    v=&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restful.v.GET = &#123;</span><br><span class="line">    &#123;pattern = <span class="string">'/'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'index'</span>&#125;,</span><br><span class="line">    &#123;pattern = <span class="string">'/:category'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'list'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restful.v.POST = &#123;</span><br><span class="line">    &#123;pattern = <span class="string">'/post'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'post'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restful.v1.GET = &#123;</span><br><span class="line">    &#123;pattern = <span class="string">'/api'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'api_get'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> restful</span><br></pre></td></tr></table></figure><p><strong>系统相关配置（sys/*）</strong></p><p><em>比如DB、MC等资源配置，系统相关的分机房配置等（在某些大公司，这部分配置又运维人员统一管理和下发），文件格式目前使用相对更运维友好的 ini 文件，开发中可以方便的在 Registry[‘sys_conf’] 中获取相关数据，如 <code>Registry[&#39;sys_conf&#39;][&#39;cache&#39;][&#39;lrucache&#39;]</code> 获取 lrucache 相关配置</em></p><p><strong>系统缓存相关配置 （sys/cache）</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[shared_dict]</span></span><br><span class="line"><span class="attr">dict</span>=idevz</span><br><span class="line"><span class="attr">exptime</span>=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="section">[memcached]</span></span><br><span class="line"><span class="attr">instances</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">11211</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">11211</span></span><br><span class="line"><span class="attr">exptime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">poolsize</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">idletimeout</span>=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[redis]</span></span><br><span class="line"><span class="attr">instances</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span></span><br><span class="line"><span class="attr">exptime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">poolsize</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">idletimeout</span>=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lrucache]</span></span><br><span class="line"><span class="attr">items</span>=<span class="number">200</span></span><br><span class="line"><span class="attr">exptime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">useffi</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><ul><li>目前这部分配置一般由 vanilla.v.libs.cache 来使用</li><li>目前支持的配置项如 poolsize（连接池大小）、timeout（数据获取超时等）</li></ul><p><strong>系统缓存相关配置 （sys/v_resource）</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mc]</span></span><br><span class="line"><span class="attr">conf</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7348</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">11211</span></span><br><span class="line"></span><br><span class="line"><span class="section">[redis]</span></span><br><span class="line"><span class="attr">conf</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7348</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7349</span></span><br><span class="line"></span><br><span class="line"><span class="section">[redisq]</span></span><br><span class="line"><span class="attr">conf</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7348</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7349</span></span><br><span class="line"></span><br><span class="line"><span class="section">[db.user.write]</span></span><br><span class="line"><span class="attr">host</span> =<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br><span class="line"><span class="attr">dbname</span> =user.info</span><br><span class="line"><span class="attr">user</span> =idevz</span><br><span class="line"><span class="attr">passwd</span> =idevz</span><br><span class="line"></span><br><span class="line"><span class="section">[db.user.read]</span></span><br><span class="line"><span class="attr">host</span> =<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br><span class="line"><span class="attr">dbname</span> =user.info</span><br><span class="line"><span class="attr">user</span> =idevz</span><br><span class="line"><span class="attr">passwd</span> =idevz</span><br></pre></td></tr></table></figure><ul><li>对所使用的数据资源做配置</li><li><code>Registry[&#39;sys_conf&#39;][&#39;v_resource）&#39;][&#39;db.user.write&#39;][&#39;host&#39;]</code> 获取写库的 HOST 信息</li></ul><blockquote><ul><li><strong>Nginx配置</strong></li></ul></blockquote><p><strong>自动生成的 Nginx 配置文件</strong></p><p><em>初始化项目的时候会在项目目录下（nginx_conf/）自动生成这个项目所对应的两套（分别对应开发和线上环境）配置文件，生成的两套配置文件中，每套都包含 nginx.conf 和 vhost 两个配置文件</em></p><ul><li><strong>生产环境</strong></li></ul><p><strong>va-nginx.conf 文件</strong></p><p><em>va-nginx.conf 配置文件内容包含 nginx 配置主干（main、events、http 等重点配置段），包括用户、组的配置，工作进程等等通用配置，关键的还有 <code>lua_package_path</code>、<code>lua_package_cpath</code> 的配置，还有框架初始化文件（vanilla/framework/init.lua）的加载</em></p><p><strong>vhost/app_name.conf 文件</strong></p><p><em>vhost/app_name.conf 文件是当前应用的相关配置，包括 APP_NAME、VANILLA_VERSION、$template_root、$va_cache_status 等全局变量的初始化，$document_root，Server_name 等的设置，还有关键的应用入口（content_by_lua_file），lua_shared_dict 等的设置，不过这些设置都是自动生成的，开发人员没有特殊需求的话，并不需要关注这些</em></p><ul><li><strong>开发环境</strong></li></ul><p><strong>va-nginx-development.conf 文件</strong></p><p><em>va-nginx-development.conf 文件的内容跟开发环境类似，唯一的区别在于加载框架初始化文件（vanilla/framework/init.lua）的方式为 <code>init_by_lua_file</code></em></p><p><strong>dev_vhost/app_name.conf 文件</strong></p><p><em>默认的dev_vhost/app_name.conf 文件的配置同生产环境的配置基本一样，关键不同在于 <code>lua_code_cache</code> 的设置</em></p><p><em>注：所以初始化项目后，首先需要执行 <code>sudo ./va-app_name-service initconf dev</code> 命令，就是为了将自动生成的配置文件部署到 OpenResty 默认的配置文件路径下，如果需要更新 va-nginx（-development）.conf 则还需要在命令后面加上 <code>-f</code> 参数进行强行部署，每次如果需要修改配置，也只需修改这部分配置，然后执行 <code>initconf</code> 即可</em></p><p><em><strong>nginx.lua( vanilla-0.1.0.rc5 后废弃此配置 )</strong></em></p><p><em>分为ngx_conf.common和ngx_conf.env两个部分，common是对Openresty指令集的配置如INIT_BY_LUA，可以是包或者文件(BY_LUA_FILE)，env是环境的部分，包括了开发环境，测试环境和生产环境端口和缓存配置等控制.</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ngx_conf.common = &#123;</span><br><span class="line">    INIT_BY_LUA = <span class="string">'nginx.init'</span>,</span><br><span class="line">    CONTENT_BY_LUA_FILE = <span class="string">'./pub/index.lua'</span></span><br><span class="line">&#125;</span><br><span class="line">ngx_conf.env = &#123;&#125;</span><br><span class="line">ngx_conf.env.development = &#123;</span><br><span class="line">    LUA_CODE_CACHE = <span class="literal">false</span>,</span><br><span class="line">    PORT = <span class="number">7200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><strong>WAF配置</strong></li></ul></blockquote><p><strong>waf.lua</strong></p><p><em>包括WAF规则的配置，及各种规则参数的配置，相关使用方法详见 <a href="https://github.com/loveshell/ngx_lua_waf" target="_blank" rel="noopener">waf</a></em></p><h3 id="2-2、Bootstrap"><a href="#2-2、Bootstrap" class="headerlink" title="2.2、Bootstrap"></a>2.2、Bootstrap</h3><h4 id="2-2-1、使用-Bootstrap-来做服务初始化"><a href="#2-2-1、使用-Bootstrap-来做服务初始化" class="headerlink" title="2.2.1、使用 Bootstrap 来做服务初始化"></a>2.2.1、使用 Bootstrap 来做服务初始化</h4><p><em>Vanilla 使用 Bootstrap 来做应用初始化的工作，用户可以在此对应用做一些配置（比如所使用的路由协议，使用何种视图引擎），对配置做一些初始化加载，初始化 WAF，初始化 Plugins 等操作，Vanilla 运行在 OpenResty content_by_lua\</em>这个 Phrase，使用 Bootstrap 可以很好的实现对请求的细粒度控制*</p><p><strong>Bootstrap 即类 <code>application.bootstrap</code></strong></p><p><em>Bootstrap 的实现其实是一个名为 <code>application.bootstrap</code> 的 Vanilla 类，实现了构造器初始化的属性只有一个（当前请求所使用的 dispatcher），我们只需要关注根据需求实现各种 init 方法即可，最后只要在 <code>boot_list</code> 方法返回的列表中的 init 方法都会被顺序执行</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:boot_list</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">-- Bootstrap.initWaf,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initErrorHandle,</span></span><br><span class="line">        Bootstrap.initRoute,</span><br><span class="line">        <span class="comment">-- Bootstrap.initView,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initPlugin,</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:__construct</span><span class="params">(dispatcher)</span></span></span><br><span class="line">    self.dispatcher = dispatcher</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>上面的定义代表只有 <code>initRoute</code> 方法会被执行，而上面两个方法的实现我们并不需要关心和更改，只需要定义各种 init 方法，并更新 <code>boot_list</code> 返回的表元素即可，比如下面初始化路由协议的 <code>initRoute</code></em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initRoute</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> router = self.dispatcher:getRouter()</span><br><span class="line">    <span class="keyword">local</span> restful_route = restful:new(self.dispatcher:getRequest())</span><br><span class="line">    router:addRoute(restful_route, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>注：可以通过 self.dispatcher 获取当前请求相关的详细信息，并进行相关控制</em></p><h3 id="2-3、Controllers"><a href="#2-3、Controllers" class="headerlink" title="2.3、Controllers"></a>2.3、Controllers</h3><h4 id="2-3-1、Vanilla-的-controller"><a href="#2-3-1、Vanilla-的-controller" class="headerlink" title="2.3.1、Vanilla 的 controller"></a>2.3.1、Vanilla 的 controller</h4><p><em>vanilla 的 controller 是业务处理的关键，基本的用法请参考上文 (如何新增一个Controller) 。</em></p><p><strong>关于 Controller</strong></p><p><em>Vanilla 的 Controller 可以是任何普通的 LUA 包，只不过导入的方法被用作处理请求的 Action。如下示例：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self:getView()</span><br><span class="line">    <span class="keyword">local</span> p = &#123;&#125;</span><br><span class="line">    p[<span class="string">'vanilla'</span>] = <span class="string">'Welcome To Vanilla...'</span> .. user_service:get()</span><br><span class="line">    p[<span class="string">'zhoujing'</span>] = <span class="string">'Power by Openresty'</span></span><br><span class="line">    <span class="comment">-- view:assign(p)</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> view:render(<span class="string">'index/index.html'</span>, p) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> view:display()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure><p><strong>更面向对象的 Controller</strong></p><p><em>Vanilla 支持使用 <code>Class</code> 方法来声明一个 Controller，实例如下：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = Class(<span class="string">'controllers.index'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure><p><em>这种情况下，可以定义 Controller 的构造器来对其进行初始化。示例如下：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = Class(<span class="string">'controllers.index'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:__construct</span><span class="params">()</span></span></span><br><span class="line">    self.aa = aa(&#123;info=<span class="string">'ppppp'</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure><p><em>甚至还可以声明一个 Controller 基类，处理某些通用的逻辑，相关的详细用法参见 Vanilla<a href="../advanced/oo.md">面向对象</a> 相关章节。</em></p><p><strong>关于 Action 的返回值</strong></p><p><em>Vanilla 底层会将 Action 执行的结果，完全使用 <code>ngx.print</code> 进行输出，所以 Action 的返回值必须不能为空。而由于 Vanilla 的 Response 中，提供了给响应添加头尾的 <code>Response:appendBody</code> 和 <code>Response:prependBody</code> 方法，最终的结果会将这些部分合起来一起返回，所以 Action 的返回值要求如下：</em></p><ul><li>Action 返回值必须非空</li><li>Action 返回值可以为一维索引数组（不可以是多维 Hash 数组）或者字符串</li></ul><h3 id="2-4、模板引擎"><a href="#2-4、模板引擎" class="headerlink" title="2.4、模板引擎"></a>2.4、模板引擎</h3><h4 id="2-4-1、Vanilla-的视图引擎"><a href="#2-4-1、Vanilla-的视图引擎" class="headerlink" title="2.4.1、Vanilla 的视图引擎"></a>2.4.1、Vanilla 的视图引擎</h4><p><em>为去除模板运行时模板解析带来的不必要开销，从 vanilla-0.1.0.rc7 起 Vanilla 开始支持 OpenResty 官方的 Lemplate 模板引擎，下面将简要介绍 Vanilla 中 Lemplate 的用法，以及 Vanilla View 接口介绍</em></p><p><strong>Vanilla 的视图渲染</strong></p><p><em>Vanilla 在 <code>vanilla.v.dispatcher</code> 中导入了默认的模板引擎（<code>local View = LoadV &#39;vanilla.v.views.rtpl&#39;</code>），但是可以在 Bootstrap 中实现 <code>initView</code> 来修改所使用的视图引擎。</em><br><em>而 Vanilla 的模板渲染，只需要在相应的 Action 中获取当前视图实例，注入数据，展示即可。下面就以 Lemplate 模板引擎为例，展示相关用法</em></p><p><strong>首先在 Bootstrap 中实现 <code>initView</code> 方法，修改项目所使用的视图引擎</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- application/bootstrap.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initView</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = LoadV(<span class="string">'vanilla.v.views.lemplate'</span>):new(self.dispatcher.application.<span class="built_in">config</span>.view)</span><br><span class="line">    self.dispatcher:setView(view)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- boot_list 中打开 Bootstrap.initView 方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:boot_list</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">-- Bootstrap.initWaf,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initErrorHandle,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initRoute,</span></span><br><span class="line">        Bootstrap.initView,</span><br><span class="line">        <span class="comment">-- Bootstrap.initPlugin,</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>运行 <code>./va-{app_name}-service ltpl</code> 命令调用 <code>Lemplate</code> 编译你的 TT2 模板</strong></p><p><em>下面是 TT2 模板示意</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>[% title %]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">[% FOREACH userinfo IN userlists %]</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>姓名：[% userinfo.name %] / 地址：[% userinfo.addr %]<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">[% END %]</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>在 Vanilla Action 中调用编译好的模板</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self:getView()</span><br><span class="line">    <span class="keyword">local</span> users = &#123;</span><br><span class="line">                        &#123;name=<span class="string">'idevz'</span>, addr=<span class="string">'yunnan'</span>&#125;,</span><br><span class="line">                        &#123;name=<span class="string">'vanilla'</span>, addr=<span class="string">'beijing'</span>&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">    <span class="keyword">return</span> view:assign(&#123;userlists=users, title = <span class="string">'Vanilla-Lemplate'</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>注：</em></p><ul><li><code>local view = self:getView()</code> 获取当前视图实例</li><li><code>view:assign({userlists=users, title = &#39;Vanilla-Lemplate&#39;})</code> 将数据注入视图</li></ul><p><em>注：以上为 Lemplate 所使用的 TT2 模板实例，关于 Lemplate 的详细使用，可参考其详细 <a href="https://github.com/openresty/lemplate" target="_blank" rel="noopener">文档</a></em></p><h3 id="2-5、插件"><a href="#2-5、插件" class="headerlink" title="2.5、插件"></a>2.5、插件</h3><h4 id="2-5-1、Vanilla-的插件体系"><a href="#2-5-1、Vanilla-的插件体系" class="headerlink" title="2.5.1、Vanilla 的插件体系"></a>2.5.1、Vanilla 的插件体系</h4><p><em>为了减少运行占用的系统资源，使开发更简便，Vanilla 默认只运行在 content_by_lua 这个 phrase，但是为了支持业务开发有层次化的请求控制，Vanilla 实现了便捷的插件机制，提供了六个钩子，给请求的细粒度控制提供了可能。下面我们来看看如何使用</em></p><p><strong>Vanilla Plugin 的简单使用</strong></p><p><em>在 Vanilla 项目中使用插件是非常简单的，只需要在 application/plugins/ 路径下实现 Vanilla 的插件 LUA 包即可，插件包可以按需实现 6 个钩子的方法。默认生成的 demo 项目中自动生成了一个 admin plugin，见 application/plugins/admin.lua。六个钩子方法按需实现，空方法可去掉，如下所示：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> AdminPlugin = LoadV(<span class="string">'vanilla.v.plugin'</span>):new()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AdminPlugin:routerStartup</span><span class="params">(request, response)</span></span></span><br><span class="line">    print_r(<span class="string">'&lt;pre&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span> <span class="keyword">then</span></span><br><span class="line">        print_r(<span class="string">'-----------'</span> .. sprint_r(request.headers) .. <span class="string">'----------'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_r(request.headers)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> AdminPlugin</span><br></pre></td></tr></table></figure><p><strong>Vanilla Plugin 的调用</strong></p><p><em>Vanilla Plugins 的调用非常简单，只需要在 application/bootstrap.lua 中实现 <code>initPlugin</code> 方法，并调用 <code>dispatcher</code> 的插件注册方法将插件注入项目（ <code>self.dispatcher:registerPlugin(admin_plugin)</code>），即能在对应的时机执行相关钩子对应的方法</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Bootstrap = Class(<span class="string">'application.bootstrap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initPlugin</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> admin_plugin = LoadPlugin(<span class="string">'plugins.admin'</span>):new()</span><br><span class="line">    self.dispatcher:registerPlugin(admin_plugin);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:boot_list</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        Bootstrap.initPlugin,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:__construct</span><span class="params">(dispatcher)</span></span></span><br><span class="line">    self.dispatcher = dispatcher</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Bootstrap</span><br></pre></td></tr></table></figure><p><strong>Vanilla 支持的插件钩子</strong></p><p><em>以下列出 Vanilla 支持的 6 中插件钩子</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:routerStartup</span><span class="params">(request, response)</span></span><span class="comment">-- 开始路由</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:routerShutdown</span><span class="params">(request, response)</span></span><span class="comment">-- 路由结束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:dispatchLoopStartup</span><span class="params">(request, response)</span></span><span class="comment">-- 开始请求分发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:preDispatch</span><span class="params">(request, response)</span></span><span class="comment">-- 预分发（载入相关的 controller）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:postDispatch</span><span class="params">(request, response)</span></span><span class="comment">-- 请求响应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:dispatchLoopShutdown</span><span class="params">(request, response)</span></span><span class="comment">-- 请求分发执行结束</span></span><br></pre></td></tr></table></figure><h3 id="2-6、路由"><a href="#2-6、路由" class="headerlink" title="2.6、路由"></a>2.6、路由</h3><h4 id="2-6-1、Vanilla-的路由体系"><a href="#2-6-1、Vanilla-的路由体系" class="headerlink" title="2.6.1、Vanilla 的路由体系"></a>2.6.1、Vanilla 的路由体系</h4><p><em>Vanilla 实现的路由体系有一个路由器（<code>vanilla.v.router</code>）和若干路由协议构成（Vanilla 默认实现了 <code>vanilla.v.routes.simple</code> 和 <code>vanilla.v.routes.restful</code> 两种路由协议，默认使用 <code>simple</code> 路由来路由请求），请求处理的开始阶段，Vanilla 通过调用路由器协议栈中的各种路由协议，计算出处理当前请求的 <code>controller</code> 和 <code>action</code>，这就是 Vanilla 路由体系的职责所在。如果默认的两种路由协议不能满足你的 URI 路由需求，你可以参考我的一篇<a href="https://my.oschina.net/idevz/blog/603657" target="_blank" rel="noopener">《如何给Vanilla(OpenResty)添加一个路由协议》</a>的博文</em></p><blockquote><p><strong>Vanilla 路由器</strong></p></blockquote><p><em>Vanilla 的路由器 <code>vanilla.v.router</code> 是请求路由的基础，路由器提供了对路由协议的添加 <code>addRoute(route, only_one)</code>，删除 <code>removeRoute(route_name)</code>，获取路由列表 <code>getRoutes()</code> 等方法，用户可以调用这些方法来管理路由协议栈并使用路由器，不过用户不需要关心路由器的实现，而只需要关注路由协议的实现。</em></p><p><strong>给路由器添加一条路由协议</strong></p><p><em>路由器只有唯一一个 <code>vanilla.v.router</code>，但路由协议可以有多个，通过 <code>addRoute(route, only_one)</code> 方法的调用可以向路由协议栈添加一条路由协议，第二个参数为可选参数，当设置为 <code>true</code> 时，代表将清空路由协议栈，只使用当前添加的这条路由协议，因为 Vanilla 路由请求的方式是路由器根据路由协议栈中的路由协议挨条解析，直到找到匹配的 <code>controller</code> 和 <code>action</code> 为止，太多的路由协议栈可能影响路由性能。</em></p><p><strong>删除一条路由协议</strong></p><p><em>Vanilla 的每条路由协议都有 <code>route_name</code> 属性，删除时只需要调用 <code>removeRoute(route_name)</code></em></p><p><strong>获取当前所使用的路由协议</strong></p><p><em>Vanilla 支持获取当前请求所使用的路由协议，只需调用 <code>getCurrentRoute()</code> 方法，调用 <code>getCurrentRouteName()</code> 方法可以获取当前路由协议名</em></p><blockquote><p><strong>路由协议</strong></p></blockquote><p><em>路由协议非常的简单，因为路由协议的关键功能在于为当前请求找到对应的 <code>controller</code> 和 <code>action</code>，核心在于根据当前请求实例 <code>request</code>，通过实现 <code>match</code> 方法，来获取结果，下面是根据 <code>vanilla.v.routes.simple</code> 路由协议提炼出来的路由协议简单骨架：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Simple = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Simple:new</span><span class="params">(request)</span></span></span><br><span class="line">    <span class="keyword">local</span> instance = &#123;</span><br><span class="line">        route_name = <span class="string">'vanilla.v.routes.simple'</span>,</span><br><span class="line">    request = request</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instance, &#123;</span><br><span class="line">        <span class="built_in">__index</span> = self,</span><br><span class="line">        <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="keyword">return</span> self.route_name <span class="keyword">end</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Simple:match</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Simple</span><br></pre></td></tr></table></figure><p><em>注：我们需要关注以下两点</em></p><ul><li><code>route_name</code> 这是路由协议栈索引的关键，协议栈中的路由协议依靠 route_name 进行管理</li><li><code>request</code> 是当前请求的实例，包含了当前请求携带的 URI，http_header 等数据，是请求路由的依据</li></ul><h3 id="2-7、异常处理"><a href="#2-7、异常处理" class="headerlink" title="2.7、异常处理"></a>2.7、异常处理</h3><h4 id="2-7-1、Vanilla-的错误处理"><a href="#2-7-1、Vanilla-的错误处理" class="headerlink" title="2.7.1、Vanilla 的错误处理"></a>2.7.1、Vanilla 的错误处理</h4><p><em>Vanilla 的错误处理分为框架系统错误和应用错误两种类型，系统错误由框架控制，一般导致致命错误，直接抛出 500 内部错误，切不再往下执行，而应用错误则可以通过定义 <code>errorController</code> 来自定义处理</em></p><p><strong>Vanilla 应用错误</strong></p><p><em>Vanilla 提供了方便的错误处理方式，避免当代码运行报错后，页面只显示一个 500 错误的白页，没有详细报错信息，影响开发效率，Vanilla 的应用错误处理非常简单，在业务开发中，我们所关注的各个组件比如 DAO、Service、Controller、Action、Library 等都可能报错，Controller Action 作为 Vanilla 项目处理请求的执行体，一切业务组件的错误都可以通过一个统一的处理口径 <code>errorController</code> 来方便的处理。在业务组件开发过程中的错误，或者用户自定义的错误，都可以在 <code>errorController</code> 中得到捕获和处理，默认初始化的 demo 项目中，application/controllers/ 路径下，默认定义了一个 error.lua 文件，这就是前面所说的 <code>errorController</code>，下面我们具体来看看这段代码：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ErrorController = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> ngx_log = ngx.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">local</span> ngx_redirect = ngx.redirect</span><br><span class="line"><span class="keyword">local</span> os_getenv = <span class="built_in">os</span>.<span class="built_in">getenv</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorController:error</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> env = os_getenv(<span class="string">'VA_ENV'</span>) <span class="keyword">or</span> <span class="string">'development'</span></span><br><span class="line">    <span class="keyword">if</span> env == <span class="string">'development'</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> view = self:getView()</span><br><span class="line">        view:assign(self.err)</span><br><span class="line">        <span class="keyword">return</span> view:display()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">local</span> helpers = <span class="built_in">require</span> <span class="string">'vanilla.v.libs.utils'</span></span><br><span class="line">        ngx_log(ngx.ERR, helpers.sprint_r(self.err))</span><br><span class="line">        <span class="comment">-- return ngx_redirect("http://sina.cn?vt=4", ngx.HTTP_MOVED_TEMPORARILY)</span></span><br><span class="line">        <span class="keyword">return</span> helpers.sprint_r(self.err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> ErrorController</span><br></pre></td></tr></table></figure><p><em>代码释意：（你只需要关注以下几点，即可随意，按需定义适合你的 errorController）</em></p><ul><li>这是一个普通的 LUA 包，一个普通的 Vanilla Controller，唯一需要注意的一点就是需要实现一个 <code>error</code> 方法，注意方法名小写</li><li>可以通过对运行环境的判断来，对不同的运行环境进行不同的错误处理，比如开发环境可能需要直接将错误打印到页面，而生产环境可能需要出错误页面等</li></ul><p><strong>Vanilla 框架系统错误（致命错误）</strong></p><p><em>当有些 Vanilla 项目所必须的配置或者关键步骤执行异常而影响项目往下运行的情况下，会抛出致命错误，并结束当前请求，目前有以下几种情况</em></p><ul><li><strong>关键配置缺少</strong></li></ul><p><em>项目未配置项目名 <code>name</code>，或者未指定项目根路径 <code>root</code>，Vanilla 有很多地方依赖项目名，比如缓存的 KEY 设置，项目的各类包加载依赖于项目根路径做全局加载，多 APP 支持也依赖与此。如果 config/application.lua 中缺少这两个配置，则会如下错误：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sys Err: Please <span class="built_in">set</span> app name and app root <span class="keyword">in</span> config/application.lua like:</span><br><span class="line"></span><br><span class="line">    Appconf.name = <span class="string">'idevz.org'</span></span><br><span class="line">    Appconf.app.root=<span class="string">'/data1/VANILLA_ROOT/idevz.org/'</span></span><br></pre></td></tr></table></figure><ul><li><strong>bootstrap 报错</strong></li></ul><p><em>Bootstrap 中的各种 init 方法并不是必须的，但是如果这部分方法定义后，执行错误，将影响整体项目的正常运行，所以 application/bootstrap.lua 中的运行报错也会报出系统致命错误，举例如下：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initRoute</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> router = self.dispatcher:getRouter()</span><br><span class="line">    <span class="keyword">local</span> restful_route = restful:new(self.dispatcher:getRequest())</span><br><span class="line">    router:addRoute(restful_route, <span class="literal">true</span>)</span><br><span class="line">    print_r(<span class="string">'xx'</span> .. <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><em>注：以上代码，最后一行操作试图将字符串与 bool 值 false 连接，会报出致命错误，如下：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre /&gt;</span><br><span class="line"><span class="string">"...g/idevz/code/www/vanilla/orcon/application/bootstrap.lua:18: attempt to concatenate a boolean value"</span></span><br></pre></td></tr></table></figure><ul><li><strong>dispatch 执行报错</strong></li></ul><p><em>dispatch 属于框架的请求分发操作，请求分发执行出错直接导致致命错误，不过这个错误由框架自己处理，用户不需要关注</em></p><h3 id="2-8、内建类"><a href="#2-8、内建类" class="headerlink" title="2.8、内建类"></a>2.8、内建类</h3><h4 id="2-8-1、Vanilla-的內建变量和方法"><a href="#2-8-1、Vanilla-的內建变量和方法" class="headerlink" title="2.8.1、Vanilla 的內建变量和方法"></a>2.8.1、Vanilla 的內建变量和方法</h4><p><em>为方便业务开发，Vanilla 提供了一些比较实用的內建方法和变量，这里我们说明如下，随着框架的更新，本页面会及时更新，欢迎随时关注。</em></p><p><strong>Vanilla 的內建变量</strong></p><p><em>Vanilla 的內建变量很多来自于 nginx.conf，其他则来自于 <code>ngx.var</code>，Vanilla 将这些变量都缓存在了 Registry 中</em></p><ul><li><strong>Registry 变量</strong></li></ul><p><em>Registry 是 Vanilla 中为了全局数据共享，及高效数据访问而封装的一个全局表，这里缓存了刻画当前请求比较全的数据，具体列表说明如下：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以下数据以 "curl http://domain.org/?arg1=aa1&amp;arg2=aa2" 访问为例进行说明</span></span><br><span class="line">Registry[<span class="string">'APP_CONF'</span>]<span class="comment">-- 当前应用的配置数据，来自于（config/application.lua）</span></span><br><span class="line">Registry[<span class="string">'sys_conf'</span>]<span class="comment">-- 当前应用的系统配置，来自于（sys/*路径，比如可以使用 Registry['sys_conf']['cache'] 获取 sys/cache 文件中关于 cache 的配置）</span></span><br><span class="line">Registry[<span class="string">'REQ_URI'</span>]<span class="comment">-- 当前请求的 URI ，为 "/"</span></span><br><span class="line">Registry[<span class="string">'REQ_ARGS'</span>]<span class="comment">-- 当前请求的参数字符串，即 Query_String，为 "arg1=aa1&amp;arg2=aa2"</span></span><br><span class="line">Registry[<span class="string">'REQ_ARGS_ARR'</span>]<span class="comment">-- 当前请求的参数列表，为一个 LUA 数组</span></span><br><span class="line">Registry[<span class="string">'REQ_HEADERS'</span>]<span class="comment">-- 当前请求的请求头数组</span></span><br><span class="line">Registry[<span class="string">'APP_NAME'</span>] <span class="comment">-- 应用名称</span></span><br><span class="line">Registry[<span class="string">'APP_ROOT'</span>] <span class="comment">-- 应用所在根目录</span></span><br><span class="line">Registry[<span class="string">'APP_HOST'</span>] <span class="comment">-- 当前请求的 HOST 信息</span></span><br><span class="line">Registry[<span class="string">'APP_PORT'</span>] <span class="comment">-- 当前请求的 PORT 信息</span></span><br><span class="line">Registry[<span class="string">'VANILLA_ROOT'</span>] <span class="comment">-- VANIALLA 框架的根目录</span></span><br><span class="line">Registry[<span class="string">'VANILLA_VERSION'</span>] <span class="comment">-- 当前所使用的 VANILLA 版本号</span></span><br><span class="line">Registry[<span class="string">'VANILLA_APPLICATION'</span>] <span class="comment">-- 'vanilla.v.application' LUA 包</span></span><br><span class="line">Registry[<span class="string">'VANILLA_UTILS'</span>] <span class="comment">-- 'vanilla.v.libs.utils' LUA 包</span></span><br><span class="line">Registry[<span class="string">'VANILLA_CACHE_LIB'</span>] <span class="comment">-- 'vanilla.v.cache' LUA 包</span></span><br><span class="line">Registry[<span class="string">'VANILLA_COOKIE_LIB'</span>] <span class="comment">-- 'vanilla.v.libs.cookie' LUA 包</span></span><br><span class="line">Registry[<span class="string">'APP_BOOTS'</span>] <span class="comment">-- 应用 'application.bootstrap' LUA 包</span></span><br><span class="line">Registry[<span class="string">'APP_PAGE_CACHE_CONF'</span>] <span class="comment">-- 应用 Page Cache 相关配置</span></span><br></pre></td></tr></table></figure><p><em>注：上面很多全局变量是从 <code>ngx.var.</code> 获取来的结果缓存的，这样避免每次都请求 <code>ngx.var</code> 而减少这部分性能开销，并且其中有些信息比如 <code>APP_NAME</code>，<code>APP_ROOT</code> 等服务一经启动就不会更改，而像 `REQ_</em><code>相关的数据则是每次请求都不一样，好在一次请求可能对这部分数据会多次调用，所以将其缓存在</code>Registry` 表中*</p><p><strong>Vanilla 的內建函数</strong></p><p><em>Vanilla 有很多内建的函数，这些函数有些来自于 Vanilla 框架本身功能性的一些 LUA 包中，比如 <code>vanilla.v.controller</code>、<code>vanilla.v.request</code>、<code>vanilla.v.response</code> 等，另一些比如通用的方法，比如 <code>print_r</code>、 <code>page_cache</code> 和 <code>vanilla_init</code>，再有比如 Vanilla 定义的各种包加载函数，列表如下：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LoadLibrary <span class="comment">-- 加载项目 library 路径下的 LUA 包</span></span><br><span class="line">LoadController <span class="comment">-- 加载项目 controller</span></span><br><span class="line">LoadModel <span class="comment">-- 加载项目 model 路径下的包，包括 DAO 和 Service</span></span><br><span class="line">LoadPlugin <span class="comment">-- 加载项目 plugins 路径下所定义的插件</span></span><br><span class="line">LoadApplication <span class="comment">-- 加载项目 application 路径下的 LUA 包</span></span><br><span class="line">LoadApp <span class="comment">-- 加载项目根目录下面的 LUA 包</span></span><br><span class="line">LoadV <span class="comment">-- 加载 Vanilla 框架相关的 LUA 包</span></span><br></pre></td></tr></table></figure><p><em>注：以上有些加载器功能重复，目的在于减短所传递参数的长度，比如加载 Index Controller， 使用 LoadController 方法是，只需要写 <code>LoadController(&#39;index&#39;)， 而如果使用方法 LoadApp 则应该写成</code>LoadApp(‘application.controllers.index’)`</em></p><ul><li><strong>方法 <code>page_cache</code></strong></li></ul><p><em>该方法调用 Vanilla 封装的页面缓存逻辑，详细内容参见 (进阶/页缓存)</em></p><ul><li><strong>单步调试方法 <code>print_r</code>、<code>sprint_r</code> 等</strong></li></ul><p><em>调试系列方法主要为了开发时能清晰方便的查看变量状态，记录开发日志等功能，详细内容参见 (快速上手/如何调试)</em></p><ul><li><strong>方法 <code>init_vanilla</code></strong></li></ul><p><em>方法 <code>init_vanilla</code> 主要完成框架基础功能的初始化，比如 Registry 的初始化，各种 Loader 的定义，页面缓存的实现等，本方法默认在应用请求处理入口的第一句语句执行</em></p><h2 id="3、Libs"><a href="#3、Libs" class="headerlink" title="3、Libs"></a>3、Libs</h2><h3 id="3-1、Cookie"><a href="#3-1、Cookie" class="headerlink" title="3.1、Cookie"></a>3.1、Cookie</h3><h4 id="3-1-1、Vanilla-中使用-Cookie"><a href="#3-1-1、Vanilla-中使用-Cookie" class="headerlink" title="3.1.1、Vanilla 中使用 Cookie"></a>3.1.1、Vanilla 中使用 Cookie</h4><p><em>Vanilla 中封装了 <code>vanilla.v.libs.cookie</code> 包，源至 <a href="https://github.com/cloudflare/lua-resty-cookie" target="_blank" rel="noopener"><code>lua-resty-cookie</code></a>，提供了简单的 <code>get</code>、<code>set</code>、<code>getAll</code> 等方法来控制 Cookie，下面具体使用举例如下：</em></p><p><strong>vanilla.v.libs.cookie 包使用</strong></p><p><em>一例胜千言：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 载入 vanilla.v.libs.cookie 包</span></span><br><span class="line"><span class="keyword">local</span> vcookie_lib = LoadV(<span class="string">'vanilla.v.libs.cookie'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 实例化 vanilla.v.libs.cookie 类</span></span><br><span class="line">    <span class="keyword">local</span> cookie = vcookie_lib()</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 调用 set 方法，设置 cookie</span></span><br><span class="line">    cookie:set(<span class="string">'idevz'</span>, <span class="string">'kkkk'</span>, &#123;expires=<span class="number">1000</span>&#125;)</span><br><span class="line">    cookie:set(<span class="string">'idevz_api'</span>, <span class="string">'kkkk'</span>, &#123;expires=<span class="number">1000</span>,<span class="built_in">path</span>=<span class="string">'/'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 调用 getAll 方法，获取所有 cookie，也可以调用 get 获取单个cookie</span></span><br><span class="line">    print_r(cookie:getAll())</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure><p><em>注：</em></p><p><em><code>vanilla.v.libs.cookie</code> 支持以下 cookie 选项</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span></span><br><span class="line">domain</span><br><span class="line">max_age</span><br><span class="line">secure</span><br><span class="line">httponly</span><br><span class="line">samesite</span><br><span class="line">extension</span><br></pre></td></tr></table></figure><h2 id="4、进阶"><a href="#4、进阶" class="headerlink" title="4、进阶"></a>4、进阶</h2><h3 id="4-1、页缓存"><a href="#4-1、页缓存" class="headerlink" title="4.1、页缓存"></a>4.1、页缓存</h3><h4 id="4-1-1、Vanilla-的-Page-Cache"><a href="#4-1-1、Vanilla-的-Page-Cache" class="headerlink" title="4.1.1、Vanilla 的 Page Cache"></a>4.1.1、Vanilla 的 Page Cache</h4><p><em>vanilla 的 Page Cache 实现了类似 Nginx 的 FastCGICache 或者 ProxyCache 的访问结果整体缓存，以 URI 的一定规则作为缓存的 KEY，属于内存型 Cache，存储位置可配置，默认存储在 OpenResty 共享字典（Share Dict）中，默认生成的项目中 Page Cache 为关闭状态</em></p><blockquote><p><strong>Page Cache 相关配置</strong></p></blockquote><p><em>Page Cache 相关的所有配置见项目的 config/application.lua 中， <code>Appconf.page_cache</code> 相关配置段，如下所示：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Appconf.page_cache = &#123;&#125;</span><br><span class="line">Appconf.page_cache.cache_on = <span class="literal">true</span></span><br><span class="line"><span class="comment">-- Appconf.page_cache.cache_handle = 'lru'</span></span><br><span class="line">Appconf.page_cache.no_cache_cookie = <span class="string">'va-no-cache'</span></span><br><span class="line">Appconf.page_cache.no_cache_uris = &#123;</span><br><span class="line">    <span class="string">'uris'</span></span><br><span class="line">&#125;</span><br><span class="line">Appconf.page_cache.build_cache_key_without_args = &#123;<span class="string">'rd'</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>配置释意</strong></p><ul><li>cache_on 缓存开关，true 为开启 Page Cache，false 则为关闭</li><li>cache_handle 设置 Page Cache 的存储介质，目前支持 Memcache、Redis、resty.lrucache、OpenResty Share Dict，默认为 OpenResty Share Dict</li><li>no_cache_cookie 设置不缓存的 cookie KEY，Vanilla Page Cache 使用这个设置所指的 cookie KEY 来对某些特殊页面不缓存，默认当页面中有 KEY 为 <code>va-no-cache</code> 这个 COOKIE 的时候，当前页面不缓存</li><li>no_cache_uris 设置不缓存的 URI 列表，默认配置例如 <a href="http://app.com/uris" target="_blank" rel="noopener">http://app.com/uris</a> 命中 <code>uris</code> 则，当前页面不缓存</li><li>build_cache_key_without_args 设置在缓存 KEY 中去除某些参数，比如某些 API 的版本号，或者随机数等，默认配置中的 <code>rd</code> 设置代表，当 URI 中有 rd 参数时，则生成的 Page Cache KEY 中清除这个参数</li></ul><p><em>注：缓存的清理，只需要在请求的 URL 中，添加参数 <code>vapurge</code></em></p><h3 id="4-2、面向对象"><a href="#4-2、面向对象" class="headerlink" title="4.2、面向对象"></a>4.2、面向对象</h3><h4 id="4-2-1、面向对象的-Vanilla"><a href="#4-2-1、面向对象的-Vanilla" class="headerlink" title="4.2.1、面向对象的 Vanilla"></a>4.2.1、面向对象的 Vanilla</h4><p><em>Lua 提供了部分面向对象的语法糖，这仅仅能在开发中提供一个功能不完备的独立 Class 的使用，有 <code>self</code> 可以来引用 LUA 表的某些属性和方法，但是更多的面向对象特性，比如继承，比如类的构造等，LUA 支持的并不是非常好，日常的业务开发中，我们确实有些通用的逻辑可能需要复用，或者数据需要共享，需要有父子关系等等。所以我们在 Vanilla 中，简单封装了部分面向对象的特性，这里我们简单介绍其使用方法。</em></p><blockquote><p><strong>一个简单的 Vanilla 类</strong></p></blockquote><p><em>下面我们看一个例子：</em></p><p><strong>类定义</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibA = Class(<span class="string">"LibA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LibA:idevzDo</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> params = params <span class="keyword">or</span> &#123; lib_bb = <span class="string">'idevzDo LibA'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LibA:__construct</span><span class="params">( data )</span></span></span><br><span class="line">    self.name = <span class="string">'name--&gt;'</span> .. data.name</span><br><span class="line">    self.sex = <span class="string">'sex--&gt;'</span> .. data.sex</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> LibA</span><br></pre></td></tr></table></figure><p><em>代码释意：</em></p><ul><li><code>Class(&quot;LibA&quot;)</code> 声明一个 Vanilla 类，类名为 <code>LibA</code></li><li><code>LibA:__construct( data )</code> 提供了一个类 LibA 的构造器，并对相应的属性进行初始化</li></ul><p><strong>类使用</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibA = LoadLibrary(<span class="string">'aa'</span>)</span><br><span class="line"><span class="keyword">local</span> liba_instance = LibA(&#123;name=<span class="string">'idevz'</span>,sex=<span class="string">'man'</span>&#125;)</span><br><span class="line">print_r(liba_instance.sex)</span><br></pre></td></tr></table></figure><p><em>执行结果 <code>sex--&gt;man</code></em></p><p><em>代码释意：（类使用的时候需要注意，类的使用分为类文件的加载 <code>Load( 如这里的 LoadLibrary )</code> 和实例化 <code>LibA()</code>） 两个步骤</em></p><ul><li><code>local LibA = LoadLibrary(&#39;aa&#39;)</code> 载入类名为 <code>LibA</code> 的类</li><li><code>local liba_instance = LibA({name=&#39;idevz&#39;,sex=&#39;man&#39;})</code> 传入表 <code>{name=&#39;idevz&#39;,sex=&#39;man&#39;}</code> 对类进行相关的实例化</li><li><code>liba_instance.sex</code> 是对实例属性的引用</li></ul><p><em>注：载入和实例化也可以一步达成 <code>local liba_instance = LoadLibrary(&#39;aa&#39;)({name=&#39;idevz&#39;,sex=&#39;man&#39;})</code></em></p><blockquote><p><strong>类继承</strong></p></blockquote><p><em>下面我么定义一个类 LibB，并使之集成于 LibA</em></p><p><strong>类定义</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibB = Class(<span class="string">"LibB"</span>, LoadLibrary(<span class="string">'LibA'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LibB:__construct</span><span class="params">( data )</span></span></span><br><span class="line"><span class="keyword">local</span> data = data <span class="keyword">or</span> &#123;name=<span class="string">'kk'</span>, sex=<span class="string">'xxx'</span>&#125;</span><br><span class="line">data.sex = data.sex .. <span class="string">'--&gt;son'</span></span><br><span class="line">self.parent:__construct(data)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> LibB</span><br></pre></td></tr></table></figure><p><em>代码释意：</em></p><ul><li><code>Class(&quot;LibB&quot;, LoadLibrary(&#39;LibA&#39;))</code> 声明一个 Vanilla 类，类名为 <code>LibB</code> 继承自类 <code>LibA</code></li><li><code>self.parent:__construct(data)</code> 构造器中调用父类的构造器</li></ul><p><strong>类使用</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibB = LoadLibrary(<span class="string">'LibB'</span>)</span><br><span class="line"><span class="keyword">local</span> libb_instance = LibB(&#123;name=<span class="string">'idevz'</span>,sex=<span class="string">'man'</span>&#125;)</span><br><span class="line">print_r(libb_instance:idevzDo(&#123;doo=<span class="string">'xxx'</span>&#125;)[<span class="string">'doo'</span>])</span><br></pre></td></tr></table></figure><p><em>执行结果 <code>xxx</code></em></p><p><em>代码释意：</em></p><ul><li><code>libb_instance:idevzDo</code> 调用父类的 <code>idevzDo</code> 方法</li></ul><h3 id="4-3、Vanilla-包开发"><a href="#4-3、Vanilla-包开发" class="headerlink" title="4.3、Vanilla 包开发"></a>4.3、Vanilla 包开发</h3><h4 id="4-3-1、Vanilla-的包开发"><a href="#4-3-1、Vanilla-的包开发" class="headerlink" title="4.3.1、Vanilla 的包开发"></a>4.3.1、Vanilla 的包开发</h4><p><em>可以使用任意 LUA 包的开发方式来开发 Vanilla 包（Controllers，Library，Dao，Services等），也可以使用 Vanilla 所提供的 (面向对象) 方式进行开发</em></p><p><strong>对 Controller 使用继承和构造器</strong></p><p><em>下面我们看一个例子：</em></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = Class(<span class="string">'controllers.index'</span>,</span><br><span class="line">    LoadApplication(<span class="string">'controllers.base'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:__construct</span><span class="params">()</span></span></span><br><span class="line">    self.parent:__construct()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure><h2 id="5、OpenResty"><a href="#5、OpenResty" class="headerlink" title="5、OpenResty"></a>5、OpenResty</h2><h3 id="5-1、OR文档精炼"><a href="#5-1、OR文档精炼" class="headerlink" title="5.1、OR文档精炼"></a>5.1、OR文档精炼</h3><p><strong>OR文档精炼</strong></p><p><em>感谢春哥给我们带来这么好的平台，在这里希望能通读 OR 文档，把自己的理解记录下来，并与时俱进的更新</em></p><h4 id="5-1-1、描述-Description"><a href="#5-1-1、描述-Description" class="headerlink" title="5.1.1、描述 / Description"></a>5.1.1、描述 / Description</h4><p><code>lua-nginx-module</code> 模块通过标准的 Lua 5.1 解释器，或者 LuaJIT 2.0/2.1 在 Nginx 运行环境中嵌入 Lua，并利用 Nginx 的子请求，允许在 Nginx 的时间模块中集成强大的 Lua 线程（Lua 协程）。</p><p>与 Apache 的 <code>mod_lua</code> 和 Lighttpd 的 <code>mod_magnet</code> 不同的是，只要使用 <code>lua-nginx-module</code> 模块为 Lua 提供的 Nginx API 来处理上游服务的请求，诸如 MySQL、PostgreSQL、Memcached、Redis 或者上游的 HTTP Web 服务，网络传输都是 100% 非阻塞的。</p><p>至少下面列举的这些 Lua 包，和 Nginx 模块可以与 <code>ngx_lua</code> 模块完美结合使用：</p><h4 id="5-1-2、ngx-timer"><a href="#5-1-2、ngx-timer" class="headerlink" title="5.1.2、ngx.timer"></a>5.1.2、ngx.timer</h4><blockquote><p><strong>ngx.timer.at</strong></p></blockquote><p><em>语法：</em></p><p><code>ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)</code></p><p><em>上下文：</em></p><p><code>init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p><p><em>使用一个自定义函数以及可选的自定义参数创建一个 Nginx 计时器</em></p><p>第一个参数 <code>delay</code> 以秒为单位指定计时器的延迟时间，支持分秒设置，比如 0.001 在这里表示 1 毫秒延迟。<code>delay</code> 同样可以设置为 0 ，此时如果当前句柄正被唤醒则计时器将立即获得执行。（in which case the timer will immediately expire when the current handler yields execution.//TODO yields）</p><p>第二个参数 <code>callback</code> 可以是任何 Lua 函数，后期延迟时间到了，该函数将被以一个后台 “轻线程” 的形式被调用。这个自定义的回调函数将被 Nginx 核心使用 <code>premature</code> 参数、user_arg1、user_arg2 等参数自动调用，参数 <code>premature</code> 是一个 boolean 值，表示当前定时器是否过期以后，而 user_arg1、user_arg2 等参数就是调用 <code>ngx.timer.at</code> 时所传递的余下参数列表。</p><p>当 Nginx 工作进程尝试关闭，比如在 Nginx 由于收到 HUP 信号而触发了 Nginx 配置重载的时候，或者 Nginx 服务正在关闭的时候，将会出现无效的计时器（//TODO Premature timer）。当 Nginx 工作进程尝试关闭，将无法通过调用 <code>ngx.timer.at</code> 来创建一个新的非零延迟的计时器，并且此时 <code>ngx.timer.at</code> 将返回 <code>nil</code> 和 “process exiting” 错误。</p><p>这个 API 从 v0.9.3 版本开始，即使 Nginx 工作进程开始关闭的时候，仍然允许创建零延迟计时器。</p><p>当一个计时器到期时，计时器中用户定义回调的 Lua 代码将在一个与创建这个计时器的源请求完全隔离的 “轻线程” 中运行，所以，源请求生命周期内的对象，比如 <code>cosockets</code> 并不能与回调函数共享。</p><p>下面来看一个简单的例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"> ...</span><br><span class="line"> log_by_lua_block &#123;</span><br><span class="line">     <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">push_data</span><span class="params">(premature, uri, args, status)</span></span></span><br><span class="line">         <span class="comment">-- push the data uri, args, and status to the remote</span></span><br><span class="line">         <span class="comment">-- via ngx.socket.tcp or ngx.socket.udp</span></span><br><span class="line">         <span class="comment">-- (one may want to buffer the data in Lua a bit to</span></span><br><span class="line">         <span class="comment">-- save I/O operations)</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">local</span> ok, err = ngx.timer.at(<span class="number">0</span>, push_data,</span><br><span class="line">                                  ngx.var.uri, ngx.var.args, ngx.header.<span class="built_in">status</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">         ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to create timer: "</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以创建一个无限执行的计时器，例如，一个每 5 秒触发执行一次的计时器，在它的回调方法中递归的调用 <code>ngx.timer.at</code> ，这里给出这样的一个例子。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> delay = <span class="number">5</span></span><br><span class="line"><span class="keyword">local</span> handler</span><br><span class="line">handler = <span class="function"><span class="keyword">function</span> <span class="params">(premature)</span></span></span><br><span class="line"> <span class="comment">-- do some routine job in Lua just like a cron job</span></span><br><span class="line"> <span class="keyword">if</span> premature <span class="keyword">then</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">local</span> ok, err = ngx.timer.at(delay, handler)</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">     ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to create the timer: "</span>, err)</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok, err = ngx.timer.at(delay, handler)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line"> ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to create the timer: "</span>, err)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因为定时器的回调函数都是运行在后端，而且他们的运行时间不会叠加到客户端请求的相应时间中，它们可能会因为 Lua 语法错误，或者过多的客户端请求而很容易在服务端造成累积，或者耗尽系统资源。为了防止出现像 Nginx 服务器宕机这种极端结果，在一个 Nginx 工作进程中提供了对 “等待中的计时器” 和 “运行中的计时器” 这两种计时器的数量限制。这里 “等待中的计时器” 是指还没有过期的计时器，而 “运行中的计时器” 是指那些用户回调方法当前正在运行的计时器。</p><p>一个 Nginx 进程中所允许的 “等待中的计时器” 允许的最大数量由 <code>lua_max_pending_timers</code> 指令控制。而允许的 “运行中的计时器” 允许的最大数量由 <code>lua_max_running_timers</code> 指令控制。</p><p>目前的实现，每个 “运行中的计时器” 都会从 nginx.conf 配置中 <code>worker_connections</code> 指令配置的全局连接列表中占用一个 （虚） 连接记录，所以必须确保 <code>worker_connections</code> 指令设置了一个足够大的值能同时包含真正的连接数和计时器回调函数运行所需要的虚连接数（这个连接数是有 <code>lua_max_running_timers</code> 指令设限的）。</p><p>许多 Nginx 的 Lua API 能在计时器回调函数的上下文中使用，比如操作流和数据包的 cosockets API（<code>ngx.socket.tcp</code> 和 <code>ngx.socket.udp</code>），共享内存字典（<code>ngx.shared.DICT</code>），用户协程函数（<code>coroutine.*</code>），用户“轻线程”（<code>ngx.thread.*</code>），<code>ngx.exit</code>，<code>ngx.now/ngx.time</code>，<code>ngx.md5/ngx.sha1_bin</code>等都是可用的，但是相关子请求的 API （诸如<code>ngx.location.capture</code>），<code>ngx.req.* API</code>，下游输出 API （诸如 <code>ngx.say</code>，<code>ngx.print</code> 和 <code>ngx.flush</code>）都是明确在此上下文中不支持的。</p><p>你可以给计时器的回调函数传递大部分的标准 Lua 值类型（nils、布尔、数字、字符串、表、闭包、文件句柄等），要么显示的使用用户参数或者隐式的使用回调函数闭包的上游值。然而有一些例外诸如：你不能传递任何由 <code>coroutine.create</code> 和 <code>ngx.thread.spawn</code> 返回的线程对象，或者任何由 <code>ngx.socket.tcp</code>、<code>ngx.socket.udp</code> 和 <code>ngx.req.socket</code> 返回的 cosocket 对象，因为这些对象的生命周期是与创建他们的请求上下文绑定的，而计时器的回调函数（设计时）是与创建他们的请求上下文分离的，并且运行在它自己的（虚）请求上下文中。如果你试图跨越创建这些线程和 cosocket 的请求上下文边界来共享这些线程和 cosocket 对象，将会报错，对线程将报错 <code>no co ctx found</code>，对 cosocket 将报错 <code>bad request</code>，然而在计时器回调函数内部来创建这些对象则是没问题的。</p><p>这个 API 在 v0.8.0 版本第一次释出。</p><blockquote><p><strong>ngx.timer.running_count</strong></p></blockquote><p><em>语法：</em></p><p><code>count = ngx.timer.running_count()</code></p><p><em>上下文：</em></p><p><code>init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p><p><em>返回当前正在运行的计时器数量。</em><br>这个指令在 v0.9.20 版本第一次释出。</p><blockquote><p><strong>ngx.timer.pending_count</strong></p></blockquote><p><em>语法：</em></p><p><code>count = ngx.timer.pending_count()</code></p><p><em>上下文：</em></p><p><code>init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p><p><em>返回当前正在等待的计时器数量。</em><br>这个指令在 v0.9.20 版本第一次释出。</p><h4 id="5-1-3、ngx-config"><a href="#5-1-3、ngx-config" class="headerlink" title="5.1.3、ngx.config"></a>5.1.3、ngx.config</h4><blockquote><p><strong>ngx.config.subsystem</strong></p></blockquote><p><em>语法：</em></p><p><code>subsystem = ngx.config.subsystem</code></p><p><em>上下文：</em></p><p><code>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</code></p><p><em>这个字符串字段表示了当前基于哪个 Nginx 子系统，对当前模块（ngx_stream_lua_module），这个字段始终返回 “http”，而对 ngx_stream_lua_module 模块，这个字段将返回 “stream”</em></p><p>这个字段在 v0.10.1 版本第一次释出。</p><blockquote><p><strong>ngx.config.debug</strong></p></blockquote><p><em>语法：</em></p><p><code>debug = ngx.config.debug</code></p><p><em>上下文：</em></p><p><code>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</code></p><p>*这个布尔字段表示了当前 Nginx 是否打开 debug 编译选项，如编译时配置为 <code>./configure option --with-debug</code>。</p><p>这个字段在 v0.8.7 版本第一次释出。</p><h4 id="5-1-4、coroutine"><a href="#5-1-4、coroutine" class="headerlink" title="5.1.4、coroutine"></a>5.1.4、coroutine</h4><blockquote><p><strong>coroutine.create</strong></p></blockquote><p><em>语法：</em></p><p><code>co = coroutine.create(f)</code></p><p><em>上下文：</em></p><p><code>rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p><p><em>使用 Lua 函数创建一个用户态 Lua 协程， 并返回一个协程对象。与标准 Lua 中的协程创建的 API <code>coroutine.create</code> 类似，但是工作在 ngx_lua 模块创建的 Lua 协程上下文中，这个 API 第一次是被使用在 0.9.2 版本的 `init_by_lua</em>` 上下文中。*</p><p>这个 API 在 v0.6.0 版本第一次释出。</p><h4 id="5-1-5、ngx-thread"><a href="#5-1-5、ngx-thread" class="headerlink" title="5.1.5、ngx.thread"></a>5.1.5、ngx.thread</h4><blockquote><p><strong>ngx.config.subsystem</strong></p></blockquote><p><em>语法：</em></p><p><code>co = ngx.thread.spawn(func, arg1, arg2, ...)</code></p><p><em>上下文：</em></p><p><code>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</code></p><p><em>使用 Lua 函数 <code>func</code> 以及可选的参数 <code>arg1</code>，<code>arg2</code> 等生成一个新的用户“轻线程”，返回一个 Lua 线程（或者 Lua 协程）对象代表这个 “轻线程”</em><br>“轻线程”仅仅是一种特殊的由 <code>ngx_lua</code> 模块来调度的 Lua 协程。<br>在 <code>ngx.thread.spawn</code> 返回之前， <code>func</code> 函数将会被使用响应的可选参数进行调用，直到此函数调用返回、或者因为错误而终止或是因为通过使用 Nginx 的 I/O 操作 API 导致请求挂起（如 <code>tcpsock:receive</code> 操作）。<br>在 <code>ngx.thread.spawn</code> 返回后，新被创建的“轻线程”将在各种 I/O 事件中保持通常的异步运行。</p><p>所有在 <code>rewrite_by_lua</code>、<code>access_by_lua</code> 和 <code>content_by_lua</code> 运行的 Lua 代码块都在一个由 ngx_lua 自动创建的样板“轻线程”中，这些样板“轻线程”通常又叫“入口线程”。</p><p>默认情况下，相应的 Nginx 处理程序（例如 <code>rewrite_by_lua</code> 处理程序）不会终止直到“入口线程”和所有的用户“轻线程”都终止，一个“轻线程（要么是“入口线程”要么是“用户轻线程”因为调用 <code>ngx.exit</code>，<code>ngx.exec</code>，<code>ngx.redirect</code> 或者 <code>ngx.req.set_uri(uri, true)</code>）或者“入口线程”因为报错而终止。<br>当一个用户“轻线程”因为报错而终止，他将不会像“入口线程”一样终止其他线程的运行。</p><p>因为 Nginx 子请求模块的限制，一般不允许中止一个正在运行中的 Nginx 子请求。所以同样禁止中止一个运行中的正在等待一个或多个 Nginx 子请求的“轻线程”。你应该调用 <code>ngx.thread.wait</code> 来在结束前等待这些“轻线程”结束。这里有个值得注意的例外是你可以通过使用而且只能使用 <code>ngx.ERROR(-1),408,444或者499</code> 状态调用 <code>ngx.exit</code> 来中止等待的子请求。</p><p>“轻线程”不是使用预先抢占的方式来调度的，换句话说，没有自动执行的时间片，一个“轻线程”将保持在 CPU 运行，直到一个（非阻塞）I/O 操作在一个单线程运行不能被完成。</p><p>The “light threads” are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A “light thread” will keep running exclusively on the CPU until<br>a (nonblocking) I/O operation cannot be completed in a single run,<br>it calls coroutine.yield to actively give up execution, or<br>it is aborted by a Lua error or an invocation of ngx.exit, ngx.exec, ngx.redirect, or ngx.req.set_uri(uri, true).<br>For the first two cases, the “light thread” will usually be resumed later by the ngx_lua scheduler unless a “stop-the-world” event happens.</p><p>User “light threads” can create “light threads” themselves. And normal user coroutines created by coroutine.create can also create “light threads”. The coroutine (be it a normal Lua coroutine or a “light thread”) that directly spawns the “light thread” is called the “parent coroutine” for the “light thread” newly spawned.</p><p>The “parent coroutine” can call ngx.thread.wait to wait on the termination of its child “light thread”.</p><p>You can call coroutine.status() and coroutine.yield() on the “light thread” coroutines.</p><p>The status of the “light thread” coroutine can be “zombie” if</p><p>the current “light thread” already terminates (either successfully or with an error),<br>its parent coroutine is still alive, and<br>its parent coroutine is not waiting on it with ngx.thread.wait.<br>The following example demonstrates the use of coroutine.yield() in the “light thread” coroutines to do manual time-slicing:</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;&lt;em&gt;香草/Vanilla是一个基于Openresty实现的高性能Web应用开发框架.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img 
      
    
    </summary>
    
    
      <category term="Lua" scheme="https://www.shengguocun.com/tags/Lua/"/>
    
      <category term="Vanilla" scheme="https://www.shengguocun.com/tags/Vanilla/"/>
    
      <category term="中文文档" scheme="https://www.shengguocun.com/tags/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Nginx初探</title>
    <link href="https://www.shengguocun.com//blog/2018/08/01/nginx-book/"/>
    <id>https://www.shengguocun.com//blog/2018/08/01/nginx-book/</id>
    <published>2018-08-01T10:51:04.000Z</published>
    <updated>2018-08-01T10:54:04.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.shengguocun.com/tags/Nginx/"/>
    
      <category term="基础概念" scheme="https://www.shengguocun.com/tags/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>基于Go语言的简易基金定投系统</title>
    <link href="https://www.shengguocun.com//blog/2018/05/18/automatic-investment-plan-by-golang/"/>
    <id>https://www.shengguocun.com//blog/2018/05/18/automatic-investment-plan-by-golang/</id>
    <published>2018-05-18T13:30:07.000Z</published>
    <updated>2018-05-30T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p>在平时基金定投的过程中，因为各家基金公司的系统定投系统功能太过单一，即使定期不定额的方式也不能满足多个梯度的自定义的需求，只能设置高于成本某个阈值或者低于成本某个阈值设置相应的定投值；但是我们想有梯度的定投而不是简单的三个点。为了满足当前我的简单的需求（希望能够有更灵活的自定义定投设置），靠人不如靠自己，下面就开始吧。</p><h2 id="1、概念介绍"><a href="#1、概念介绍" class="headerlink" title="1、概念介绍"></a>1、概念介绍</h2><h4 id="净值估算"><a href="#净值估算" class="headerlink" title="净值估算"></a>净值估算</h4><p>净值估算每个交易日9：30-15：00盘中实时更新（QDII基金为海外交易时段），是按照基金持仓、指数走势和基金过往业绩估算，估算数据并不代表真实净值，仅供参考，请以基金管理人披露净值为准。</p><h4 id="指数温度"><a href="#指数温度" class="headerlink" title="指数温度"></a>指数温度</h4><p>指数温度 = ( PE + PB ) / 2</p><h4 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h4><p>PE就是我们一般所说的市盈率，即每股股价与每股收益的比率．用来反映投资该股票的风险，一般来说比率越低越安全；</p><h4 id="PB"><a href="#PB" class="headerlink" title="PB"></a>PB</h4><p>PB即市净率。市净率 = 股票市价 / 每股净资产，市净率越低的股票，其投资价值越高。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0、前言&quot;&gt;&lt;a href=&quot;#0、前言&quot; class=&quot;headerlink&quot; title=&quot;0、前言&quot;&gt;&lt;/a&gt;0、前言&lt;/h2&gt;&lt;p&gt;在平时基金定投的过程中，因为各家基金公司的系统定投系统功能太过单一，即使定期不定额的方式也不能满足多个梯度的自定义的需求，只
      
    
    </summary>
    
    
      <category term="Go语言" scheme="https://www.shengguocun.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
      <category term="基金" scheme="https://www.shengguocun.com/tags/%E5%9F%BA%E9%87%91/"/>
    
      <category term="定投" scheme="https://www.shengguocun.com/tags/%E5%AE%9A%E6%8A%95/"/>
    
  </entry>
  
  <entry>
    <title>A Bite of Golang</title>
    <link href="https://www.shengguocun.com//blog/2018/04/20/a-bite-of-golang/"/>
    <id>https://www.shengguocun.com//blog/2018/04/20/a-bite-of-golang/</id>
    <published>2018-04-20T06:54:03.000Z</published>
    <updated>2018-05-14T08:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些小的经验，同时为了方便让读者了解到Go语言中的一些概念，文中包含了许多快速简洁的例子，读者后期可以去自行拓展。当然写这篇文章的灵感来源于GitHub上的 a bite of Python</p><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-0、环境搭建"><a href="#1-0、环境搭建" class="headerlink" title="1.0、环境搭建"></a>1.0、环境搭建</h3><h4 id="1、下载安装包安装"><a href="#1、下载安装包安装" class="headerlink" title="1、下载安装包安装"></a>1、下载安装包安装</h4><p>通过浏览器访问下面的地址 <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> 要是自己的网络不能翻墙的话，可以访问下面的Go语言中文网 <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a> 下载指定的版本的安装包直接下一步就可以安装完成；</p><h4 id="2、命令行安装"><a href="#2、命令行安装" class="headerlink" title="2、命令行安装"></a>2、命令行安装</h4><p>Mac 利器 home brew 安装 go</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade</span><br><span class="line">brew install git</span><br><span class="line">brew install mercurial</span><br><span class="line">brew install go</span><br></pre></td></tr></table></figure><p>安装完成之后</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GOROOT</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOROOT</span>=/usr/local/Cellar/go/1.7.4/libexec</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOPATH</span>=<span class="variable">$HOME</span>/GoLangProject</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH bin</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOPATH/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH root bin</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOROOT/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>OK配合完成之后,输入go env验证一下是否配置成功</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~ sheng$ go env</span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"darwin"</span></span><br><span class="line">GOOS=<span class="string">"darwin"</span></span><br><span class="line">GOPATH=<span class="string">"/Users/verton/GoLangProject"</span></span><br><span class="line">GORACE=<span class="string">""</span></span><br><span class="line">GOROOT=<span class="string">"/usr/local/Cellar/go/1.7.4/libexec"</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/usr/local/Cellar/go/1.7.4/libexec/pkg/tool/darwin_amd64"</span></span><br><span class="line">CC=<span class="string">"clang"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/z2/h48yrw8131g824_bvtw6584r0000gn/T/go-build415367881=/tmp/go-build -gno-record-gcc-switches -fno-common"</span></span><br><span class="line">CXX=<span class="string">"clang++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br></pre></td></tr></table></figure><h3 id="1-1、变量定义"><a href="#1-1、变量定义" class="headerlink" title="1.1、变量定义"></a>1.1、变量定义</h3><h4 id="1、通过var关键字"><a href="#1、通过var关键字" class="headerlink" title="1、通过var关键字"></a>1、通过var关键字</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> int</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> string</span><br></pre></td></tr></table></figure><p>在Go语言中在定义变量的时候，是变量在前类型在后，现在你暂时先不用考虑那么多为什么，就先知道Go是这样的定义形式就可以了；当然可以多个变量一起定义,同时可以一起赋初值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c bool</span><br><span class="line"><span class="selector-tag">var</span> m,n string = <span class="string">"Hello"</span>,<span class="string">"World"</span></span><br><span class="line"><span class="selector-tag">var</span> (</span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line">    bb = <span class="string">"hello world"</span></span><br><span class="line">    cc = true</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然也可以让编译器自动决定类型，比如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s,m,<span class="selector-tag">p</span>,<span class="selector-tag">q</span> = <span class="number">1</span>,<span class="string">"hahah"</span>,false,<span class="string">"xixiix"</span></span><br></pre></td></tr></table></figure><h4 id="2、使用-定义变量"><a href="#2、使用-定义变量" class="headerlink" title="2、使用 := 定义变量"></a>2、使用 := 定义变量</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s,m,<span class="selector-tag">p</span>,<span class="selector-tag">q</span> := <span class="number">1</span>,<span class="string">"hahah"</span>,false,<span class="string">"xixiix"</span></span><br></pre></td></tr></table></figure><p>这样呢可以让代码写的更加简短一点，当然呢 := 只能在函数内使用，是不能在函数外使用的。（相关的函数的知识后面会做介绍）</p><h3 id="1-2、内建变量类型"><a href="#1-2、内建变量类型" class="headerlink" title="1.2、内建变量类型"></a>1.2、内建变量类型</h3><h4 id="1、bool-、string"><a href="#1、bool-、string" class="headerlink" title="1、bool 、string"></a>1、bool 、string</h4><p>这两个类型就不做过多的介绍，因为基本每一门语言里面都有这两个类型，在Go语言里面也是一样的</p><h4 id="2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr"><a href="#2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr" class="headerlink" title="2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr"></a>2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr</h4><p>上面这些就是Go的整数类型，加u和不加u的区别就是有无符号的区别，Go语言中的整数类型还分为两个大类，一个是规定长度的，比如：int8、int16、int32…，还有一种就是不规定长度的，它是根据操作系统来，在32位系统就是32位，在64位系统就是64位的，Go语言中没有int、long 这些类型，你想要定义一个相对较长的定义int64就可以了，最后uintptr就是Go语言的指针，后面我会再来介绍它</p><h4 id="3、byte、rune"><a href="#3、byte、rune" class="headerlink" title="3、byte、rune"></a>3、byte、rune</h4><p>byte就不用过多介绍了，大家都知道字节类型，那rune是什么呢，这就是Go语言的“char”，因为char只有一个字节在使用中会有很多的坑，Go语言针对这点痛点做了一些优化</p><h4 id="4、float32、float64、complex64、complex128"><a href="#4、float32、float64、complex64、complex128" class="headerlink" title="4、float32、float64、complex64、complex128"></a>4、float32、float64、complex64、complex128</h4><p>前面两个不过多介绍，浮点数类型32位和64位的，后面两个是一个复数的类型，complex64实部和虚部都是32位的，complex128实部和虚部都是64位的</p><h3 id="1-3、常量与枚举"><a href="#1-3、常量与枚举" class="headerlink" title="1.3、常量与枚举"></a>1.3、常量与枚举</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = <span class="number">1</span></span><br><span class="line">const b,c = <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">const (</span><br><span class="line">    d = <span class="number">5</span></span><br><span class="line">    e,f = <span class="number">6</span>,<span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量数值可以作为各种类型使用,比如以下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s,<span class="selector-tag">p</span> = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">m := math.Sqrt(s*s + p*p)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure><p>这段代码语法是编译不通过的，因为Sqrt的参数必须是一个浮点数类型；但是呢我们把是s、p定义成常量就可以编译通过了</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s,p = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">m := math.<span class="built_in">Sqrt</span>(s*s + p*p)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure><p>Go语言中的枚举类型就是通过const来实现，同时Go语言中还可以通过iota实现自增的功能</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func enums()&#123;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line"><span class="selector-tag">a</span> = iota</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br><span class="line">fmt.Println(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面这个函数显而易见，会输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="1-4、条件语句"><a href="#1-4、条件语句" class="headerlink" title="1.4、条件语句"></a>1.4、条件语句</h3><h4 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h4><p>正常的条件判断我这边就不做过多的介绍，当然Go语言有它特别的地方，if的条件里可以赋值，比如：</p><p>举个读文件的例子，ioutil.ReadFile 这个方法有两个返回值，后面会详细的讲解，常规的写法是</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename  = <span class="string">"file.txt"</span></span><br><span class="line">content,<span class="keyword">err</span> := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="built_in">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言可以整合成下面的写法</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename  = <span class="string">"file.txt"</span></span><br><span class="line"><span class="keyword">if</span> content,<span class="keyword">err</span> := ioutil.ReadFile(filename); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="built_in">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、switch"><a href="#2、switch" class="headerlink" title="2、switch"></a>2、switch</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func eval(a <span class="built_in">int</span>, b <span class="built_in">int</span>, op <span class="built_in">string</span>) <span class="built_in">int</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> <span class="built_in">int</span></span><br><span class="line">switch op &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="literal">result</span> = a + b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="literal">result</span> = a - b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line"><span class="literal">result</span> = a * b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line"><span class="literal">result</span> = a / b</span><br><span class="line">default:</span><br><span class="line">panic(<span class="string">"unsupported op"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的这段代码，你发现和别的语言不一样的地方是怎么没有break，是的，Go语言中switch会自动break，除非使用fallthrough</p><p>同时，Go语言的switch还有另外一种写法，结合一个最常见的Switch用法举个例子吧，比如通过考试分数判断是否合格</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Wrong score"</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">80</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">70</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">60</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"D"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的一个写法可以发现switch后面是可以没有表达式的</p><h3 id="1-5、循环"><a href="#1-5、循环" class="headerlink" title="1.5、循环"></a>1.5、循环</h3><h4 id="1、for"><a href="#1、for" class="headerlink" title="1、for"></a>1、for</h4><p>for关键字和其他语言有着共同的功能，同时还充当的Go语言中的 while 功能，Go语言中没有 while 关键字</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> scanner.<span class="title">Scan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的循环代码省略了起始条件，省略了递增条件，就跟while的功能非常的类似</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面其实就是一个死循环，因为Go语言中经常会用到，后面的并发编程 Goroutine 的时候还会给大家继续介绍。</p><h3 id="1-6、函数"><a href="#1-6、函数" class="headerlink" title="1.6、函数"></a>1.6、函数</h3><h4 id="1、普通函数"><a href="#1、普通函数" class="headerlink" title="1、普通函数"></a>1、普通函数</h4><p>普通的函数定义我这边不再过多阐述，跟变量定义类似，函数名在前，函数返回类型在后</p><h4 id="2、多返回值"><a href="#2、多返回值" class="headerlink" title="2、多返回值"></a>2、多返回值</h4><p>这个是Go语言的不一样的地方，函数可以有多个返回值，比如 ioutil.ReadFile 这个函数就是有两个返回值，但是呢多返回值不要滥用，尽量贴合Go语言的风格，常规返回值和一个error，那我门这边可以将上面的加减乘除的例子做一下改造，因为panic之后程序就会终止了，我们可以将错误信息直接返回出来，让程序继续执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line"><span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line"><span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"unsupported op"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、函数可作为参数"><a href="#3、函数可作为参数" class="headerlink" title="3、函数可作为参数"></a>3、函数可作为参数</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">apply</span>(<span class="params">op func(<span class="keyword">int</span>, <span class="keyword">int</span></span>) <span class="keyword">int</span>, a, b <span class="keyword">int</span>) <span class="keyword">int</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言定义这种函数在前，参数在后的复合函数非常的方便，只需要apply一个函数就可以了，当然在现实的过程中有时候也会了偷下懒，相关的op函数就直接写成一个匿名函数了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"sub(3, 4) is:"</span>, apply(</span><br><span class="line">func(<span class="selector-tag">a</span> int, <span class="selector-tag">b</span> int) int &#123;</span><br><span class="line">return <span class="selector-tag">a</span> - b</span><br><span class="line">&#125;, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>这样也是OK的</p><h4 id="4、没有默认参数、没有可选参数"><a href="#4、没有默认参数、没有可选参数" class="headerlink" title="4、没有默认参数、没有可选参数"></a>4、没有默认参数、没有可选参数</h4><p>Go语言中没有其他语言类似Lambda这种很花哨的用法，除了一个可变参数列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">s := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">s += numbers[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个参数求和函数</p><h3 id="1-7、指针"><a href="#1-7、指针" class="headerlink" title="1.7、指针"></a>1.7、指针</h3><h4 id="1、指针不能运算"><a href="#1、指针不能运算" class="headerlink" title="1、指针不能运算"></a>1、指针不能运算</h4><p>比如想对指针做加1运算，Go语言是不支持的；当然要是想在函数内部改变函数外面的变量的值，通过指针是如何实现的呢，如下图所示<br><img src="/media/15231955282344/15235210375685.jpg" alt=""></p><h4 id="2、Go语言只有值传递"><a href="#2、Go语言只有值传递" class="headerlink" title="2、Go语言只有值传递"></a>2、Go语言只有值传递</h4><p>Go语言中想要改变变量的值，只能传一个指针进去，比如常见 a b 两个变量的值交换</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func swap(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> int) &#123;</span><br><span class="line">    *<span class="selector-tag">a</span>, *<span class="selector-tag">b</span> = *<span class="selector-tag">b</span>, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然呢，交换参数值是不建议上面的写法的</p><h2 id="2-内建容器"><a href="#2-内建容器" class="headerlink" title="2. 内建容器"></a>2. 内建容器</h2><h3 id="2-0、数组"><a href="#2-0、数组" class="headerlink" title="2.0、数组"></a>2.0、数组</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 [5]int</span><br><span class="line">arr2 := [3]int&#123;1, 3, 5&#125;</span><br><span class="line">arr3 := [...]int&#123;2, 4, 6, 8, 10&#125;</span><br><span class="line">var grid [<span class="string">4</span>][<span class="symbol">5</span>]int</span><br></pre></td></tr></table></figure><p>数组的定义和变量的定义类似，数组名在前类型在后；<br>常规的遍历操作也是类似</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, v := range arr &#123;</span><br><span class="line">fmt.Println(<span class="selector-tag">i</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 是数组的下标，v是数组的值</p><h4 id="2、数组是值类型"><a href="#2、数组是值类型" class="headerlink" title="2、数组是值类型"></a>2、数组是值类型</h4><p>和上面值传递的概念类似，通过传参在函数内部是改变不了数组的值的;当然要是想改变相关的数组的值，可以通过指针来改变的。接下来的Slice可以直接解决上述的问题。</p><h3 id="2-1、Slice-切片-的概念"><a href="#2-1、Slice-切片-的概念" class="headerlink" title="2.1、Slice(切片)的概念"></a>2.1、Slice(切片)的概念</h3><h4 id="1、Slice定义"><a href="#1、Slice定义" class="headerlink" title="1、Slice定义"></a>1、Slice定义</h4><p>Slice是什么呢？其实呢就是数组的一个View（视图），先来段代码热个身</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="string">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"arr[2:6] ="</span>, arr<span class="string">[2:6]</span>)</span><br><span class="line">fmt.Println(<span class="string">"arr[:6] ="</span>, arr<span class="string">[:6]</span>)</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="string">[2:6]</span> = <span class="string">[2 3 4 5]</span></span><br><span class="line">arr<span class="string">[:6]</span> = <span class="string">[0 1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>从上面的输出结果可以直接的看出，arr加一个下标区间都叫做Slice，Slice的区间是一个左闭右开的区间<br>当然我们还需要知道一个概念，Slice是没有数据的，是对底层Array的一个View，如何理解这个概念呢？简单的用一个例子来理解它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSliceData</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := arr[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"s1 ="</span>, s1)</span><br><span class="line">s2 := arr[:]</span><br><span class="line">fmt.Println(<span class="string">"s2 ="</span>, s2)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"更新Slice数据 s1"</span>)</span><br><span class="line">updateSliceData(s1)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"更新Slice数据 s2"</span>)</span><br><span class="line">updateSliceData(s2)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">s2 = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">更新Slice数据 s1</span><br><span class="line">[<span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">更新Slice数据 s2</span><br><span class="line">[<span class="number">666</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">666</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure><h4 id="2、ReSlice"><a href="#2、ReSlice" class="headerlink" title="2、ReSlice"></a>2、ReSlice</h4><p>就是在一个Slice上进一步slice，比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">ss := arr[:6]</span><br><span class="line">ss = ss[:5]</span><br><span class="line">ss = ss[2:]</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="3、Slice拓展"><a href="#3、Slice拓展" class="headerlink" title="3、Slice拓展"></a>3、Slice拓展</h4><p>首先我们先看一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">s1 := arr[2:6]</span><br><span class="line">s2 := s1[3:5]</span><br></pre></td></tr></table></figure><p>大家或许会有疑问，这个s2不会报错么，要是不报错结果又是多少呢？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>答案是可以，上述就是s1、s2的值，是不是跟你想的有点不一样。那么这又是为什么呢？</p><p><img src="/media/15231955282344/15235352570650.jpg" alt=""></p><p>这就是为什么能把 6 这个值取出来的原因，因为slice是array的底层的一个view，是不是依然还是有点懵，具体又是如何实现的呢？</p><h4 id="4、Slice实现"><a href="#4、Slice实现" class="headerlink" title="4、Slice实现"></a>4、Slice实现</h4><p><img src="/media/15231955282344/15236013496891.jpg" alt=""></p><p>从上图是不是大体明白为什么上面那个例子能把6取出来了；看到这里大家也能大体明白Slice内部的ptr、len、cap是什么意思，ptr指向slice的开头的元素，len是slice的长度，cap代表底层的array从ptr开始到结束的长度，Slice是可以向后扩展的，但是不能向前扩展，所以只要不超过cap的长度slice都是可以扩展的，但是常规的s[i]取值是不可以超过len的。<br>用一个例子来简单的理解一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Printf(<span class="string">"len(s1): %d   ; cap(s1): %d "</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s1): <span class="number">4</span>   ; <span class="built_in">cap</span>(s1): <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="2-2、Slice-切片-的操作"><a href="#2-2、Slice-切片-的操作" class="headerlink" title="2.2、Slice(切片)的操作"></a>2.2、Slice(切片)的操作</h3><h4 id="1、向Slice添加元素"><a href="#1、向Slice添加元素" class="headerlink" title="1、向Slice添加元素"></a>1、向Slice添加元素</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">s3</span> := append(<span class="built_in">s2</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">s4</span> := append(<span class="built_in">s3</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">s5</span> := append(<span class="built_in">s4</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="string">"s3, s4, s5 ="</span>, <span class="built_in">s3</span>, <span class="built_in">s4</span>, <span class="built_in">s5</span>)</span><br><span class="line">fmt.Println(<span class="string">"arr ="</span>, arr)</span><br></pre></td></tr></table></figure><p>上面的这个例子打印出来结果又是多少呢？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3, s4, s5 = [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">arr = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>上面的9 ，10为什么不见了呢？因为Go语言在append数据超过cap长度的时候会分配一个更长的数组，如果arr不再使用的话就会被垃圾回收掉。<br>在append的过程中，由于是值传递的关系，len、cap都有可能会改变，所以呢必须要用一个新的slice来接收这个slice，通常会写成</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = append(s, value1)</span><br></pre></td></tr></table></figure><h4 id="2、创建slice"><a href="#2、创建slice" class="headerlink" title="2、创建slice"></a>2、创建slice</h4><p>当然slice也可以直接通过var关键字创建</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>这样创建的slice的初始值就是nil，别的语言中的null的意思，当然也是可以赋初值的，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure><p>就上面的Zero Value的Slice的情况，要是我这个时候对这个slice进行append操作会怎么样呢？这个slice的内部的len以及cap又是如何变化的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v, len = %d, cap = %d\n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果我就不输出了，因为相对太长，我把相应的结果总结一下，就是len就是一个步长为1由1增至100，cap呢？当系统发现不够存储的时候会分配一个现有长度两倍的空间。</p><p>当然在实际生产过程中，大多是使用的make关键字来创建slice的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">8</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><h4 id="3、Copy-Slice数据"><a href="#3、Copy-Slice数据" class="headerlink" title="3、Copy Slice数据"></a>3、Copy Slice数据</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written int64, err error)</span></span></span><br></pre></td></tr></table></figure><p>文档中可以看的很清晰，直接将第二个参数直接拷贝进第一个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br><span class="line">fmt.Println(s2)</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="4、Slice删除元素"><a href="#4、Slice删除元素" class="headerlink" title="4、Slice删除元素"></a>4、Slice删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br></pre></td></tr></table></figure><p>比如我要删除 s2 中的第 3 个元素该如何操作呢？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">s2</span> = append(<span class="built_in">s2</span>[:<span class="number">2</span>], <span class="built_in">s2</span>[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><p>当然现实的使用中还会从slice中pop一个值出来，下面分别演示一下从s2头部pop和从s2尾部pop数据</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front := s2[0]</span><br><span class="line">s2 = s2[1:]</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail := <span class="built_in">s2</span>[len(<span class="built_in">s2</span>)-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">s2</span> = <span class="built_in">s2</span>[:len(<span class="built_in">s2</span>)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="2-3、Map"><a href="#2-3、Map" class="headerlink" title="2.3、Map"></a>2.3、Map</h3><h4 id="1、创建map"><a href="#1、创建map" class="headerlink" title="1、创建map"></a>1、创建map</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>上述就是常见的创建map的方式，但是m1、m2还是有区别的，m1是nil，m2是一个空map;常规的遍历map也是用 range 的方式就可以，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然细心的会发现，在遍历的过程中是不能保证顺序的，当然要是想顺序遍历，需要自己手动对key进行排序，可以将key存进slice，然后再通过slice遍历相关的key获取map的值。</p><h4 id="2、获取map元素"><a href="#2、获取map元素" class="headerlink" title="2、获取map元素"></a>2、获取map元素</h4><p>m[key] 一般就是这样获取map的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"name"</span> : <span class="string">"shengguocun"</span>,</span><br><span class="line"><span class="string">"gender"</span> : <span class="string">"male"</span>,</span><br><span class="line"><span class="string">"city"</span> : <span class="string">"hangzhou"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value1 := map1[<span class="string">"age"</span>]</span><br><span class="line">fmt.Println(value1)</span><br></pre></td></tr></table></figure><p>先来猜测一下，上述这段代码可以运行么？会不会报错？</p><p>答案是不会，这就是Go语言和别的语言不一样的地方，上述的例子中 value1 的值是一个空字符串，map中当key不存在时，会获取value类型的初始值。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gender, ok := map1[<span class="string">"gender"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Gender 的值为 : "</span>, gender)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Key 不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然Go语言的出现就是为了解决别的语言的痛点，所以在使用过程中不再需要每次获取某个 key 的时候都要去 isset 判断一下，Go的获取map的值的时候第二个返回值就是别的语言 isset 的功能；存在返回 true ，不存在返回 false。</p><h4 id="3、删除元素"><a href="#3、删除元素" class="headerlink" title="3、删除元素"></a>3、删除元素</h4><p>delete函数，就可以直接删除指定的key的值</p><p><img src="/media/15231955282344/15238684220308.jpg" alt=""></p><p>这是Go语言的官方文档，不难理解比如要删除上面的 map1 的 city 的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delete</span><span class="params">(map1, <span class="string">"city"</span>)</span></span></span><br></pre></td></tr></table></figure><p>直接调用就可以</p><h4 id="4、map的key"><a href="#4、map的key" class="headerlink" title="4、map的key"></a>4、map的key</h4><p>为什么要把key单独拿出来说呢？因为map底层使用的是hash表，所以map的key必须可以比较相等；换句话说就是除了 slice、map、function的内建类型都可以作为key。</p><h3 id="2-4、字符和字符串处理"><a href="#2-4、字符和字符串处理" class="headerlink" title="2.4、字符和字符串处理"></a>2.4、字符和字符串处理</h3><h4 id="1、rune介绍"><a href="#1、rune介绍" class="headerlink" title="1、rune介绍"></a>1、rune介绍</h4><p>rune就是Go语言的字符串类型，其实可以理解为是 int32 的一个別名，下面我们通过例子来深入理解一下rune</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"你好,杭州"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">byte</span>(s1) &#123;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%X "</span>, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s1 &#123;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"(%d %X) "</span>, i, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你好,杭州</span><br><span class="line">E4 BD A0 E5 A5 BD <span class="number">2</span>C E6 <span class="number">9</span>D AD E5 B7 <span class="number">9</span>E</span><br><span class="line">(<span class="number">0</span> <span class="number">4</span>F60) (<span class="number">3</span> <span class="number">597</span>D) (<span class="number">6</span> <span class="number">2</span>C) (<span class="number">7</span> <span class="number">676</span>D) (<span class="number">10</span> <span class="number">5</span>DDE)</span><br></pre></td></tr></table></figure><p>从上述的例子我们可以直接的看出来，其实就是将UTF-8编码解码，然后再转成Unicode之后将它存放进一个rune（int32）中</p><h4 id="2、字符串处理"><a href="#2、字符串处理" class="headerlink" title="2、字符串处理"></a>2、字符串处理</h4><p>UTF-8编码的rune长度统计</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">count</span> := utf8.RuneCountInString(s1)</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Rune Count :"</span>, <span class="keyword">count</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rune Count : 5</span><br></pre></td></tr></table></figure><p>字符串的输出操作</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bytes </span>:= []<span class="keyword">byte(s1)</span></span><br><span class="line"><span class="keyword">for </span>len(<span class="keyword">bytes) </span>&gt; <span class="number">0</span> &#123;</span><br><span class="line">ch, size := utf8.DecodeRune(<span class="keyword">bytes)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bytes </span>= <span class="keyword">bytes[size:]</span></span><br><span class="line"><span class="keyword"></span>fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用rune实现上述同样的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s1) &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-面向“对象”"><a href="#3-面向“对象”" class="headerlink" title="3. 面向“对象”"></a>3. 面向“对象”</h2><h3 id="3-0、结构体和方法"><a href="#3-0、结构体和方法" class="headerlink" title="3.0、结构体和方法"></a>3.0、结构体和方法</h3><h4 id="1、结构体的创建"><a href="#1、结构体的创建" class="headerlink" title="1、结构体的创建"></a>1、结构体的创建</h4><p>go语言仅支持封装，不支持继承和多态；这句话怎么理解呢？就是说在Go语言内部没有class，只有struct；也没有复杂的继承和多态，那继承和多态的任务又是通过什么实现的呢？Go是面向接口编程，可以通过接口来实现继承和多态的相关的任务，后面我会再进行介绍。<br>下面先来介绍一下struct的创建：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Node</span> <span class="title">struct</span> &#123;</span><br><span class="line">Value       int</span><br><span class="line">Left, Right *<span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>通过type、struct关键字创建结构体类型，当然在创建了结构体类型之后，就可以创建相关类型的变量</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> root tree.Node</span><br><span class="line">root = tree.Node&#123;Value:<span class="number">1</span>&#125;</span><br><span class="line">root<span class="selector-class">.Value</span> = <span class="number">2</span></span><br><span class="line">root<span class="selector-class">.Left</span> = &amp;tree.Node&#123;Value:<span class="number">3</span>&#125;</span><br><span class="line">root<span class="selector-class">.Right</span> = &amp;tree.Node&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2、方法创建"><a href="#2、方法创建" class="headerlink" title="2、方法创建"></a>2、方法创建</h4><p>结构体的方法的创建和普通的函数创建没有太大的区别，只是在方法名前面添加一个接收者，就相当于其他语言的this</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">Node</span>) Print() &#123;</span><br><span class="line">fmt.Print(<span class="keyword">node</span>.<span class="title">Value</span>, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是一个值接收者打印出Node的Value的值的方法。<br>当然要是需要改变Value的值的时候，就需要一个指针接收者。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">*Node</span>) SetValue(value int) &#123;</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Value</span> = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个疑问，要是对一个值为nil的Node进行 SetValue 操作会发生什么？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> pRoot *tree.Node</span><br><span class="line">pRoot.SetValue(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>虽说nil指针可以调用方法，但是下面的Value是拿不到，自然就会报下面的错了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory<span class="built_in"> address </span><span class="keyword">or</span> <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation <span class="attribute">code</span>=0x1 <span class="attribute">addr</span>=0x0 <span class="attribute">pc</span>=0x20c3]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">panic(0x8f100, 0xc42000a070)</span><br></pre></td></tr></table></figure><p>实际使用过程中可以添加相关的判断在做处理。结合上面的知识我们不难写出一个树的遍历的方法的代码</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">*Node</span>) Traverse()  &#123;</span><br><span class="line"></span><br><span class="line">if <span class="keyword">node</span> <span class="title">== nil</span> &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Print</span>()</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Left</span>.Traverse()</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Right</span>.Traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1、包和封装"><a href="#3-1、包和封装" class="headerlink" title="3.1、包和封装"></a>3.1、包和封装</h3><h4 id="1、命名规范"><a href="#1、命名规范" class="headerlink" title="1、命名规范"></a>1、命名规范</h4><ul><li>名字一般使用 CamelCase（驼峰式）</li><li>首字母大写：Public</li><li>首字母小写：Private</li></ul><h4 id="2、包的概念"><a href="#2、包的概念" class="headerlink" title="2、包的概念"></a>2、包的概念</h4><ul><li>每个目录一个包，但是包名和目录名不一定要一样的，但是每个目录只能包含一个包；</li><li>main包是一个相对特殊的，main包包含一个可执行入口；</li><li>为结构体定义的方法必须放在同一个包内</li></ul><p>当然上面的例子已经在不经意间提前引入了package的概念</p><h3 id="3-2、扩展已有类型"><a href="#3-2、扩展已有类型" class="headerlink" title="3.2、扩展已有类型"></a>3.2、扩展已有类型</h3><p>在面向对象中，我们想要扩展一下别人的类，我们通常继承一下就好了，但是Go语言中没有继承的概念，我们该如何处理呢？</p><h4 id="1、定义别名（1-9新特性）"><a href="#1、定义别名（1-9新特性）" class="headerlink" title="1、定义别名（1.9新特性）"></a>1、定义别名（1.9新特性）</h4><p>在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型</p><p>基本语法就是：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">identifier </span>= <span class="keyword">Type</span></span><br></pre></td></tr></table></figure><p>比如内建的byte类型，其实是uint8的类型别名，而rune其实是int32的类型别名。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// byte <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> uint8 <span class="keyword">and</span> <span class="keyword">is</span> equivalent <span class="keyword">to</span> uint8 <span class="keyword">in</span> <span class="keyword">all</span> ways. It <span class="keyword">is</span></span><br><span class="line">// used, by convention, <span class="keyword">to</span> distinguish byte values from <span class="number">8</span>-<span class="built_in">bit</span> <span class="built_in">unsigned</span></span><br><span class="line">// <span class="built_in">integer</span> values.</span><br><span class="line"><span class="keyword">type</span> byte = uint8</span><br><span class="line"></span><br><span class="line">// rune <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> int32 <span class="keyword">and</span> <span class="keyword">is</span> equivalent <span class="keyword">to</span> int32 <span class="keyword">in</span> <span class="keyword">all</span> ways. It <span class="keyword">is</span></span><br><span class="line">// used, by convention, <span class="keyword">to</span> distinguish <span class="built_in">character</span> values from <span class="built_in">integer</span> values.</span><br><span class="line"><span class="keyword">type</span> rune = int32</span><br></pre></td></tr></table></figure><p>通过别名的方式就可以拓展了，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> T3 = T1</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t1 T1)</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t3 *T3)</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t1 T1</span><br><span class="line"><span class="comment">// var t2 T2</span></span><br><span class="line"><span class="keyword">var</span> t3 T3</span><br><span class="line">t1.say()</span><br><span class="line">t1.greeting()</span><br><span class="line">t3.say()</span><br><span class="line">t3.greeting()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然要是T1也定义了 greeting 的方法，那么编译会报错的，因为有重复的方法定义。</p><h4 id="2、使用组合"><a href="#2、使用组合" class="headerlink" title="2、使用组合"></a>2、使用组合</h4><p>比如我们想扩展上面的树的包，实现一个自己的中序遍历，该如何实现呢？通过代码来理解一下使用组合的概念</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type myNode <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">node *tree.<span class="type">Node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNodeNode *myNode)</span></span> <span class="type">Traverse</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> myNodeNode == <span class="literal">nil</span> || myNodeNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">left</span> := myNode&#123;myNodeNode.node.<span class="type">Left</span>&#125;</span><br><span class="line"><span class="keyword">right</span> := myNode&#123;myNodeNode.node.<span class="type">Right</span>&#125;</span><br><span class="line"><span class="keyword">left</span>.ownFunc()</span><br><span class="line">myNodeNode.node.<span class="type">Print</span>()</span><br><span class="line"><span class="keyword">right</span>.ownFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、GOPATH以及目录结构"><a href="#3-3、GOPATH以及目录结构" class="headerlink" title="3.3、GOPATH以及目录结构"></a>3.3、GOPATH以及目录结构</h3><ul><li>默认在 ～／go 目录下（unix或者Linux环境），%USERPROFILE%\go 目录下（windows环境）</li><li>官方推荐：所有的项目和第三方库都放在同一个GOPATH下</li><li>当然也可以将每个项目放在不同的GOPATH下</li></ul><p>如何查看自己的GOPATH呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ sheng$ <span class="built_in">echo</span> <span class="variable">$GOPATH</span></span><br><span class="line">/Users/verton/GoLangProject</span><br></pre></td></tr></table></figure><h4 id="1、go-get获取第三方库"><a href="#1、go-get获取第三方库" class="headerlink" title="1、go get获取第三方库"></a>1、go get获取第三方库</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> url</span><br></pre></td></tr></table></figure><p>这样是可以获取GitHub上面的三方的库，但是Golang.org上面要是不能翻墙是获取不了的，这里我给大家介绍一个新的工具 <strong>gopm</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheng$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gpmgo/gopm</span><br></pre></td></tr></table></figure><p>一行命令就可以装好了，这个时候再get三方的库就毫无压力了，因为这个国内有相关的镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopm <span class="builtin-name">get</span> -g url</span><br></pre></td></tr></table></figure><p>采用-g 参数，可以把依赖包下载到GOPATH目录中</p><h4 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h4><ul><li>src<ul><li>git repo 1</li><li>git repo 2</li></ul></li><li>pkg<ul><li>git repo 1</li><li>git repo 2</li></ul></li><li>bin<ul><li>执行文件 1 2</li></ul></li></ul><p>从上述的目录结构上我们可以看出来，src pkg 是对应的，src 是我们的代码的位置以及三方库的位置，pkg 是build的中间过程，可以暂时先不用关注，bin下面就是可执行文件。</p><h2 id="4-面向接口"><a href="#4-面向接口" class="headerlink" title="4. 面向接口"></a>4. 面向接口</h2><h3 id="4-0、Duck-Typing的概念"><a href="#4-0、Duck-Typing的概念" class="headerlink" title="4.0、Duck Typing的概念"></a>4.0、Duck Typing的概念</h3><p>很多语言都有duck typing的概念， 用一个简单的例子来描述一下这个概念</p><p><img src="/media/15231955282344/15240576798805.jpg" alt=""></p><p>大黄鸭是鸭子么？这个答案是要看基于什么角度来看，从生物角度来看，那它当然不是鸭子，连基本的生命都没有；但是从duck typing的角度来看它就是一个鸭子，因为它外部长得像鸭子，通俗点概括一下duck typing的概念就是：描述事物的外部行为而非内部结构。</p><p>从严格意义上讲，go语言只能说是类似duck typing，go语言不是动态绑定的，go语言是编译时绑定的。</p><h3 id="4-1、接口的定义和实现"><a href="#4-1、接口的定义和实现" class="headerlink" title="4.1、接口的定义和实现"></a>4.1、接口的定义和实现</h3><p>在Go语言中，接口interface其实和其他语言的接口意思也没什么区别。一个结构体必须实现了一个接口的所有方法，才能被一个接口对象接受，这一点和Java语言中的接口的要求是一样的。interface理解其为一种类型的规范或者约定。</p><h4 id="1、接口的定义"><a href="#1、接口的定义" class="headerlink" title="1、接口的定义"></a>1、接口的定义</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span>&#123;</span><br><span class="line">    Get(url <span class="built_in">string</span>) <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就定义了一个接口，它包含一个Get函数。</p><h4 id="2、接口的实现"><a href="#2、接口的实现" class="headerlink" title="2、接口的实现"></a>2、接口的实现</h4><p>现在我们就来实现一下这个接口。比如我们做一个拉取某个页面的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rick</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"shengguocun.com/retriever/rick"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span>&#123;</span><br><span class="line">Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Get(<span class="string">"http://www.shengguocun.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r Retriever</span><br><span class="line">r = rick.Retriever&#123;&#125;</span><br><span class="line">fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述rick.Retriever就实现了Retriever接口。</p><h3 id="4-2、接口值的类型"><a href="#4-2、接口值的类型" class="headerlink" title="4.2、接口值的类型"></a>4.2、接口值的类型</h3><h4 id="1、接口变量里面有什么"><a href="#1、接口变量里面有什么" class="headerlink" title="1、接口变量里面有什么"></a>1、接口变量里面有什么</h4><p>继续使用上面的例子</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r Retriever</span><br><span class="line">r = rick.Retriever&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"<span class="subst">\n</span> %T %v <span class="subst">\n</span>"</span>, r, r)</span><br></pre></td></tr></table></figure><p>会输出什么呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rick</span><span class="selector-class">.Retriever</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这就是常规的值传递，没有什么特别的地方。要是 Retriever 这个struct很大，我们不希望通过传值的方法去拷贝，而是通过指针访问Get方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r Retriever</span><br><span class="line">r = &amp;rick.Retriever&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"<span class="subst">\n</span> %T %v <span class="subst">\n</span>"</span>, r, r)</span><br></pre></td></tr></table></figure><p>这时候的Type、Value又是什么？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-tag">rick</span><span class="selector-class">.Retriever</span> &amp;&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到是一个指针，所以我们一般用到接口的指针，因为它的肚子里含有一个指针，通常我们会说“<strong>接口变量自带指针</strong>”，那我们现在用两个图来总结一下上面的概念</p><p><img src="/media/15231955282344/15244909642810.jpg" alt=""></p><p><img src="/media/15231955282344/15244910308713.jpg" alt=""></p><p>概括为：接口变量里面可以是实现者的类型和实现者的值，或者是接口类型里面可以是实现者的类型和实现者的指针，同时指向实现者。</p><h4 id="2、查看接口变量"><a href="#2、查看接口变量" class="headerlink" title="2、查看接口变量"></a>2、查看接口变量</h4><p>说到这里要提到一个特殊的接口，空接口 interface{} ，对于空接口 interface{} 其实和泛型的概念很像，任何类型都实现了空接口。在方法需要返回多个类型的时候，返回值的类型我们一般定义为 interface{} 。</p><p>这时我们现在引入获取接口变量肚子里的类型的另外一种写法，叫 Type Assertion（断言）。比如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> interface&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"Are you ok?"</span>, <span class="selector-tag">a</span>.(string))</span><br></pre></td></tr></table></figure><p>然而上述的写法一旦断言失败，会报出panic错误，当然这样的程序就显得十分的不友好。我们需要在断言前进行一个判断。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">value</span>, ok := a.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"断言失败，这不是一个string类型"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"值为："</span>, <span class="keyword">value</span>)</span><br></pre></td></tr></table></figure><p>另外我们可以结合switch进行类型判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r = balabalaFunction()</span><br><span class="line"><span class="keyword">switch</span> v := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Println(<span class="string">"type bool..."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">"type int..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:转换类型的时候如果是string可以不用断言，使用fmt.Sprint()函数可以达到想要的效果。</p><h3 id="4-3、接口的组合"><a href="#4-3、接口的组合" class="headerlink" title="4.3、接口的组合"></a>4.3、接口的组合</h3><h4 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h4><p>什么叫接口的组合？当然这就是它的字面上的意思，接口可以组合其他的接口。这种方式等效于在接口中添加其他的接口的方法。在系统函数中就有很多这样的组合，比如：ReadWriter</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ReadWriter <span class="keyword">is</span> the <span class="keyword">interface</span> that groups the basic Read <span class="keyword">and</span> Write methods.</span><br><span class="line"><span class="keyword">type</span> <span class="type">ReadWriter </span><span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在常见的读写文件的时候，网络相关以及一些底层的东西经常会遇到 Reader 、Writer</p><h4 id="2、实例演示"><a href="#2、实例演示" class="headerlink" title="2、实例演示"></a>2、实例演示</h4><p>为了更好的理解接口的组合的概念，下面用一个简单的例子来进一步了解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Reader接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">read()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Writer接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">write()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现上述两个接口</span></span><br><span class="line"><span class="keyword">type</span> myReaderWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw *myReaderWriter)</span> <span class="title">read</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"myReaderWriter read func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw *myReaderWriter)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"myReadWriter writer func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个接口，组合上述两个接口</span></span><br><span class="line"><span class="keyword">type</span> ReaderWriterV1 <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> ReaderWriterV2 <span class="keyword">interface</span> &#123;</span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mrw := &amp;myReaderWriter&#123;&#125;</span><br><span class="line"><span class="comment">//mrw对象实现了read()方法和write()方法，因此可以赋值给ReaderWriterV1和ReaderWriterV2</span></span><br><span class="line"><span class="keyword">var</span> rwv1 ReaderWriterV1 = mrw</span><br><span class="line">rwv1.read()</span><br><span class="line">rwv1.write()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwv2 ReaderWriterV2 = mrw</span><br><span class="line">rwv2.write()</span><br><span class="line">rwv2.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时，ReaderWriterV1和ReaderWriterV2两个接口对象可以相互赋值</span></span><br><span class="line">rwv1 = rwv2</span><br><span class="line">rwv2 = rwv1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、常用的系统接口"><a href="#4-4、常用的系统接口" class="headerlink" title="4.4、常用的系统接口"></a>4.4、常用的系统接口</h3><h4 id="1、Stringer"><a href="#1、Stringer" class="headerlink" title="1、Stringer"></a>1、Stringer</h4><p>这个就是常见的 toString 的功能，</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Stringer <span class="keyword">is</span> implemented by any value that <span class="built_in">has</span> <span class="keyword">a</span> String method,</span><br><span class="line">// which defines the ``native<span class="string">''</span> format <span class="keyword">for</span> that value.</span><br><span class="line">// The String method <span class="keyword">is</span> used <span class="keyword">to</span> <span class="keyword">print</span> <span class="built_in">values</span> passed <span class="keyword">as</span> <span class="keyword">an</span> operand</span><br><span class="line">// <span class="keyword">to</span> any format that accepts <span class="keyword">a</span> <span class="built_in">string</span> <span class="built_in">or</span> <span class="keyword">to</span> <span class="keyword">an</span> unformatted printer</span><br><span class="line">// such <span class="keyword">as</span> <span class="keyword">Print</span>.</span><br><span class="line"><span class="built_in">type</span> Stringer interface &#123;</span><br><span class="line">String() <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stringer接口定义在fmt包中，该接口包含String()函数。任何类型只要定义了String()函数，进行Print输出时，就可以得到定制输出。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"age:%d, gender:%s, name:%s"</span>, p.age, p.gender, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i Person = Person&#123;</span><br><span class="line">age: <span class="number">25</span>,</span><br><span class="line">gender: <span class="string">"male"</span>,</span><br><span class="line">name: <span class="string">"sheng.guocun"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br></pre></td></tr></table></figure><h4 id="2、Reader、Writer"><a href="#2、Reader、Writer" class="headerlink" title="2、Reader、Writer"></a>2、Reader、Writer</h4><p>Reader Writer 上面有提到过，就是常见的读写文件的时候经常会用到，就是对文件的一个抽象，但是不仅这些，比如常见的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewScanner returns a new Scanner to read from r.</span></span><br><span class="line"><span class="comment">// The split function defaults to ScanLines.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span></span> *<span class="type">Scanner</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;<span class="type">Scanner</span>&#123;</span><br><span class="line">r:            r,</span><br><span class="line"><span class="built_in">split</span>:        <span class="type">ScanLines</span>,</span><br><span class="line">maxTokenSize: <span class="type">MaxScanTokenSize</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的参数也是一个Reader，还有很多的底层的代码都是基于 Reader Writer 的，这里就不一一举例了。</p><h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><h3 id="5-0、函数式编程"><a href="#5-0、函数式编程" class="headerlink" title="5.0、函数式编程"></a>5.0、函数式编程</h3><p>Go语言作为一个通用型语言，它对函数式编程主要体现在闭包上面。</p><h4 id="1、函数式编程-VS-函数指针"><a href="#1、函数式编程-VS-函数指针" class="headerlink" title="1、函数式编程 VS 函数指针"></a>1、函数式编程 VS 函数指针</h4><ul><li><p>函数是一等公民：参数、变量、返回值都可以是函数，在别的语言中大多不是这样的，比如在C++里面只有函数指针，在Java里面我们只能调用，不能把函数传给别人。</p></li><li><p>高阶函数：参数可以是函数，1.6.3里面的apply函数就是一个高阶函数。</p></li><li><p>函数 –&gt; 闭包：首先用个例子来了解一下闭包的用法</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum += v</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"0 + 1 + 2 + ... + %d = %d\n"</span>, i, a(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">6</span> = <span class="number">21</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">8</span> = <span class="number">36</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">9</span> = <span class="number">45</span></span><br></pre></td></tr></table></figure><p>上述的 v 就称为局部变量， sum 称为自由变量，<code>func(v int) int {        sum += v        return sum    }</code> 称为函数体，整个就叫做一个闭包。用一张图来概括就是：</p><p><img src="/media/15231955282344/15245726261451.jpg" alt=""></p><h4 id="2、“正统”函数式编程"><a href="#2、“正统”函数式编程" class="headerlink" title="2、“正统”函数式编程"></a>2、“正统”函数式编程</h4><ul><li><p>不可变性：不能有状态，只有常量和函数；当然这和平常的函数不一样，连变量都没有，甚至连选择语句、循环语句都没有。</p></li><li><p>函数只能有一个参数</p></li></ul><p>要是上面的累加想做一个稍微正统函数怎么做呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iAdder <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">adderV2</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">iAdder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> base + v, adderV2(base + v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := adderV2(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">int</span></span><br><span class="line">s, a = a(i)</span><br><span class="line">fmt.Printf(<span class="string">"0 + 1 + 2 + ... + %d = %d\n"</span>, i, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然正统的不一定是最好的，正统式的写法经常导致代码的可读性变得不是很好。</p><h3 id="5-1、函数式编程实例演示"><a href="#5-1、函数式编程实例演示" class="headerlink" title="5.1、函数式编程实例演示"></a>5.1、函数式编程实例演示</h3><h4 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h4><p>Go语言的官方案列中，对闭包的讲解通过一个常见的例子：斐波那契数列，为了更好的理解闭包的感念，那这里我们就将这个例子再来演示一遍</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Fibonacci() func() int &#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">return func() int &#123;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = <span class="selector-tag">b</span>, a+b</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们要打印这一串斐波那契数列，我们就需要不停的调用上面的斐波那契数列的生成器。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f := Fibonacci()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 5</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="2、为函数实现接口"><a href="#2、为函数实现接口" class="headerlink" title="2、为函数实现接口"></a>2、为函数实现接口</h4><p>这个斐波那契数列的调用的生成器跟文件有点像，我们可以把它包装成一个 <code>io.Reader</code> 这样就跟打印一个文件一样生成这个斐波那契数列。</p><p>首先我们先定义我们的类型 <code>func() int</code> ，就取名Generate好了</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Generate <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>同时需要将 <code>Fibonacci()</code> 函数的类型改掉</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Fibonacci() Generate &#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">return func() int &#123;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = <span class="selector-tag">b</span>, a+b</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个类型就可以实现接口，这就是Go语言灵活的地方，下一步我们实现这个Reader接口</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> (<span class="selector-tag">gen</span> <span class="selector-tag">Generate</span>) <span class="selector-tag">Read</span>(<span class="selector-tag">p</span> <span class="selector-attr">[]</span><span class="selector-tag">byte</span>) (<span class="selector-tag">n</span> <span class="selector-tag">int</span>, <span class="selector-tag">err</span> <span class="selector-tag">error</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">nextNum </span>:= <span class="built_in">gen</span>()</span><br><span class="line">numString := fmt.<span class="built_in">Sprintf</span>(<span class="string">"%d \n"</span>, nextNum)</span><br><span class="line"></span><br><span class="line">return strings.<span class="built_in">NewReader</span>(numString).<span class="built_in">Read</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们会发现函数也可以实现接口，这就是Go语言的不一样的地方，因为函数是一等公民，它既可以作为参数，也可以作为接收者。首先我们要先取到下一个元素 <code>nextNum</code> ,然后将下一个元素写进 <em>p</em> 。然后我们直接用一个写好的文件打印的函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">printFileContents</span>(<span class="selector-tag">reader</span> <span class="selector-tag">io</span><span class="selector-class">.Reader</span>) &#123;</span><br><span class="line"><span class="attribute">scanner </span>:= bufio.<span class="built_in">NewScanner</span>(reader)</span><br><span class="line"></span><br><span class="line">for scanner.<span class="built_in">Scan</span>() &#123;</span><br><span class="line">fmt.<span class="built_in">Println</span>(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们就可以直接调用了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">f </span>:= <span class="built_in">Fibonacci</span>()</span><br><span class="line"><span class="built_in">printFileContents</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上述的代码是存在瑕疵的，比如这个 <code>printFileContents</code> 函数会一直读下去，就变成一个死循环了，我们需要设置其终止条件。比如上面的 <em>p</em> 太小的话，只读了一半，当然这边就留给读者后期拓展了。</p><h2 id="6-错误处理和资源管理"><a href="#6-错误处理和资源管理" class="headerlink" title="6. 错误处理和资源管理"></a>6. 错误处理和资源管理</h2><p>我们实际的代码不止 <code>Hello World</code> ,我们的代码是要运行在服务器上的，要和各种各样的用户进行交互，所以我们这里就要了解一下Go语言的资源管理和出错处理。</p><h3 id="6-0、defer调用"><a href="#6-0、defer调用" class="headerlink" title="6.0、defer调用"></a>6.0、defer调用</h3><h4 id="1、确保在函数结束时调用"><a href="#1、确保在函数结束时调用" class="headerlink" title="1、确保在函数结束时调用"></a>1、确保在函数结束时调用</h4><p>比如一个常见的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我要是想要让1在2后面输出该如何做呢？你说调换一下顺序呗，道理我都懂，但是我们今天要介绍的不是这个，我们只需要在打印1之前加一个 <em>defer</em> 就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是有多个defer呢？它的输出顺序又是什么样的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，输出的结果又是什么？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里我们可以发现 <em>defer</em> 的调用实际是一个栈，先进后出。当然 <em>defer</em> 的最大的好处是什么呢？就是当程序中间有return返回甚至panic的时候，依然不影响 defer 后面的代码的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"whoops, something went wrong...."</span>)</span><br><span class="line">fmt.Println(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码在panic之后，1 2 依然能够正常输出。</p><h4 id="2、场景演示"><a href="#2、场景演示" class="headerlink" title="2、场景演示"></a>2、场景演示</h4><p>当然说了这么多，我们在代码中常见的使用defer的场景有哪些呢？比如我们创建文件，写文件这些，过去我们用别的语言经常会在处理文件的最后释放句柄，因为中间隔了很多的文件操作，经常可能会忘记释放句柄。那Go语言就针对这样的场景做了非常好的优化，通过defer关键字实现，下面我们就通过一个简单的写文件事例来演示一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">filename := <span class="string">"demo.txt"</span></span><br><span class="line">file, err := os.Create(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">defer</span> writer.Flush()</span><br><span class="line"></span><br><span class="line">fmt.Fprintln(writer, <span class="string">"你好，杭州"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/media/15231955282344/15248139076584.jpg" alt=""></p><p>一个完整的事例就演示到这边，比如常见的 Open／Close、Lock／Unlock这些成对出现的都可以使用 <em>defer</em></p><h3 id="6-1、错误处理概念"><a href="#6-1、错误处理概念" class="headerlink" title="6.1、错误处理概念"></a>6.1、错误处理概念</h3><p>因为在我们实际的程序中，有错直接panic中断程序执行，这时非常不友好的，通常我们会对其出错处理。比如上面的事例中 <code>os.Create</code> 函数返回的 <code>err</code> 不为 <code>nil</code> 的时候，我们需要做一个出错处理，</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename := <span class="string">"demo.txt"</span></span><br><span class="line"><span class="keyword">file</span>, <span class="keyword">err</span> := os.Create(filename)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="keyword">err</span>.<span class="keyword">Error</span>())</span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接打印出相关的错误信息，然后直接返回。这就是常见的错误处理方式之一，当然在函数内部也可以将错误信息直接作为结果返回。</p><h3 id="6-2、panic和recover"><a href="#6-2、panic和recover" class="headerlink" title="6.2、panic和recover"></a>6.2、panic和recover</h3><h4 id="1、panic"><a href="#1、panic" class="headerlink" title="1、panic"></a>1、panic</h4><ul><li>停止当前函数执行</li></ul><p>panic和我们其他语言的throw exception很像</p><ul><li>一直向上返回，执行每一层的defer</li></ul><p>当然相对还是友好的，每层的defer还是会用到，一层一层的返回，返回到最后程序就会自动退出了</p><ul><li>如果没有遇见recover，程序退出</li></ul><h4 id="2、recover"><a href="#2、recover" class="headerlink" title="2、recover"></a>2、recover</h4><ul><li><p>仅在defer调用中使用</p></li><li><p>获取panic的值</p></li><li><p>如果无法处理，可充新panic</p></li></ul><p>主要的特性就可以用上述几句话概括，为了更好的理解上述的概念，下面用一个简短的代码来学以致用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryDefer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"就打印到这吧"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个 panic 和 defer 的结合使用，他的输出结果会是什么样的呢？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">panic:</span> 就打印到这吧</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.tryDefer()</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>web/web.<span class="string">go:</span><span class="number">11</span> +<span class="number">0x11d</span></span><br><span class="line">main.main()</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>web/web.<span class="string">go:</span><span class="number">18</span> +<span class="number">0x20</span></span><br></pre></td></tr></table></figure><p>从上述输出结果我们可以看到panic的前两个特性，那结合recover又会是什么样的呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// The recover built-in function allows a program to manage behavior of a</span><br><span class="line">// panicking goroutine. Executing a <span class="keyword">call</span> <span class="keyword">to</span> <span class="keyword">recover</span> inside a <span class="keyword">deferred</span></span><br><span class="line">// <span class="keyword">function</span> (but <span class="keyword">not</span> <span class="keyword">any</span> <span class="keyword">function</span> called <span class="keyword">by</span> it) stops the panicking <span class="keyword">sequence</span></span><br><span class="line">// <span class="keyword">by</span> restoring <span class="keyword">normal</span> execution <span class="keyword">and</span> retrieves the <span class="keyword">error</span> <span class="keyword">value</span> passed <span class="keyword">to</span> the</span><br><span class="line">// <span class="keyword">call</span> <span class="keyword">of</span> panic. <span class="keyword">If</span> <span class="keyword">recover</span> <span class="keyword">is</span> called outside the <span class="keyword">deferred</span> <span class="keyword">function</span> it will</span><br><span class="line">// <span class="keyword">not</span> <span class="keyword">stop</span> a panicking sequence. <span class="keyword">In</span> this <span class="keyword">case</span>, <span class="keyword">or</span> <span class="keyword">when</span> the goroutine <span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line">// panicking, <span class="keyword">or</span> <span class="keyword">if</span> the argument supplied <span class="keyword">to</span> panic was nil, <span class="keyword">recover</span> <span class="keyword">returns</span></span><br><span class="line">// nil. Thus the <span class="keyword">return</span> <span class="keyword">value</span> <span class="keyword">from</span> <span class="keyword">recover</span> reports whether the goroutine <span class="keyword">is</span></span><br><span class="line">// panicking.</span><br><span class="line">func <span class="keyword">recover</span>() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"错误信息: "</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(errors.New(<span class="string">"这是一个 error"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以看到 recover 是一个interface， 所以在判断的时候需要判断 r 是否是一个 error，结果自然会是输出</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息:  这是一个 <span class="keyword">error</span></span><br></pre></td></tr></table></figure><p>那我们再用一个实际一点的例子来测试一下，比如除数为0的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"错误信息: "</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">b := <span class="number">0</span></span><br><span class="line">a := <span class="number">5</span> / b</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息:  runtime error: <span class="keyword">integer</span> <span class="built_in">divide</span> <span class="keyword">by</span> <span class="literal">zero</span></span><br></pre></td></tr></table></figure><p>上面的两个例子简单介绍了panic、recover的基本使用，下面通过一个稍微实际一点的例子来综合讲述一下一般的项目中是如何统一处理错误的。</p><h3 id="6-3、服务器统一出错处理"><a href="#6-3、服务器统一出错处理" class="headerlink" title="6.3、服务器统一出错处理"></a>6.3、服务器统一出错处理</h3><p>现在呢我们就通过一个Http服务来展开如何统一处理服务器出错这件事，结合一个实际读取目录内文件的例子来简单介绍一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/list/"</span>,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">path := request.URL.Path[<span class="built_in">len</span>(<span class="string">"/list/"</span>):]</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line">all, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer.Write(all)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServe(<span class="string">":2872"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在GOPATH下有一个 <code>demo.txt</code> 文件，浏览器输入一下地址 <code>http://localhost:2872/list/demo.txt</code> ,浏览器正确输出结果</p><p><img src="/media/15231955282344/15254248021435.jpg" alt=""></p><p>万一我访问一个不存在的文件呢？会得到什么样的结果，比如我现在访问 <code>http://localhost:2872/list/demo.txts</code> GOPATH目录下没有demo.txts文件，自然你会想到会panic一个错误</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="regexp">/05/</span><span class="number">04</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">54</span> <span class="string">http:</span> panic serving [::<span class="number">1</span>]:<span class="number">51946</span>: open demo.<span class="string">txts:</span> no such file or directory</span><br><span class="line">goroutine <span class="number">5</span> [running]:</span><br><span class="line">net/http.(*conn).serve.func1(<span class="number">0xc4200968c0</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>net<span class="regexp">/http/</span>server.<span class="string">go:</span><span class="number">1726</span> +<span class="number">0xd0</span></span><br><span class="line">panic(<span class="number">0x124fde0</span>, <span class="number">0xc420086fc0</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>runtime/panic.<span class="string">go:</span><span class="number">502</span> +<span class="number">0x229</span></span><br><span class="line">main.main.func1(<span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>web/web.<span class="string">go:</span><span class="number">52</span> +<span class="number">0x144</span></span><br><span class="line">net/http.HandlerFunc.ServeHTTP(<span class="number">0x12aff28</span>, <span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>net<span class="regexp">/http/</span>server.<span class="string">go:</span><span class="number">1947</span> +<span class="number">0x44</span></span><br><span class="line">net/http.(*ServeMux).ServeHTTP(<span class="number">0x140b3e0</span>, <span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>net<span class="regexp">/http/</span>server.<span class="string">go:</span><span class="number">2337</span> +<span class="number">0x130</span></span><br><span class="line">net/http.serverHandler.ServeHTTP(<span class="number">0xc420089110</span>, <span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br></pre></td></tr></table></figure><p>从上面的部分的报错信息来看，</p><p><img src="/media/15231955282344/15254260616558.jpg" alt=""></p><p>相关的错误信息都是 <code>/usr/local/Cellar/go/1.10.2/libexec/src/net/http/server.go</code> 的 <code>serve</code> 函数报出的，具体是哪一步报出的我就不细说了，有兴趣的可以自己按照例子自己查阅相关的源码，说到这那错误统一处理又是如何处理呢？<br>我们先把第一个panic替换成</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path := request.URL.Path[len(<span class="string">"/list/"</span>):]</span><br><span class="line"><span class="keyword">file</span>, <span class="keyword">err</span> := os.<span class="keyword">Open</span>(path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line"></span><br><span class="line">http.<span class="keyword">Error</span>(writer, <span class="keyword">err</span>.<span class="keyword">Error</span>(), http.StatusInternalServerError)</span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来访问上述地址</p><p><img src="/media/15231955282344/15254277514513.jpg" alt=""></p><p>相比之前，提示稍微友好一点了，但是这对用户来讲还是不合适的，直接将程序内部错误信息输出给用户有些欠妥。我们可以包装成一个外部的Error，首先我们先定义一个函数appHandler, 返回一个error</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler func(writer http.<span class="type">ResponseWriter</span>, request *http.<span class="type">Request</span>) error</span><br></pre></td></tr></table></figure><p>然后定义一个 errWrapper 函数, 返回一个handler 里面需要的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type appHandler <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errWrapper</span><span class="params">(handler appHandler)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">err := handler(writer, request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> os.<span class="type">IsNotExist</span>(err):</span><br><span class="line">    http.<span class="type">Error</span>(writer, http.<span class="type">StatusText</span>(http.<span class="type">StatusNotFound</span>), http.<span class="type">StatusNotFound</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将writer和request传进handler，通过switch判断err的类型，做一个统一的返回处理；这时我们需要将原来的业务逻辑的代码稍微做一下调整，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/list/"</span>,</span><br><span class="line">errWrapper(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">path := request.URL.Path[<span class="built_in">len</span>(<span class="string">"/list/"</span>):]</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line">all, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer.Write(all)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServe(<span class="string">":2872"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>http.HandleFunc</code> 的第二个参数我们需要改为 <code>errWrapper</code> 同时将原来的函数作为参数传进去，当然这个函数为了代码的可读性应该单独抽离出来，相应的返回直接返回error就可以了，这时候我们再去访问之前的一个不存在的URL</p><p><img src="/media/15231955282344/15256970597886.jpg" alt=""></p><p>这时候的错误就明显友好了很多，讲到这就是一个简单的统一错误处理的思路。</p><h2 id="7-测试和性能调优"><a href="#7-测试和性能调优" class="headerlink" title="7. 测试和性能调优"></a>7. 测试和性能调优</h2><h3 id="7-0、测试"><a href="#7-0、测试" class="headerlink" title="7.0、测试"></a>7.0、测试</h3><h4 id="1、传统测试-VS-表格驱动测试"><a href="#1、传统测试-VS-表格驱动测试" class="headerlink" title="1、传统测试 VS 表格驱动测试"></a>1、传统测试 VS 表格驱动测试</h4><p>测试的作用对于一个软件行业从业者而言都是毋庸置疑的，Go语言在测试这块它有自己独特的见解，下面我们先介绍一下这两种模式下的测试</p><h5 id="传统测试"><a href="#传统测试" class="headerlink" title="传统测试"></a>传统测试</h5><ul><li><p>测试数据和测试逻辑混在一起</p></li><li><p>出错信息不明确</p></li><li><p>一旦一个数据出错测试全部结束</p></li></ul><p>下面我们简单的举个例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public function testCase()&#123;</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">2</span>, <span class="keyword">add</span><span class="bash">(1, 1));</span></span><br><span class="line"><span class="bash">    assertEquals(1, add(1, 3));</span></span><br><span class="line"><span class="bash">    assertEquals(0, add(1, -1));</span></span><br><span class="line"><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure><p>很明显上面的几个特征它都占了，那下面我们来看一段Go语言的测试case</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">    a, b, c <span class="keyword">int32</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line">    <span class="keyword">if</span> act := add(test.a, test.b); act != test.c &#123;</span><br><span class="line">        <span class="comment">// 相应的错误处理...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是一个典型的表格驱动测试</p><h5 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h5><ul><li><p>分离测试数据和测试逻辑</p></li><li><p>明确的出错信息</p></li><li><p>可以部分失败</p></li></ul><p>Go语言的语法使得我们更容易使用表格驱动测试的测试模式</p><h4 id="2、实例演示-1"><a href="#2、实例演示-1" class="headerlink" title="2、实例演示"></a>2、实例演示</h4><p>说了这么多，我们通常又是如何写测试用例呢？首先下面是一段加法的代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package calculator</span><br><span class="line"></span><br><span class="line">func Add(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> int32) int32 &#123;</span><br><span class="line"></span><br><span class="line">return <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在就写上面的函数的测试用例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calculator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">a, b, c <span class="keyword">int32</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line"><span class="keyword">if</span> act := Add(test.a, test.b); act != test.c &#123;</span><br><span class="line"></span><br><span class="line">t.Errorf(<span class="string">"%d + %d != %d 实际为 %d"</span>, test.a, test.b, test.c, act)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用IDE的同学直接点击 <code>Run Test</code> 就可以了，当然也同样支持命令行运行,进入到指定的文件目录下面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">sheng$</span><span class="bash"> go <span class="built_in">test</span> ./</span></span><br><span class="line">ok  shengguocun.com/functional/calculator0.006s</span><br></pre></td></tr></table></figure><p>运行相关的执行命令就可以了，要是有错误的case依然不影响相关的测试的执行，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> calculator</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">tests := []<span class="keyword">struct</span>&#123;</span><br><span class="line">a, b, c <span class="keyword">int32</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#123;math.MaxInt32, <span class="number">1</span>, math.MaxInt32&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, test := <span class="keyword">range</span> tests &#123;</span><br><span class="line"><span class="keyword">if</span> act := Add(test.a, test.b); act != test.c &#123;</span><br><span class="line"></span><br><span class="line">t.Errorf(<span class="string">"%d + %d != %d 实际为 %d"</span>, test.a, test.b, test.c, act)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例的执行结果为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sheng$ <span class="keyword">go</span> test ./</span><br><span class="line">--- FAIL: TestAdd (<span class="number">0.00s</span>)</span><br><span class="line">add_test.<span class="keyword">go</span>:<span class="number">21</span>: <span class="number">2147483647</span> + <span class="number">1</span> != <span class="number">2147483647</span> 实际为 <span class="number">-2147483648</span></span><br><span class="line">FAIL</span><br><span class="line">FAILshengguocun.com/functional/calculator<span class="number">0.006s</span></span><br></pre></td></tr></table></figure><p>我们需要将不符合预期的case做出检查，看是否是代码逻辑有问题，还是case的问题，这就是一个完整的测试用例的编写的过程。</p><h3 id="7-1、代码覆盖率和性能测试"><a href="#7-1、代码覆盖率和性能测试" class="headerlink" title="7.1、代码覆盖率和性能测试"></a>7.1、代码覆盖率和性能测试</h3><h4 id="1、代码覆盖率"><a href="#1、代码覆盖率" class="headerlink" title="1、代码覆盖率"></a>1、代码覆盖率</h4><p>用IDE的同学我们会发现点击 <code>Run Test</code> 按钮的时候还有一个 with coverage 的选项</p><p><img src="/media/15231955282344/15257609082735.jpg" alt=""></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== RUN   TestAdd</span></span><br><span class="line"><span class="bullet">--- </span>PASS: TestAdd (0.00s)</span><br><span class="line">PASS</span><br><span class="line">coverage: 100.0% of statements</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这就是一个测试用例的代码覆盖率的结果。</p><p><img src="/media/15231955282344/15257788675876.jpg" alt=""></p><p>IDE这块有详细的覆盖率报告，可以看到左侧的绿色就是代码的覆盖的范围，右侧有详细的每个文件的覆盖率。当然除了IDE之外命令行也是同样支持的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go test -coverprofile=<span class="selector-tag">a</span>.out</span><br><span class="line">PASS</span><br><span class="line">coverage: <span class="number">100.0%</span> of statements</span><br><span class="line">ok  shengguocun.com/functional/calculator<span class="number">0.006s</span></span><br></pre></td></tr></table></figure><p>直接查看这个 a.out 文件，似乎看得不是很明白，当然我们有一个工具叫 <code>go tool cover</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go<span class="built_in"> tool </span>cover <span class="attribute">-html</span>=a.out</span><br></pre></td></tr></table></figure><p>运行上面的命令，就会展现一个下面的静态页面</p><p><img src="/media/15231955282344/15257797357515.jpg" alt=""></p><p>这就是一个详细的覆盖率报告</p><h4 id="2、性能测试"><a href="#2、性能测试" class="headerlink" title="2、性能测试"></a>2、性能测试</h4><p>对于程序员而言，代码的性能是每个人都会去关注的，Go语言在性能测试这块依然有它的独特见解 <code>Benchmark</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">aa := <span class="keyword">int32</span>(math.MaxInt32 / <span class="number">16</span>)</span><br><span class="line">bb := <span class="keyword">int32</span>(math.MaxInt32 / <span class="number">16</span>)</span><br><span class="line">cc := <span class="keyword">int32</span>(math.MaxInt32 / <span class="number">8</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i ++ &#123;</span><br><span class="line"></span><br><span class="line">act := Add(aa, bb)</span><br><span class="line"><span class="keyword">if</span> act != cc &#123;</span><br><span class="line"></span><br><span class="line">b.Errorf(<span class="string">"%d + %d != %d 实际为 %d"</span>,</span><br><span class="line">aa, bb, cc, act)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一段性能测试代码，我们不需要关注这段代码具体要跑多少次，Go语言自身会帮你决定，IDE点击 <code>Run Test</code> 完，输出相关的结果</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">goos:</span> darwin</span><br><span class="line"><span class="symbol">goarch:</span> amd64</span><br><span class="line"><span class="symbol">pkg:</span> shengguocun.com<span class="meta-keyword">/functional/</span>calculator</span><br><span class="line"><span class="number">2000000000</span>         <span class="number">0.35</span> ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>总共跑了多少次以及每次的平均耗时，都会给出结果。当然同样支持命令行的交互方式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go test -bench .</span><br><span class="line"><span class="symbol">goos:</span> darwin</span><br><span class="line"><span class="symbol">goarch:</span> amd64</span><br><span class="line"><span class="symbol">pkg:</span> shengguocun.com<span class="meta-keyword">/functional/</span>calculator</span><br><span class="line">BenchmarkAdd<span class="number">-4</span>   <span class="number">2000000000</span>         <span class="number">0.34</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  shengguocun.com<span class="meta-keyword">/functional/</span>calculator<span class="number">0.721</span>s</span><br></pre></td></tr></table></figure><h3 id="7-2、使用pprof进行性能调优"><a href="#7-2、使用pprof进行性能调优" class="headerlink" title="7.2、使用pprof进行性能调优"></a>7.2、使用pprof进行性能调优</h3><p>上面我们刚提到了性能测试，下一步自然就是我们该如何优化代码的性能，这里我们需要介绍一下Go语言的性能分析工具 <code>pprof</code> ，就依然用上面的这个例子进行阐述它的基本用法，我们要是想了解一段代码具体它慢在哪里，首先呢我们先让它生成一个cpuprofile</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go test -bench . -cpuprofile=cpu.out</span><br><span class="line"><span class="symbol">goos:</span> darwin</span><br><span class="line"><span class="symbol">goarch:</span> amd64</span><br><span class="line"><span class="symbol">pkg:</span> shengguocun.com<span class="meta-keyword">/functional/</span>calculator</span><br><span class="line">BenchmarkAdd<span class="number">-4</span>   <span class="number">2000000000</span>         <span class="number">0.34</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok  shengguocun.com<span class="meta-keyword">/functional/</span>calculator<span class="number">0.916</span>s</span><br></pre></td></tr></table></figure><p>这时候我们发现现在多了一个 <code>cpu.out</code> 文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sheng$ ls</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.out</span>add<span class="selector-class">.go</span>add_test<span class="selector-class">.go</span>calculator<span class="selector-class">.test</span>cpu.out</span><br></pre></td></tr></table></figure><p>查看之后你会发现是一个二进制文件，那我们该如何处理呢？Go语言的 <code>pprof</code> 就要登场了</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sheng$</span> less cpu.out</span><br><span class="line"><span class="string">"cpu.out"</span> may <span class="keyword">be </span>a <span class="keyword">binary </span>file.  See <span class="keyword">it </span>anyway?</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go<span class="built_in"> tool </span>pprof cpu.out</span><br><span class="line">Main binary filename <span class="keyword">not</span> available.</span><br><span class="line">Type: cpu</span><br><span class="line">Time: May 9, 2018 at 5:40pm (CST)</span><br><span class="line">Duration: 907.82ms, Total samples = 600ms (66.09%)</span><br><span class="line">Entering interactive mode (type <span class="string">"help"</span> <span class="keyword">for</span> commands, <span class="string">"o"</span> <span class="keyword">for</span> options)</span><br><span class="line">(pprof)</span><br></pre></td></tr></table></figure><p>这时候出现了一个交互式的命令行，我们可以通过输入 help 得到相关的使用说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">(pprof) <span class="keyword">help</span></span><br><span class="line">  Commands:</span><br><span class="line">    callgrind        Outputs a graph <span class="keyword">in</span> callgrind <span class="keyword">format</span></span><br><span class="line">    comments         <span class="keyword">Output</span> all profile comments</span><br><span class="line">    disasm           <span class="keyword">Output</span> <span class="keyword">assembly</span> listings annotated <span class="keyword">with</span> samples</span><br><span class="line">    dot              Outputs a graph <span class="keyword">in</span> DOT <span class="keyword">format</span></span><br><span class="line">    eog              Visualize graph <span class="keyword">through</span> eog</span><br><span class="line">    evince           Visualize graph <span class="keyword">through</span> evince</span><br><span class="line">    gif              Outputs a graph image <span class="keyword">in</span> GIF <span class="keyword">format</span></span><br><span class="line">    gv               Visualize graph <span class="keyword">through</span> gv</span><br><span class="line">    kcachegrind      Visualize report <span class="keyword">in</span> KCachegrind</span><br><span class="line">    <span class="keyword">list</span>             <span class="keyword">Output</span> annotated <span class="keyword">source</span> <span class="keyword">for</span> functions matching regexp</span><br><span class="line">    pdf              Outputs a graph <span class="keyword">in</span> PDF <span class="keyword">format</span></span><br><span class="line">    peek             <span class="keyword">Output</span> callers/callees <span class="keyword">of</span> functions matching regexp</span><br><span class="line">    png              Outputs a graph image <span class="keyword">in</span> PNG <span class="keyword">format</span></span><br><span class="line">    proto            Outputs the profile <span class="keyword">in</span> compressed protobuf <span class="keyword">format</span></span><br><span class="line">    ps               Outputs a graph <span class="keyword">in</span> PS <span class="keyword">format</span></span><br><span class="line">    <span class="keyword">raw</span>              Outputs a <span class="built_in">text</span> representation <span class="keyword">of</span> the <span class="keyword">raw</span> profile</span><br><span class="line">    svg              Outputs a graph <span class="keyword">in</span> SVG <span class="keyword">format</span></span><br><span class="line">    tags             Outputs all tags <span class="keyword">in</span> the profile</span><br><span class="line">    <span class="built_in">text</span>             Outputs top entries <span class="keyword">in</span> <span class="built_in">text</span> <span class="keyword">form</span></span><br><span class="line">    top              Outputs top entries <span class="keyword">in</span> <span class="built_in">text</span> <span class="keyword">form</span></span><br><span class="line">    topproto         Outputs top entries <span class="keyword">in</span> compressed protobuf <span class="keyword">format</span></span><br><span class="line">    traces           Outputs all profile samples <span class="keyword">in</span> <span class="built_in">text</span> <span class="keyword">form</span></span><br><span class="line">    tree             Outputs a <span class="built_in">text</span> rendering <span class="keyword">of</span> <span class="keyword">call</span> graph</span><br><span class="line">    web              Visualize graph <span class="keyword">through</span> web browser</span><br><span class="line">    weblist          Display annotated <span class="keyword">source</span> <span class="keyword">in</span> a web browser</span><br><span class="line">    o/options        <span class="keyword">List</span> options <span class="keyword">and</span> their <span class="keyword">current</span> <span class="keyword">values</span></span><br><span class="line">    quit/<span class="keyword">exit</span>/^D     <span class="keyword">Exit</span> pprof</span><br><span class="line"></span><br><span class="line">  Options:</span><br><span class="line">    call_tree        <span class="keyword">Create</span> a <span class="keyword">context</span>-sensitive <span class="keyword">call</span> tree</span><br><span class="line">    compact_labels   <span class="keyword">Show</span> minimal headers</span><br><span class="line">    divide_by        Ratio <span class="keyword">to</span> divide all samples <span class="keyword">before</span> visualization</span><br><span class="line">    drop_negative    <span class="keyword">Ignore</span> negative differences</span><br><span class="line">    edgefraction     Hide edges below &lt;f&gt;*total</span><br><span class="line">    focus            Restricts <span class="keyword">to</span> samples going <span class="keyword">through</span> a node matching regexp</span><br><span class="line">    hide             Skips nodes matching regexp</span><br><span class="line">    <span class="keyword">ignore</span>           Skips paths going <span class="keyword">through</span> <span class="keyword">any</span> nodes matching regexp</span><br><span class="line">    mean             Average <span class="keyword">sample</span> <span class="keyword">value</span> <span class="keyword">over</span> <span class="keyword">first</span> <span class="keyword">value</span> (<span class="keyword">count</span>)</span><br><span class="line">    nodecount        <span class="keyword">Max</span> <span class="built_in">number</span> <span class="keyword">of</span> nodes <span class="keyword">to</span> <span class="keyword">show</span></span><br><span class="line">    nodefraction     Hide nodes below &lt;f&gt;*total</span><br><span class="line">    normalize        Scales profile based <span class="keyword">on</span> the base profile.</span><br><span class="line">    <span class="keyword">output</span>           <span class="keyword">Output</span> filename <span class="keyword">for</span> <span class="keyword">file</span>-based outputs</span><br><span class="line">    positive_percentages <span class="keyword">Ignore</span> negative samples <span class="keyword">when</span> computing percentages</span><br><span class="line">    prune_from       Drops <span class="keyword">any</span> functions below the <span class="keyword">matched</span> frame.</span><br><span class="line">    relative_percentages <span class="keyword">Show</span> percentages <span class="keyword">relative</span> <span class="keyword">to</span> focused subgraph</span><br><span class="line">    sample_index     <span class="keyword">Sample</span> <span class="keyword">value</span> <span class="keyword">to</span> report (<span class="number">0</span>-based <span class="keyword">index</span> <span class="keyword">or</span> <span class="keyword">name</span>)</span><br><span class="line">    <span class="keyword">show</span>             <span class="keyword">Only</span> <span class="keyword">show</span> nodes matching regexp</span><br><span class="line">    source_path      <span class="keyword">Search</span> <span class="keyword">path</span> <span class="keyword">for</span> <span class="keyword">source</span> files</span><br><span class="line">    tagfocus         Restricts <span class="keyword">to</span> samples <span class="keyword">with</span> tags <span class="keyword">in</span> <span class="keyword">range</span> <span class="keyword">or</span> <span class="keyword">matched</span> <span class="keyword">by</span> regexp</span><br><span class="line">    taghide          <span class="keyword">Skip</span> tags matching this regexp</span><br><span class="line">    tagignore        Discard samples <span class="keyword">with</span> tags <span class="keyword">in</span> <span class="keyword">range</span> <span class="keyword">or</span> <span class="keyword">matched</span> <span class="keyword">by</span> regexp</span><br><span class="line">    tagshow          <span class="keyword">Only</span> <span class="keyword">consider</span> tags matching this regexp</span><br><span class="line">    <span class="keyword">trim</span>             Honor nodefraction/edgefraction/nodecount <span class="keyword">defaults</span></span><br><span class="line">    unit             Measurement units <span class="keyword">to</span> display</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Option</span> <span class="keyword">groups</span> (<span class="keyword">only</span> <span class="keyword">set</span> one per <span class="keyword">group</span>):</span><br><span class="line">    cumulative</span><br><span class="line">      cum              <span class="keyword">Sort</span> entries based <span class="keyword">on</span> cumulative weight</span><br><span class="line">      flat             <span class="keyword">Sort</span> entries based <span class="keyword">on</span> own weight</span><br><span class="line">    granularity</span><br><span class="line">      addresses        <span class="keyword">Aggregate</span> <span class="keyword">at</span> the <span class="keyword">function</span> level.</span><br><span class="line">      addressnoinlines <span class="keyword">Aggregate</span> <span class="keyword">at</span> the <span class="keyword">function</span> <span class="keyword">level</span>, <span class="keyword">including</span> functions<span class="string">' addresses in the output.</span></span><br><span class="line"><span class="string">      files            Aggregate at the file level.</span></span><br><span class="line"><span class="string">      functions        Aggregate at the function level.</span></span><br><span class="line"><span class="string">      lines            Aggregate at the source code line level.</span></span><br><span class="line"><span class="string">      noinlines        Aggregate at the function level.</span></span><br><span class="line"><span class="string">  :   Clear focus/ignore/hide/tagfocus/tagignore</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  type "help &lt;cmd|option&gt;" for more information</span></span><br><span class="line"><span class="string">(pprof)</span></span><br></pre></td></tr></table></figure><p>我们这里就介绍一个最简单的方式，敲入web回车,z这里做一个温馨提示</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(pprof) web</span><br><span class="line">Failed to<span class="built_in"> execute </span>dot. Is Graphviz installed? Error: exec: <span class="string">"dot"</span>: executable file<span class="built_in"> not </span>found in $PATH</span><br></pre></td></tr></table></figure><p>出现上述报错的，是因为Graphviz没有安装，安装好了之后再敲入web会生成一个SVG文件,用浏览器打开它</p><p><img src="/media/15231955282344/15258608481013.jpg" alt=""></p><p>一张图可以很明显的表现出哪边花的时间多哪边花的时间少，当然也可以从框框的大小来做判断，我们需要优化比较大的框框的部分。上述的代码因为太过于简单，大家可以试着用自己写的代码进行性能分析。</p><h3 id="7-3、生成文档和事例代码"><a href="#7-3、生成文档和事例代码" class="headerlink" title="7.3、生成文档和事例代码"></a>7.3、生成文档和事例代码</h3><p>在我们实际的开发过程中，文档的重要性不必多说，服务调用方、协同开发的小伙伴、QA都需要文档；其他的语言我们经常需要依赖其他的文档工具，比如：ApiDoc、doxmate、daux等等。<br>首先我们先介绍一下 <code>go doc</code> 的常规的用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sheng$ <span class="keyword">go</span> doc</span><br><span class="line"><span class="keyword">package</span> calculator <span class="comment">// import "shengguocun.com/functional/calculator"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sheng$ <span class="keyword">go</span> doc Add</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="title">int32</span></span></span><br></pre></td></tr></table></figure><p>除此之外呢，我们可以通过help来查看</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go help doc</span><br><span class="line">usage: go doc [-u] [-c] [<span class="keyword">package</span>|[<span class="keyword">package</span>.]symbol[.methodOrField]]</span><br><span class="line"></span><br><span class="line">Doc prints the documentation comments associated <span class="keyword">with</span> the item identified by its</span><br><span class="line">arguments (a <span class="keyword">package</span>, const, func, <span class="keyword">type</span>, var, method, <span class="keyword">or</span> struct field)</span><br><span class="line">followed by a one-<span class="literal">line</span> summary <span class="keyword">of</span> each <span class="keyword">of</span> the first-level items <span class="string">"under"</span></span><br><span class="line">that item (<span class="keyword">package</span>-level declarations <span class="keyword">for</span> a <span class="keyword">package</span>, methods <span class="keyword">for</span> a <span class="keyword">type</span>,</span><br><span class="line">etc.).</span><br><span class="line"></span><br><span class="line">Doc accepts zero, one, <span class="keyword">or</span> two arguments.</span><br><span class="line"></span><br><span class="line">Given no arguments, that <span class="keyword">is</span>, <span class="keyword">when</span> run as</span><br><span class="line"></span><br><span class="line">go doc</span><br><span class="line"></span><br><span class="line">it prints the <span class="keyword">package</span> documentation <span class="keyword">for</span> the <span class="keyword">package</span> <span class="keyword">in</span> the current directory.</span><br><span class="line"><span class="keyword">If</span> the <span class="keyword">package</span> <span class="keyword">is</span> a command (<span class="keyword">package</span> main), the exported symbols <span class="keyword">of</span> the <span class="keyword">package</span></span><br><span class="line">are elided from the presentation unless the -cmd flag <span class="keyword">is</span> provided.</span><br><span class="line"></span><br><span class="line"><span class="keyword">When</span> run <span class="keyword">with</span> one argument, the argument <span class="keyword">is</span> treated as a Go-syntax-like</span><br><span class="line">representation <span class="keyword">of</span> the item <span class="keyword">to</span> be documented. What the argument selects depends</span><br><span class="line"><span class="keyword">on</span> what <span class="keyword">is</span> installed <span class="keyword">in</span> GOROOT <span class="keyword">and</span> GOPATH, as well as the form <span class="keyword">of</span> the argument,</span><br><span class="line">which <span class="keyword">is</span> schematically one <span class="keyword">of</span> these:</span><br><span class="line"></span><br><span class="line">go doc &lt;pkg&gt;</span><br><span class="line">go doc &lt;sym&gt;[.&lt;methodOrField&gt;]</span><br><span class="line">go doc [&lt;pkg&gt;.]&lt;sym&gt;[.&lt;methodOrField&gt;]</span><br><span class="line">go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt;</span><br><span class="line"></span><br><span class="line">The first item <span class="keyword">in</span> this list matched by the argument <span class="keyword">is</span> the one whose documentation</span><br><span class="line"><span class="keyword">is</span> printed. (See the examples below.) However, <span class="keyword">if</span> the argument starts <span class="keyword">with</span> a capital</span><br><span class="line">letter it <span class="keyword">is</span> assumed <span class="keyword">to</span> identify a symbol <span class="keyword">or</span> method <span class="keyword">in</span> the current directory.</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> packages, the order <span class="keyword">of</span> scanning <span class="keyword">is</span> determined lexically <span class="keyword">in</span> breadth-first order.</span><br><span class="line">That <span class="keyword">is</span>, the <span class="keyword">package</span> presented <span class="keyword">is</span> the one that matches the search <span class="keyword">and</span> <span class="keyword">is</span> nearest</span><br><span class="line">the root <span class="keyword">and</span> lexically first at its level <span class="keyword">of</span> the hierarchy. The GOROOT tree <span class="keyword">is</span></span><br><span class="line">always scanned <span class="keyword">in</span> its entirety before GOPATH.</span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> there <span class="keyword">is</span> no <span class="keyword">package</span> specified <span class="keyword">or</span> matched, the <span class="keyword">package</span> <span class="keyword">in</span> the current</span><br><span class="line">directory <span class="keyword">is</span> selected, so <span class="string">"go doc Foo"</span> shows the documentation <span class="keyword">for</span> symbol Foo <span class="keyword">in</span></span><br><span class="line">the current <span class="keyword">package</span>.</span><br><span class="line"></span><br><span class="line">The <span class="keyword">package</span> path must be either a qualified path <span class="keyword">or</span> a proper suffix <span class="keyword">of</span> a</span><br><span class="line">path. The go tool<span class="symbol">'s</span> usual <span class="keyword">package</span> mechanism does <span class="keyword">not</span> apply: <span class="keyword">package</span> path</span><br><span class="line">elements like . <span class="keyword">and</span> ... are <span class="keyword">not</span> implemented by go doc.</span><br><span class="line"></span><br><span class="line"><span class="keyword">When</span> run <span class="keyword">with</span> two arguments, the first must be a full <span class="keyword">package</span> path (<span class="keyword">not</span> just a</span><br><span class="line">suffix), <span class="keyword">and</span> the second <span class="keyword">is</span> a symbol, <span class="keyword">or</span> symbol <span class="keyword">with</span> method <span class="keyword">or</span> struct field.</span><br><span class="line">This <span class="keyword">is</span> similar <span class="keyword">to</span> the syntax accepted by godoc:</span><br><span class="line"></span><br><span class="line">go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;methodOrField&gt;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">In</span> <span class="keyword">all</span> forms, <span class="keyword">when</span> matching symbols, lower-<span class="keyword">case</span> letters <span class="keyword">in</span> the argument match</span><br><span class="line">either <span class="keyword">case</span> but upper-<span class="keyword">case</span> letters match exactly. This means that there may be</span><br><span class="line">multiple matches <span class="keyword">of</span> a lower-<span class="keyword">case</span> argument <span class="keyword">in</span> a <span class="keyword">package</span> <span class="keyword">if</span> different symbols have</span><br><span class="line">different cases. <span class="keyword">If</span> this occurs, documentation <span class="keyword">for</span> <span class="keyword">all</span> matches <span class="keyword">is</span> printed.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line">go doc</span><br><span class="line">Show documentation <span class="keyword">for</span> current <span class="keyword">package</span>.</span><br><span class="line">go doc Foo</span><br><span class="line">Show documentation <span class="keyword">for</span> Foo <span class="keyword">in</span> the current <span class="keyword">package</span>.</span><br><span class="line">(Foo starts <span class="keyword">with</span> a capital letter so it cannot match</span><br><span class="line">a <span class="keyword">package</span> path.)</span><br><span class="line">go doc encoding/json</span><br><span class="line">Show documentation <span class="keyword">for</span> the encoding/json <span class="keyword">package</span>.</span><br><span class="line">go doc json</span><br><span class="line">Shorthand <span class="keyword">for</span> encoding/json.</span><br><span class="line">go doc json.Number (<span class="keyword">or</span> go doc json.number)</span><br><span class="line">Show documentation <span class="keyword">and</span> method summary <span class="keyword">for</span> json.Number.</span><br><span class="line">go doc json.Number.Int64 (<span class="keyword">or</span> go doc json.number.int64)</span><br><span class="line">Show documentation <span class="keyword">for</span> json.Number<span class="symbol">'s</span> Int64 method.</span><br><span class="line">go doc cmd/doc</span><br><span class="line">Show <span class="keyword">package</span> docs <span class="keyword">for</span> the doc command.</span><br><span class="line">go doc -cmd cmd/doc</span><br><span class="line">Show <span class="keyword">package</span> docs <span class="keyword">and</span> exported symbols within the doc command.</span><br><span class="line">go doc template.<span class="keyword">new</span></span><br><span class="line">Show documentation <span class="keyword">for</span> html/template<span class="symbol">'s</span> <span class="keyword">New</span> <span class="keyword">function</span>.</span><br><span class="line">(html/template <span class="keyword">is</span> lexically before <span class="literal">text</span>/template)</span><br><span class="line">go doc <span class="literal">text</span>/template.<span class="keyword">new</span> # One argument</span><br><span class="line">Show documentation <span class="keyword">for</span> <span class="literal">text</span>/template<span class="symbol">'s</span> <span class="keyword">New</span> <span class="keyword">function</span>.</span><br><span class="line">go doc <span class="literal">text</span>/template <span class="keyword">new</span> # Two arguments</span><br><span class="line">Show documentation <span class="keyword">for</span> <span class="literal">text</span>/template<span class="symbol">'s</span> <span class="keyword">New</span> <span class="keyword">function</span>.</span><br><span class="line"></span><br><span class="line">At least <span class="keyword">in</span> the current tree, these invocations <span class="keyword">all</span> print the</span><br><span class="line">documentation <span class="keyword">for</span> json.Decoder<span class="symbol">'s</span> Decode method:</span><br><span class="line"></span><br><span class="line">go doc json.Decoder.Decode</span><br><span class="line">go doc json.decoder.decode</span><br><span class="line">go doc json.decode</span><br><span class="line">cd go/src/encoding/json; go doc decode</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">-c</span><br><span class="line">Respect <span class="keyword">case</span> <span class="keyword">when</span> matching symbols.</span><br><span class="line">-cmd</span><br><span class="line">Treat a command (<span class="keyword">package</span> main) like a regular <span class="keyword">package</span>.</span><br><span class="line">Otherwise <span class="keyword">package</span> main<span class="symbol">'s</span> exported symbols are hidden</span><br><span class="line"><span class="keyword">when</span> showing the <span class="keyword">package</span><span class="symbol">'s</span> top-level documentation.</span><br><span class="line">-u</span><br><span class="line">Show documentation <span class="keyword">for</span> unexported as well as exported</span><br><span class="line">symbols, methods, <span class="keyword">and</span> fields.</span><br></pre></td></tr></table></figure><p>再比如我们可以查看系统的文档</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go doc json.Decoder.Decode</span><br><span class="line">func (dec *Decoder) Decode(v interface&#123;&#125;) <span class="keyword">error</span></span><br><span class="line">    Decode reads <span class="keyword">the</span> next JSON-encoded value <span class="keyword">from</span> <span class="keyword">its</span> input <span class="keyword">and</span> stores <span class="keyword">it</span> <span class="keyword">in</span> <span class="keyword">the</span></span><br><span class="line">    value pointed <span class="keyword">to</span> <span class="keyword">by</span> v.</span><br><span class="line"></span><br><span class="line">    See <span class="keyword">the</span> documentation <span class="keyword">for</span> Unmarshal <span class="keyword">for</span> details <span class="keyword">about</span> <span class="keyword">the</span> conversion <span class="keyword">of</span> JSON</span><br><span class="line">    <span class="keyword">into</span> a Go value.</span><br><span class="line"></span><br><span class="line">sheng$ go doc fmt.Printf</span><br><span class="line">func Printf(format <span class="built_in">string</span>, a ...interface&#123;&#125;) (n int, err <span class="keyword">error</span>)</span><br><span class="line">    Printf formats according <span class="keyword">to</span> a format specifier <span class="keyword">and</span> writes <span class="keyword">to</span> standard</span><br><span class="line">    output. It returns <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> bytes written <span class="keyword">and</span> any <span class="built_in">write</span> <span class="keyword">error</span></span><br><span class="line">    encountered.</span><br></pre></td></tr></table></figure><p>当然我们最常用的命令是 <code>godoc</code> ，我们help看一下它的基本用法</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">sheng$ godoc -help</span><br><span class="line">usage: godoc package [name ...]</span><br><span class="line">godoc -<span class="keyword">http</span>=:<span class="number">6060</span></span><br><span class="line">  -analysis <span class="keyword">string</span></span><br><span class="line">    <span class="literal">comma</span>-separated list <span class="keyword">of</span> analyses <span class="built_in">to</span> perform (supported: type, pointer). See <span class="keyword">http</span>://golang.org/lib/godoc/analysis/help.html</span><br><span class="line">  -ex</span><br><span class="line">    show examples <span class="keyword">in</span> <span class="keyword">command</span> <span class="title">line</span> <span class="title">mode</span></span><br><span class="line">  -goroot <span class="keyword">string</span></span><br><span class="line">    Go root <span class="built_in">directory</span> (default <span class="string">"/usr/local/Cellar/go/1.10.2/libexec"</span>)</span><br><span class="line">  -html</span><br><span class="line">    print HTML <span class="keyword">in</span> <span class="keyword">command</span>-line <span class="title">mode</span></span><br><span class="line">  -<span class="keyword">http</span> <span class="keyword">string</span></span><br><span class="line">    HTTP service address (e.g., <span class="string">':6060'</span>)</span><br><span class="line">  -httptest.serve <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> non-<span class="literal">empty</span>, httptest.NewServer serves <span class="keyword">on</span> <span class="title">this</span> <span class="title">address</span> <span class="title">and</span> <span class="title">blocks</span></span><br><span class="line">  -index</span><br><span class="line">    enable search index</span><br><span class="line">  -index_files <span class="keyword">string</span></span><br><span class="line">    glob pattern specifying index <span class="built_in">files</span>; <span class="keyword">if</span> <span class="keyword">not</span> <span class="literal">empty</span>, <span class="keyword">the</span> index is <span class="built_in">read</span> <span class="built_in">from</span> these <span class="built_in">files</span> <span class="keyword">in</span> sorted order</span><br><span class="line">  -index_interval duration</span><br><span class="line">    interval <span class="keyword">of</span> indexing; <span class="number">0</span> <span class="keyword">for</span> default (<span class="number">5</span>m), negative <span class="built_in">to</span> only index once <span class="keyword">at</span> startup</span><br><span class="line">  -index_throttle float</span><br><span class="line">    index throttle <span class="built_in">value</span>; <span class="number">0.0</span> = no <span class="built_in">time</span> allocated, <span class="number">1.0</span> = full throttle (default <span class="number">0.75</span>)</span><br><span class="line">  -links</span><br><span class="line">    link identifiers <span class="built_in">to</span> their declarations (default <span class="literal">true</span>)</span><br><span class="line">  -maxresults int</span><br><span class="line">    maximum <span class="built_in">number</span> <span class="keyword">of</span> full <span class="keyword">text</span> search results shown (default <span class="number">10000</span>)</span><br><span class="line">  -notes <span class="keyword">string</span></span><br><span class="line">    regular expression matching note markers <span class="built_in">to</span> show (default <span class="string">"BUG"</span>)</span><br><span class="line">  -play</span><br><span class="line">    enable playground <span class="keyword">in</span> web interface</span><br><span class="line">  -qarguments are considered search queries</span><br><span class="line">  -server <span class="keyword">string</span></span><br><span class="line">    webserver address <span class="keyword">for</span> <span class="keyword">command</span> <span class="title">line</span> <span class="title">searches</span></span><br><span class="line">  -src</span><br><span class="line">    print (exported) source <span class="keyword">in</span> <span class="keyword">command</span>-line <span class="title">mode</span></span><br><span class="line">  -tabwidth int</span><br><span class="line">    <span class="literal">tab</span> width (default <span class="number">4</span>)</span><br><span class="line">  -templates <span class="keyword">string</span></span><br><span class="line">    <span class="built_in">load</span> templates/JS/CSS <span class="built_in">from</span> disk <span class="keyword">in</span> this <span class="built_in">directory</span></span><br><span class="line">  -timestamps</span><br><span class="line">    show timestamps <span class="keyword">with</span> <span class="built_in">directory</span> listings</span><br><span class="line">  -url <span class="keyword">string</span></span><br><span class="line">    print HTML <span class="keyword">for</span> named <span class="built_in">URL</span></span><br><span class="line">  -vverbose mode</span><br><span class="line">  -write_index</span><br><span class="line">    <span class="built_in">write</span> index <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">file</span>; <span class="keyword">the</span> <span class="built_in">file</span> name must be specified <span class="keyword">with</span> -index_files</span><br><span class="line">  -zip <span class="keyword">string</span></span><br><span class="line">    zip <span class="built_in">file</span> providing <span class="keyword">the</span> <span class="built_in">file</span> <span class="keyword">system</span> <span class="built_in">to</span> serve; disabled <span class="keyword">if</span> <span class="literal">empty</span></span><br></pre></td></tr></table></figure><p>我们看到有个http的用法，现在我们试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">sheng$</span><span class="bash"> godoc -http :6060</span></span><br></pre></td></tr></table></figure><p>打开浏览器，输入 <a href="http://localhost:6060" target="_blank" rel="noopener">http://localhost:6060</a></p><p><img src="/media/15231955282344/15258650494831.jpg" alt=""></p><p>完整的Web版的Go语言的文档就可以使用了。当然不单单包含系统函数，同时还包含我们自己写的函数的文档，现在我们就演示一下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加法函数</span></span><br><span class="line">func Add(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> int32) int32 &#123;</span><br><span class="line"></span><br><span class="line">return <span class="selector-tag">a</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在函数前面加上了注释，这是我们重新启动 <code>godoc -http :6060</code> 我们会发现</p><p><img src="/media/15231955282344/15258654981479.jpg" alt=""></p><p>相关的注释已经加上了。Go语言除此之外还提供了写示例代码的方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">ExampleAdd</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">c </span>:= <span class="built_in">Add</span>(1, 3)</span><br><span class="line">fmt.<span class="built_in">Println</span>(c)</span><br><span class="line"></span><br><span class="line">// Output:</span><br><span class="line">// <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接添加一个 <code>ExampleAdd</code> 函数，还是像之前一样写代码，最后我们要写一个 <code>Output</code> 的注释，那你现在是否有疑问，下面的 1 是什么意思？这里说下，这是我随便写的，这时候 <code>Run Test</code> 这段代码</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">=== RUN   ExampleAdd</span></span><br><span class="line"><span class="bullet">--- </span>FAIL: ExampleAdd (0.00s)</span><br><span class="line">got:</span><br><span class="line">4</span><br><span class="line">want:</span><br><span class="line">1</span><br><span class="line">FAIL</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>我们再把正确的输出贴到上面的输出中，重启godoc</p><p><img src="/media/15231955282344/15258664478886.jpg" alt=""></p><p>这时候完整的示例代码就已经生成到文档中了。</p><h2 id="8-Goroutine"><a href="#8-Goroutine" class="headerlink" title="8. Goroutine"></a>8. Goroutine</h2><h3 id="8-0、Goroutine介绍"><a href="#8-0、Goroutine介绍" class="headerlink" title="8.0、Goroutine介绍"></a>8.0、Goroutine介绍</h3><h4 id="协程-Coroutine"><a href="#协程-Coroutine" class="headerlink" title="协程 Coroutine"></a>协程 Coroutine</h4><h5 id="轻量级”线程”"><a href="#轻量级”线程”" class="headerlink" title="轻量级”线程”"></a>轻量级”线程”</h5><p>上面的两个特征到底是什么意思呢？下面我们通过具体的事例详细的讲述一下，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Goroutine :"</span> , i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码有问题么? 这就是一个从 0 到 10 的调用，但是匿名函数内部没有中止条件，所以会进入一个死循环。要是我们在匿名函数前加上 <strong>go</strong> 关键字，就不是刚才的意思了，就变成并发执行这个函数。主程序继续向下跑，同时并发开了一个函数，就相当于开了一个线程，当然我们后面会继续介绍，这个叫 <strong>协程</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Goroutine :"</span> , i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再执行这段代码，发现什么都没有输出，这又是为什么呢？因为这个 <code>main</code> 和 <code>fmt.Println</code> 是并发执行的，我们还来不及print结果， <code>main</code> 就执行完成退出了。Go语言一旦main函数退出了，所有的Goroutine就被杀掉了。<br>当然要是想看到输出结果，main函数可以在最后sleep一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Goroutine :"</span> , i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候就有相关的结果输出了。那我们将现在的10改成1000，又会怎样呢？当然还是可以正常输出的，熟悉操作系统的都知道正常的线程几十个上百个是没啥问题的，1000个还是有点难度的，其它语言通常使用异步IO的方式。在Go语言中我们不用管10个、100个、1000个代码还是一样的写法。</p><h5 id="非抢占式多任务处理，由协程主动交出控制权"><a href="#非抢占式多任务处理，由协程主动交出控制权" class="headerlink" title="非抢占式多任务处理，由协程主动交出控制权"></a>非抢占式多任务处理，由协程主动交出控制权</h5><p><strong>非抢占式多任务</strong> 这又是什么意思呢？下面我们用一个例子来解释一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a[i] ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行之前，可以想一下会输出什么呢? 什么也没有输出，进入了死循环。</p><p><img src="/media/15231955282344/15259278282666.jpg" alt=""></p><p>上图是我的活动监视器的截图，因为是4核的机器，几乎全部占满了。退不出的原因是因为Goroutine a[i] 交不出控制权，没有yield出去，同时main函数也是一个goroutine，因为没人交出控制权，所以下面的sleep永远也不会执行。<br>那我该如何交出控制权呢？我们可以做一个IO操作可以交出控制权，当然也可以手动交出控制权</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a[i] ++</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要加上 <code>runtime.Gosched()</code> ，这样大家都主动让出控制权，这时候代码可以正常输出了</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">321</span> <span class="number">986</span> <span class="number">890</span> <span class="number">880</span> <span class="number">831</span> <span class="number">881</span> <span class="number">919</span> <span class="number">904</span> <span class="number">861</span> <span class="number">904</span>]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果我们把goroutine的参数 <strong>i</strong> 去掉会怎样呢？<br>直接的看语法上没有什么问题，就变成了一个闭包，使用外部的变量 <strong>i</strong> ，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a[i] ++</span><br><span class="line">runtime.Gosched()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后会出现什么问题呢？</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">panic</span>: runtime error: index out of range</span><br><span class="line"></span><br><span class="line">goroutine 6 [running]:</span><br><span class="line">main.main.func1(0xc42001a0f0, 0xc42001c060)</span><br><span class="line">/Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:15 +0x45</span><br><span class="line">created by main.main</span><br><span class="line">/Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:13 +0x95</span><br><span class="line"></span><br><span class="line">Process finished with exit code 2</span><br></pre></td></tr></table></figure><p>这里我们通过Go语言的 <code>go run -race xxx.go</code> ，执行分析一下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go run -race route.go</span><br><span class="line">==================</span><br><span class="line"><span class="symbol">WARNING: </span>DATA RACE</span><br><span class="line">Read at 0x00c420092008 by goroutine 6:</span><br><span class="line"><span class="code">  main.main.func1()</span></span><br><span class="line"><span class="code">      /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:15 +0x54</span></span><br><span class="line"></span><br><span class="line">Previous write at 0x00c420092008 by main goroutine:</span><br><span class="line"><span class="code">  main.main()</span></span><br><span class="line"><span class="code">      /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:12 +0x11b</span></span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line"><span class="code">  main.main()</span></span><br><span class="line"><span class="code">      /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:13 +0xf1</span></span><br><span class="line">==================</span><br></pre></td></tr></table></figure><p>这个地址 <code>0x00c420092008</code> 是谁呢，很显然就是 <strong>i</strong> ，原因是因为在最后跳出来的时候 i 会变成10，里面的 <code>a[i] ++</code> 就会是a[10] ，所以出错的原因就在这。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sheng$ go run -race route.go</span><br><span class="line">==================</span><br><span class="line"><span class="symbol">WARNING: </span>DATA RACE</span><br><span class="line">Read at 0x00c420092008 by goroutine 6:</span><br><span class="line"><span class="code">  main.main.func1()</span></span><br><span class="line"><span class="code">      /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:15 +0x54</span></span><br><span class="line"></span><br><span class="line">Previous write at 0x00c420092008 by main goroutine:</span><br><span class="line"><span class="code">  main.main()</span></span><br><span class="line"><span class="code">      /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:12 +0x11b</span></span><br><span class="line"></span><br><span class="line">Goroutine 6 (running) created at:</span><br><span class="line"><span class="code">  main.main()</span></span><br><span class="line"><span class="code">      /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:13 +0xf1</span></span><br><span class="line">==================</span><br></pre></td></tr></table></figure><p>上面还剩一个的两个Goroutine读写的问题需要我们后面介绍的Channel来解决。</p><h3 id="8-1、Go语言调度器"><a href="#8-1、Go语言调度器" class="headerlink" title="8.1、Go语言调度器"></a>8.1、Go语言调度器</h3><h5 id="多个协程可能在一个或多个线程上运行"><a href="#多个协程可能在一个或多个线程上运行" class="headerlink" title="多个协程可能在一个或多个线程上运行"></a>多个协程可能在一个或多个线程上运行</h5><p>首先我们先看一张普通函数和协程的对比图</p><p><img src="/media/15231955282344/15259316982938.jpg" alt=""></p><p>普通函数main函数和work函数都运行在一个线程里面，main函数在等work函数执行完才能执行其他的操作。可以看到普通函数 main 函数和 work 函数是单向的，但是发现协程的 main 和 work 是双向通道的，控制权可以在work也可以在main，不需要像普通函数那样等work函数执行完才交出控制权。协程中main和work可能执行在一个线程中，有可能执行在多个线程中。</p><p><img src="/media/15231955282344/15259325535349.jpg" alt=""></p><p>上图就是Go语言的协程， 首先下面会有一个调度器，负责调度协程，有些是一个goroutine放在一个线程里面，有的是两个，有的是多个，这些我们都不需要关注。</p><h4 id="goroutine定义"><a href="#goroutine定义" class="headerlink" title="goroutine定义"></a>goroutine定义</h4><ul><li><p>任何函数只需要加上go就能送给调度器运行</p></li><li><p>不需要在定义时区分是否是异步函数</p></li><li><p>调度器在合适的点进行切换</p></li><li><p>使用-race来检测数据访问冲突</p></li></ul><h5 id="goroutine可能的切换点"><a href="#goroutine可能的切换点" class="headerlink" title="goroutine可能的切换点"></a>goroutine可能的切换点</h5><ul><li><p>I/O 、select</p></li><li><p>channel</p></li><li><p>等待锁</p></li><li><p>函数调用（有时）</p></li><li><p>runtime.Gosched()</p></li></ul><p>上述仅是参考，不能保证切换，不能保证在其他的地方不切换</p><h2 id="9-Channel"><a href="#9-Channel" class="headerlink" title="9. Channel"></a>9. Channel</h2><h3 id="9-0、Channel介绍"><a href="#9-0、Channel介绍" class="headerlink" title="9.0、Channel介绍"></a>9.0、Channel介绍</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><img src="/media/15231955282344/15259339991866.jpg" alt=""></p><p>我们可以开很多个goroutine，goroutine和goroutine之间的双向通道就是channel。<br>首先我们先来介绍一下channel的用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>和其他类型类似，都是需要先创建声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line">num := &lt;- ch</span><br><span class="line">fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个简单的channel示例，同时channel是一等公民，可以作为参数也可以作为返回值，那我们就用一个例子来简单的演示一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(channels <span class="keyword">chan</span> <span class="keyword">int</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ch := <span class="keyword">range</span> channels &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Work ID :"</span>, num)</span><br><span class="line">fmt.Println(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWork</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">chan</span>&lt;- <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> work(ch, num)</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> channels [<span class="number">10</span>]<span class="keyword">chan</span>&lt;- <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">channels[i] = createWork(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">channels[i] &lt;- <span class="string">'M'</span> + i</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Work ID : 3</span><br><span class="line"><span class="number">80</span></span><br><span class="line">Work ID : 0</span><br><span class="line"><span class="number">77</span></span><br><span class="line">Work ID : 1</span><br><span class="line"><span class="number">78</span></span><br><span class="line">Work ID : 6</span><br><span class="line">Work ID : 9</span><br><span class="line"><span class="number">83</span></span><br><span class="line">Work ID : 4</span><br><span class="line">Work ID : 5</span><br><span class="line"><span class="number">82</span></span><br><span class="line"><span class="number">86</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line">Work ID : 8</span><br><span class="line"><span class="number">85</span></span><br><span class="line">Work ID : 2</span><br><span class="line"><span class="number">79</span></span><br><span class="line">Work ID : 7</span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure><p>结果为什么是乱序的呢？因为 <code>fmt.Println</code> 有I/O操作；上述例子，可以看到channel既可以作参数，也可以作为返回值。</p><h4 id="Buffer-Channel"><a href="#Buffer-Channel" class="headerlink" title="Buffer Channel"></a>Buffer Channel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span>  <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们要是光发送，没有接收是不行的，程序会报错,比如上述代码运行之后</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="string">error:</span> all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [chan send]:</span><br><span class="line">main.main()</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>channel/channel.<span class="string">go:</span><span class="number">42</span> +<span class="number">0x50</span></span><br></pre></td></tr></table></figure><p>我们可以设置一个缓冲区</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span>  <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure><p>缓冲区大小设置为5，只要发送不超过5个都不会报错，下面我们来演示一下buffer channel的使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>()  &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">channels </span>:= <span class="built_in">make</span>(chan  int, 5)</span><br><span class="line">go <span class="built_in">func</span>() &#123;</span><br><span class="line">for ch := range channels &#123;</span><br><span class="line"></span><br><span class="line">fmt.<span class="built_in">Println</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 1</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 2</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 3</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 4</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 5</span><br><span class="line"><span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span><span class="selector-class">.Millisecond</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出正常</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>比如我们确定数据结束了，可以在最后进行close；同时只能是发送方close的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>()  &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">channels </span>:= <span class="built_in">make</span>(chan  int, 5)</span><br><span class="line">go <span class="built_in">func</span>() &#123;</span><br><span class="line">for ch := range channels &#123;</span><br><span class="line"></span><br><span class="line">fmt.<span class="built_in">Println</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 1</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 2</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 3</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 4</span><br><span class="line"><span class="selector-tag">channels</span> &lt;<span class="selector-tag">-</span> 5</span><br><span class="line"><span class="selector-tag">close</span>(<span class="selector-tag">channels</span>)</span><br><span class="line"><span class="selector-tag">time</span><span class="selector-class">.Sleep</span>(<span class="selector-tag">time</span><span class="selector-class">.Millisecond</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直观地从输出结果来看，加不加close这两者是没有区别的。</p><h3 id="9-1、使用Channel等待任务结束"><a href="#9-1、使用Channel等待任务结束" class="headerlink" title="9.1、使用Channel等待任务结束"></a>9.1、使用Channel等待任务结束</h3><p>前面的例子中我们等待任务结束是通过sleep来处理，因为打印的数据较少，1 毫秒足够；但是这种方式等待任务结束显然不是很优雅。<br>对于任务结束首先我们需要确定的通知外面我们打印结束了，那我们又如何通知呢？在Go语言中我们不要通过共享内存来通信，而是要通过通信来共享内存。直接用Channel就可以，下面我们来改造上面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">in <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">done <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(in <span class="keyword">chan</span> <span class="keyword">int</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ch := <span class="keyword">range</span> in &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Work ID :"</span>, num)</span><br><span class="line">fmt.Println(ch)</span><br><span class="line">done&lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWork</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">worker</span></span> &#123;</span><br><span class="line"></span><br><span class="line">ch := worker&#123;</span><br><span class="line">in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">done: <span class="built_in">make</span>(<span class="keyword">chan</span>  <span class="keyword">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> work(ch.in, ch.done, num)</span><br><span class="line"><span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">workers[i] = createWork(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">workers[i].in &lt;- <span class="string">'M'</span> + i</span><br><span class="line">&lt;-workers[i].done</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印输出结果</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Work ID : 0</span><br><span class="line"><span class="number">77</span></span><br><span class="line">Work ID : 1</span><br><span class="line"><span class="number">78</span></span><br><span class="line">Work ID : 2</span><br><span class="line"><span class="number">79</span></span><br><span class="line">Work ID : 3</span><br><span class="line"><span class="number">80</span></span><br><span class="line">Work ID : 4</span><br><span class="line"><span class="number">81</span></span><br><span class="line">Work ID : 5</span><br><span class="line"><span class="number">82</span></span><br><span class="line">Work ID : 6</span><br><span class="line"><span class="number">83</span></span><br><span class="line">Work ID : 7</span><br><span class="line"><span class="number">84</span></span><br><span class="line">Work ID : 8</span><br><span class="line"><span class="number">85</span></span><br><span class="line">Work ID : 9</span><br><span class="line"><span class="number">86</span></span><br></pre></td></tr></table></figure><p>虽然sleep部分的代码已经删除了，但是发现是顺序打印的，这显然不是我想要的结果。Go语言对等待多任务完成提供了一个库 WaitGroup，下面我们就用它继续重构上述的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> worker <span class="keyword">struct</span> &#123;</span><br><span class="line">in <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">done <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">work</span><span class="params">(worker worker, num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ch := <span class="keyword">range</span> worker.in &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"Work ID :"</span>, num)</span><br><span class="line">fmt.Println(ch)</span><br><span class="line">worker.done()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWork</span><span class="params">(num <span class="keyword">int</span>, wg *sync.WaitGroup)</span> <span class="title">worker</span></span> &#123;</span><br><span class="line"></span><br><span class="line">worker := worker&#123;</span><br><span class="line">in: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),</span><br><span class="line">done: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Done() <span class="comment">// 每个任务做完了就调用Done</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> work(worker, num)</span><br><span class="line"><span class="keyword">return</span> worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> workers [<span class="number">10</span>]worker</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">workers[i] = createWork(i, &amp;wg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">10</span>) <span class="comment">// Add 总共有多少个任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">workers[i].in &lt;- <span class="string">'M'</span> + i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait() <span class="comment">// 等待所有的任务做完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Work ID : 4</span><br><span class="line"><span class="number">81</span></span><br><span class="line">Work ID : 5</span><br><span class="line"><span class="number">82</span></span><br><span class="line">Work ID : 1</span><br><span class="line"><span class="number">78</span></span><br><span class="line">Work ID : 2</span><br><span class="line"><span class="number">79</span></span><br><span class="line">Work ID : 6</span><br><span class="line">Work ID : 3</span><br><span class="line"><span class="number">80</span></span><br><span class="line">Work ID : 0</span><br><span class="line">Work ID : 9</span><br><span class="line"><span class="number">86</span></span><br><span class="line"><span class="number">83</span></span><br><span class="line"><span class="number">77</span></span><br><span class="line">Work ID : 7</span><br><span class="line"><span class="number">84</span></span><br><span class="line">Work ID : 8</span><br><span class="line"><span class="number">85</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这样相应的结果才是我们想要的。</p><h4 id="面试题实战"><a href="#面试题实战" class="headerlink" title="面试题实战"></a>面试题实战</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协程交替执行,使其能顺序输出<span class="number">1</span><span class="number">-20</span>的自然数</span><br></pre></td></tr></table></figure><p>这个问题就不做演示了，留给读者自行发挥。</p><h3 id="9-2、用select进行调度"><a href="#9-2、用select进行调度" class="headerlink" title="9.2、用select进行调度"></a>9.2、用select进行调度</h3><h4 id="1、select使用"><a href="#1、select使用" class="headerlink" title="1、select使用"></a>1、select使用</h4><p>首先我们先来介绍一下select常规的应用场景，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>我们有两个channel，我们想从 ch1、ch2 里面收数据，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">data1 := &lt;- ch1</span><br><span class="line">data2 := &lt;- ch2</span><br></pre></td></tr></table></figure><p>谁快我就要谁，这就是我们的select</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch1, ch2 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> data := &lt;- ch1:</span><br><span class="line">fmt.Println(<span class="string">"CH1 的数据："</span>, data)</span><br><span class="line"><span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">fmt.Println(<span class="string">"CH2 的数据："</span>, data)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"没收到 CH1、CH2 的数据"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就相当于做了一个非阻塞式的获取。下面我们就结合一个channel生成器来做一个例子演示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genChan</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="number">1000</span>)))</span><br><span class="line">out &lt;- i</span><br><span class="line">i ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch1, ch2 = genChan(), genChan()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> data := &lt;- ch1:</span><br><span class="line">fmt.Println(<span class="string">"CH1 的数据："</span>, data)</span><br><span class="line"><span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">fmt.Println(<span class="string">"CH2 的数据："</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果（部分）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CH1 的数据： <span class="number">0</span></span><br><span class="line">CH2 的数据： <span class="number">0</span></span><br><span class="line">CH1 的数据： <span class="number">1</span></span><br><span class="line">CH2 的数据： <span class="number">1</span></span><br><span class="line">CH1 的数据： <span class="number">2</span></span><br><span class="line">CH2 的数据： <span class="number">2</span></span><br><span class="line">CH1 的数据： <span class="number">3</span></span><br><span class="line">CH2 的数据： <span class="number">3</span></span><br><span class="line">CH1 的数据： <span class="number">4</span></span><br><span class="line">CH2 的数据： <span class="number">4</span></span><br><span class="line">CH1 的数据： <span class="number">5</span></span><br><span class="line">CH2 的数据： <span class="number">5</span></span><br><span class="line">CH2 的数据： <span class="number">6</span></span><br><span class="line">CH1 的数据： <span class="number">6</span></span><br><span class="line">CH1 的数据： <span class="number">7</span></span><br><span class="line">CH1 的数据： <span class="number">8</span></span><br><span class="line">CH2 的数据： <span class="number">7</span></span><br><span class="line">CH1 的数据： <span class="number">9</span></span><br><span class="line">CH2 的数据： <span class="number">8</span></span><br><span class="line">CH1 的数据： <span class="number">10</span></span><br><span class="line">CH2 的数据： <span class="number">9</span></span><br><span class="line">CH1 的数据： <span class="number">11</span></span><br><span class="line">CH1 的数据： <span class="number">12</span></span><br><span class="line">CH1 的数据： <span class="number">13</span></span><br><span class="line">CH2 的数据： <span class="number">10</span></span><br><span class="line">CH2 的数据： <span class="number">11</span></span><br><span class="line">CH1 的数据： <span class="number">14</span></span><br><span class="line">CH2 的数据： <span class="number">12</span></span><br><span class="line">CH2 的数据： <span class="number">13</span></span><br><span class="line">CH1 的数据： <span class="number">15</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">130</span> (interrupted by signal <span class="number">2</span>: SIGINT)</span><br></pre></td></tr></table></figure><p>这就是select的一个应用场景，从输出结果可以看到，CH1、CH2的输出结果不一样，谁先出数据就先选择谁；两个同时出就随机的选择一个。</p><h4 id="2、定时器的使用"><a href="#2、定时器的使用" class="headerlink" title="2、定时器的使用"></a>2、定时器的使用</h4><p>比如上面的这段代码我想要在10秒之后程序就终止，我该如何处理呢？我们这里需要介绍一下Go语言的 <code>time.After</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After waits for the duration to elapse and then sends the current time</span></span><br><span class="line"><span class="comment">// on the returned channel.</span></span><br><span class="line"><span class="comment">// It is equivalent to NewTimer(d).C.</span></span><br><span class="line"><span class="comment">// The underlying Timer is not recovered by the garbage collector</span></span><br><span class="line"><span class="comment">// until the timer fires. If efficiency is a concern, use NewTimer</span></span><br><span class="line"><span class="comment">// instead and call Timer.Stop if the timer is no longer needed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码来看，他的返回值类型是一个 <code>&lt;-chan Time</code> ,那就方便很多了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genChan</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">out &lt;- i</span><br><span class="line">i ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ch1, ch2 = genChan(), genChan()</span><br><span class="line">tm := time.After(<span class="number">10</span> * time.Second) <span class="comment">// 加上10秒的定时</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> data := &lt;- ch1:</span><br><span class="line">fmt.Println(<span class="string">"CH1 的数据："</span>, data)</span><br><span class="line"><span class="keyword">case</span> data := &lt;-ch2:</span><br><span class="line">fmt.Println(<span class="string">"CH2 的数据："</span>, data)</span><br><span class="line"><span class="keyword">case</span> &lt;-tm:</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 收到指令程序直接return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行到10秒，代码自动退出。</p><h3 id="9-3、传统同步机制"><a href="#9-3、传统同步机制" class="headerlink" title="9.3、传统同步机制"></a>9.3、传统同步机制</h3><p>Go语言除了CSP模型外，还是有传统同步机制的，比如互斥量 <code>Mutex</code> ，现在我们就用它举个例子：<br>用互斥量实现 <code>atomic</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type atomicInt struct &#123;</span><br><span class="line">value int</span><br><span class="line">lock sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func increment(<span class="selector-tag">a</span> *atomicInt) &#123;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.lock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">defer <span class="selector-tag">a</span><span class="selector-class">.lock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.value</span> ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func get(<span class="selector-tag">a</span> *atomicInt) int &#123;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.lock</span><span class="selector-class">.Lock</span>()</span><br><span class="line">defer <span class="selector-tag">a</span><span class="selector-class">.lock</span><span class="selector-class">.Unlock</span>()</span><br><span class="line">return <span class="selector-tag">a</span>.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> atomicInt</span><br><span class="line">increment(&amp;a)</span><br><span class="line">go func() &#123;</span><br><span class="line">increment(&amp;a)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="selector-tag">time</span>.Sleep(<span class="selector-tag">time</span>.Second)</span><br><span class="line">fmt.Println(get(&amp;a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure><p>代码写完，可以用上面介绍的race来检查一下，是否有冲突，是否安全；当然这里还是不建议自己来造这些轮子的，直接使用系统的就可以了。系统提供了 <code>atomic.AddInt32()</code> 等等这些原子操作。</p><h2 id="10-Http及其他标准库"><a href="#10-Http及其他标准库" class="headerlink" title="10. Http及其他标准库"></a>10. Http及其他标准库</h2><h3 id="10-0、Http标准库介绍"><a href="#10-0、Http标准库介绍" class="headerlink" title="10.0、Http标准库介绍"></a>10.0、Http标准库介绍</h3><p>Go语言有很多的标准库，http库是最重要的之一，它对Http的封装也是非常完善的，之前我们有演示过服务端的一些基础使用，下面我们介绍一些客户端相关的使用</p><h4 id="1、使用http客户端发送请求"><a href="#1、使用http客户端发送请求" class="headerlink" title="1、使用http客户端发送请求"></a>1、使用http客户端发送请求</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">response, err := http.Get(<span class="string">"https://www.shengguocun.com"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()</span><br><span class="line"></span><br><span class="line">ss, err := httputil.DumpResponse(response, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s \n"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就把完整的头信息以及html的部分打印出来了。比如在我们现实的情境中，我们会根据UA做一些反作弊的策略，以及是否需要重定向到 M 端等等。这里的 <code>http.Client</code> 就能实现。</p><h4 id="2、使用http-Client控制请求头"><a href="#2、使用http-Client控制请求头" class="headerlink" title="2、使用http.Client控制请求头"></a>2、使用http.Client控制请求头</h4><p>请求头信息直接通过 <code>request.Header.Add</code> 添加就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">request, err := http.NewRequest(http.MethodGet,<span class="string">"https://www.shengguocun.com"</span>, <span class="literal">nil</span>)</span><br><span class="line">request.Header.Add(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36"</span>)</span><br><span class="line">response, err := http.DefaultClient.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()</span><br><span class="line"></span><br><span class="line">ss, err := httputil.DumpResponse(response, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s \n"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们都用的是 <strong>DefaultClient</strong> ，我们也可以自己创建 client， 首先我们先看一下 Client 内部都有些什么</p><p><img src="/media/15231955282344/15260240788691.jpg" alt=""></p><p>查看源码我们发现有一个 <code>CheckRedirect</code> ，我们发现这是一个检查重定向的函数。那我们就用它做一下演示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">request, err := http.NewRequest(http.MethodGet,<span class="string">"https://jim-sheng.github.io"</span>, <span class="literal">nil</span>)</span><br><span class="line">request.Header.Add(<span class="string">"User-Agent"</span>, <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36"</span>)</span><br><span class="line">client := http.Client&#123;</span><br><span class="line">CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"重定向地址："</span>, req)</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">response, err := client.Do(request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()</span><br><span class="line"></span><br><span class="line">ss, err := httputil.DumpResponse(response, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s \n"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果（部分）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">重定向地址： &amp;&#123;GET https://www.shengguocun.com/  <span class="number">0</span> <span class="number">0</span> map[User-Agent:[Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10</span>_12_4) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">66.0</span><span class="number">.3359</span><span class="number">.139</span> Safari/<span class="number">537.36</span>] Referer:[https://jim-sheng.github.<span class="built_in">io</span>]] &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt; <span class="number">0</span> [] <span class="literal">false</span>  map[] map[] &lt;<span class="literal">nil</span>&gt; map[]   &lt;<span class="literal">nil</span>&gt; &lt;<span class="literal">nil</span>&gt; <span class="number">0xc42012c090</span> &lt;<span class="literal">nil</span>&gt;&#125;</span><br><span class="line">HTTP/<span class="number">2.0</span> <span class="number">200</span> OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>我们可以看到具体的重定向的地址 <a href="https://www.shengguocun.com/">https://www.shengguocun.com/</a> ，其它的</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transport specifies the mechanism by which individual</span></span><br><span class="line"><span class="comment">// HTTP requests are made.</span></span><br><span class="line"><span class="comment">// If nil, DefaultTransport is used.</span></span><br><span class="line">Transport RoundTripper</span><br></pre></td></tr></table></figure><p>主要用于代理</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Jar specifies the cookie jar.</span><br><span class="line">//</span><br><span class="line">// The Jar is used to <span class="keyword">insert</span> relevant cookies <span class="keyword">into</span> every</span><br><span class="line">// outbound Request <span class="keyword">and</span> <span class="keyword">is</span> <span class="keyword">updated</span> <span class="keyword">with</span> the cookie <span class="keyword">values</span></span><br><span class="line">// <span class="keyword">of</span> every inbound Response. The Jar <span class="keyword">is</span> consulted <span class="keyword">for</span> every</span><br><span class="line">// redirect that the <span class="keyword">Client</span> follows.</span><br><span class="line">//</span><br><span class="line">// <span class="keyword">If</span> Jar <span class="keyword">is</span> nil, cookies <span class="keyword">are</span> <span class="keyword">only</span> sent <span class="keyword">if</span> they <span class="keyword">are</span> explicitly</span><br><span class="line">// <span class="keyword">set</span> <span class="keyword">on</span> the Request.</span><br><span class="line">Jar CookieJar</span><br></pre></td></tr></table></figure><p>主要用于模拟登录用的</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Timeout specifies <span class="keyword">a</span> <span class="built_in">time</span> limit <span class="keyword">for</span> requests made <span class="keyword">by</span> this</span><br><span class="line">// Client. The timeout includes connection <span class="built_in">time</span>, <span class="keyword">any</span></span><br><span class="line">// redirects, <span class="keyword">and</span> reading <span class="keyword">the</span> response body. The timer remains</span><br><span class="line">// running <span class="keyword">after</span> Get, Head, Post, <span class="keyword">or</span> Do <span class="literal">return</span> <span class="keyword">and</span> will</span><br><span class="line">// interrupt reading <span class="keyword">of</span> <span class="keyword">the</span> Response.Body.</span><br><span class="line">//</span><br><span class="line">// A Timeout <span class="keyword">of</span> <span class="literal">zero</span> means no timeout.</span><br><span class="line">//</span><br><span class="line">// The Client cancels requests <span class="built_in">to</span> <span class="keyword">the</span> underlying Transport</span><br><span class="line">// <span class="keyword">using</span> <span class="keyword">the</span> Request.Cancel mechanism. Requests passed</span><br><span class="line">// <span class="built_in">to</span> Client.Do may still <span class="built_in">set</span> Request.Cancel; both will</span><br><span class="line">// <span class="built_in">cancel</span> <span class="keyword">the</span> request.</span><br><span class="line">//</span><br><span class="line">// For compatibility, <span class="keyword">the</span> Client will also use <span class="keyword">the</span> deprecated</span><br><span class="line">// CancelRequest method <span class="keyword">on</span> <span class="title">Transport</span> <span class="title">if</span> <span class="title">found</span>. <span class="title">New</span></span><br><span class="line">// RoundTripper implementations should use Request.Cancel</span><br><span class="line">// instead <span class="keyword">of</span> implementing CancelRequest.</span><br><span class="line">Timeout <span class="built_in">time</span>.Duration</span><br></pre></td></tr></table></figure><p>主要设置超时的</p><h4 id="3、http服务器性能分析"><a href="#3、http服务器性能分析" class="headerlink" title="3、http服务器性能分析"></a>3、http服务器性能分析</h4><p>还是使用之前的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> appHandler <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">errWrapper</span><span class="params">(handler appHandler)</span> <span class="title">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err := handler(writer, request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> os.IsNotExist(err):</span><br><span class="line">http.Error(writer, http.StatusText(http.StatusNotFound), http.StatusNotFound)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/list/"</span>,</span><br><span class="line">errWrapper(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">path := request.URL.Path[<span class="built_in">len</span>(<span class="string">"/list/"</span>):]</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line">all, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer.Write(all)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServe(<span class="string">":2872"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是一样的代码，只不过import多了一个 <code>import _ &quot;net/http/pprof&quot;</code> , 为什么会多一个下划线呢？因为代码没有使用到，会报错，加一个下划线就可以了。重启代码，我们就可以访问 <a href="http://localhost:2872/debug/pprof/" target="_blank" rel="noopener">http://localhost:2872/debug/pprof/</a> 了</p><p><img src="/media/15231955282344/15260254493162.jpg" alt=""></p><p>里面的 stacktrace 都可以查看到</p><p><img src="/media/15231955282344/15260260333285.jpg" alt=""></p><p>我们可以查看 pprof 的源码，继续查看它的其他的使用方式</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Or <span class="built_in">to</span> look <span class="keyword">at</span> <span class="keyword">a</span> <span class="number">30</span>-<span class="keyword">second</span> CPU profile:</span><br><span class="line">//</span><br><span class="line">//go tool pprof <span class="keyword">http</span>://localhost:<span class="number">6060</span>/debug/pprof/profile</span><br></pre></td></tr></table></figure><p>比如这一段，我们可以查看30秒的CPU的使用情况。可以终端敲下该命令（替换成自己的监听的端口），获取出结果后敲下 web 命令就可以看下具体的代码哪些地方需要优化。其他的使用使用方式就不一一罗列了，有兴趣可以继续查阅。</p><h3 id="10-1、其他库"><a href="#10-1、其他库" class="headerlink" title="10.1、其他库"></a>10.1、其他库</h3><p>其它的标准库就不过多罗列了， <a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">https://studygolang.com/pkgdoc</a> 上面的中文版的文档已经非常详细了 。</p><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h2><p>Go语言给我们展现了不一样的世界观，没有类、继承、多态、重载，没有构造函数，没有断言，没有try/catch等等；上面是在学习Go语言的过程中，记录下来的笔记；也可能有部分地方存在偏颇，还望指点～～～</p><p><img src="/media/qrcode_mpweixin_shengguocun.jpg" alt=""></p><p>欢迎关注个人微信公众号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些
      
    
    </summary>
    
    
      <category term="Go语言" scheme="https://www.shengguocun.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
      <category term="入门" scheme="https://www.shengguocun.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>GDB抓虫之旅</title>
    <link href="https://www.shengguocun.com//blog/2018/03/15/taste-gdb/"/>
    <id>https://www.shengguocun.com//blog/2018/03/15/taste-gdb/</id>
    <published>2018-03-15T05:59:24.000Z</published>
    <updated>2018-03-15T06:08:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">问: gdb是什么？</span></span><br><span class="line"><span class="section">答: 强大的UNIX下命令行调试工具。</span></span><br><span class="line"></span><br><span class="line"><span class="section">问: gdb能干什么？</span></span><br><span class="line"><span class="section">答: 让你随心所欲的驾驭你的程序；Start、Stop、Examine、Change。</span></span><br><span class="line"></span><br><span class="line"><span class="section">问: 我们为什么要学习gdb？</span></span><br><span class="line"><span class="section">答: 欲善其事，必先利其器；利用gdb进一步的定位程序异常。</span></span><br><span class="line"></span><br><span class="line"><span class="section">问: 本次分享的宗旨?</span></span><br><span class="line"><span class="section">答: gdb的介绍和使用入门，为大家抓虫多提供一个选择。</span></span><br></pre></td></tr></table></figure><h2 id="抓虫从0开始"><a href="#抓虫从0开始" class="headerlink" title="抓虫从0开始"></a>抓虫从0开始</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><blockquote><p>1.包含有调试信息的可执行文件</p><p>2.编译时加-g选项即可，不建议开优化选项</p></blockquote><h3 id="GDB的启动"><a href="#GDB的启动" class="headerlink" title="GDB的启动"></a>GDB的启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb &lt;program&gt;</span><br><span class="line">gdb &lt;program&gt; core</span><br><span class="line">gdb &lt;program&gt; &lt;PID&gt;</span><br><span class="line">(gdb) file &lt;program&gt;</span><br></pre></td></tr></table></figure><h3 id="抓虫流程"><a href="#抓虫流程" class="headerlink" title="抓虫流程"></a>抓虫流程</h3><image src="http://nos.netease.com/ceb-report-document/detail_data/consume_detail_969e5fd49156d7ba2f98a301a2bb81da.jpeg?imageView&thumbnail=300x0"><h3 id="实战1-GDB基础命令的使用"><a href="#实战1-GDB基础命令的使用" class="headerlink" title="实战1 :  GDB基础命令的使用"></a>实战1 :  GDB基础命令的使用</h3><p>1.1、示例程序(example_1.cpp)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result+=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s1=<span class="string">"dafdf"</span>;</span><br><span class="line">    <span class="keyword">char</span> * s2;</span><br><span class="line"><span class="comment">//  s1=s2;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result[1-100]="</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result[1-250]="</span>&lt;&lt;foo(<span class="number">250</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2、调试准备<br>编译命令：g++ -g -Wall -o example_1 example_1.cpp</p><p>1.3、启动gdb</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gdb example_1</span><br><span class="line">GNU gdb Red Hat Linux (6.3.0.0-1.96rh)</span><br><span class="line">Copyright 2004 Free Software Foundation, Inc.</span><br><span class="line">GDB is free software, covered by the GNU General Public License, <span class="keyword">and</span> you are</span><br><span class="line">welcome <span class="keyword">to</span> change it <span class="keyword">and</span>/<span class="keyword">or</span> distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There is absolutely <span class="literal">no</span> warranty <span class="keyword">for</span> GDB. <span class="built_in"> Type </span><span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span><span class="built_in">..</span>.Using host libthread_db library <span class="string">"/lib64/tls/libthread_db.so.1"</span>.</span><br></pre></td></tr></table></figure><p>1.4、辅助性命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cd <span class="built_in">..</span></span><br><span class="line">Working directory /home/work/testers/sgc.</span><br><span class="line">(gdb) shell ls</span><br><span class="line">autotest <span class="built_in"> client </span> Makefile  spanti  spantispam_if.h  study</span><br><span class="line">(gdb) cd study/</span><br><span class="line">Working directory /home/work/testers/sgc/study.</span><br><span class="line">(gdb) pwd</span><br><span class="line">Working directory /home/work/testers/sgc/study.</span><br><span class="line">(gdb) help run</span><br><span class="line">Start debugged program.  You may specify arguments <span class="keyword">to</span> give it.</span><br><span class="line">Args may include <span class="string">"*"</span>, <span class="keyword">or</span> <span class="string">"[...]"</span>; they are expanded using <span class="string">"sh"</span>.</span><br><span class="line">Input <span class="keyword">and</span> output redirection with <span class="string">"&gt;"</span>, <span class="string">"&lt;"</span>, <span class="keyword">or</span> <span class="string">"&gt;&gt;"</span> are also allowed.</span><br><span class="line"></span><br><span class="line">With <span class="literal">no</span> arguments, uses arguments last specified (with <span class="string">"run"</span> <span class="keyword">or</span> <span class="string">"set args"</span>).</span><br><span class="line"><span class="keyword">To</span> cancel previous arguments <span class="keyword">and</span> <span class="builtin-name">run</span> with <span class="literal">no</span> arguments,</span><br><span class="line">use <span class="string">"set args"</span> without arguments.</span><br></pre></td></tr></table></figure><p>1.5、设置断点命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看源代码信息</span></span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br><span class="line"><span class="number">18</span>              &#125;</span><br><span class="line"><span class="number">19</span>              <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>      &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>      <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">24      </span>&#123;</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span>              <span class="built_in">string</span> s1=<span class="string">"dafdf"</span>;</span><br><span class="line">(gdb) l <span class="number">1</span></span><br><span class="line"><span class="number">1</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">2</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>       <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="number">6</span>       <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">7       </span>&#123;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">10</span></span><br><span class="line">(gdb) l example_1.cpp:<span class="number">16</span></span><br><span class="line"><span class="number">11</span>      &#125;</span><br><span class="line"><span class="number">12</span>      <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">13      </span>&#123;</span><br><span class="line"><span class="number">14</span>              <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>              <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">16</span>              &#123;</span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br><span class="line"><span class="number">18</span>              &#125;</span><br><span class="line"><span class="number">19</span>              <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">20</span></span><br><span class="line">(gdb) <span class="function">l <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">8</span></span><br><span class="line"><span class="function">9               <span class="keyword">return</span> 1</span>;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>      &#125;</span><br><span class="line"><span class="number">12</span>      <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">13      </span>&#123;</span><br><span class="line"><span class="number">14</span>              <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>              <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">16</span>              &#123;</span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置断点</span></span><br><span class="line">(gdb) <span class="selector-tag">b</span> <span class="number">17</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x400c07: file example_1<span class="selector-class">.cpp</span>, line <span class="number">17</span>.</span><br><span class="line">(gdb) <span class="selector-tag">b</span> main</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0</span>x400c27: file example_1<span class="selector-class">.cpp</span>, line <span class="number">26</span>.</span><br><span class="line">(gdb) info br</span><br><span class="line">Num Type           Disp Enb Address            What</span><br><span class="line"><span class="number">1</span>   breakpoint     keep y   <span class="number">0</span>x0000000000400c07 <span class="keyword">in</span> foo(int) at example_1<span class="selector-class">.cpp</span>:<span class="number">17</span></span><br><span class="line"><span class="number">2</span>   breakpoint     keep y   <span class="number">0</span>x0000000000400c27 <span class="keyword">in</span> main at example_1<span class="selector-class">.cpp</span>:<span class="number">26</span></span><br></pre></td></tr></table></figure><p>1.6、执行控制命令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting <span class="string">program:</span> <span class="regexp">/home/</span>work<span class="regexp">/testers/</span>sgc<span class="regexp">/study/</span>example_1</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, main () at example_1.<span class="string">cpp:</span><span class="number">26</span></span><br><span class="line"><span class="number">26</span>              string s1=<span class="string">"dafdf"</span>;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-100</span>]=<span class="number">5050</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, foo (n=<span class="number">250</span>) at example_1.<span class="string">cpp:</span><span class="number">17</span></span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">15</span>              <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br></pre></td></tr></table></figure><p>1.7、程序信息查看命令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//查看变量信息</span><br><span class="line">(gdb) p result</span><br><span class="line"><span class="number">$1</span> = <span class="number">250</span></span><br><span class="line">(gdb) p s1</span><br><span class="line"><span class="number">$2</span> = <span class="number">1431655765</span></span><br><span class="line"> (gdb) disp result</span><br><span class="line"><span class="number">1</span>: result = <span class="number">250</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, foo (n=<span class="number">250</span>) <span class="meta">at</span> example_1.cpp:<span class="number">17</span></span><br><span class="line"><span class="number">17</span>                      result+=n<span class="comment">;</span></span><br><span class="line"><span class="number">1</span>: result = <span class="number">250</span></span><br><span class="line">(gdb) info locals</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">250</span></span><br><span class="line"></span><br><span class="line">//查看栈信息</span><br><span class="line">(gdb) <span class="keyword">bt</span></span><br><span class="line">#<span class="number">0</span>  foo (n=<span class="number">250</span>) <span class="meta">at</span> example_1.cpp:<span class="number">17</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000400cc1</span> <span class="keyword">in</span> main () <span class="meta">at</span> example_1.cpp:<span class="number">38</span></span><br><span class="line">(gdb) info f</span><br><span class="line">Stack level <span class="number">0</span>, frame <span class="meta">at</span> <span class="number">0x7fbffff8a0</span>:</span><br><span class="line"> <span class="built_in">rip</span> = <span class="number">0x400c07</span> <span class="keyword">in</span> foo(<span class="keyword">int</span>) (example_1.cpp:<span class="number">17</span>)<span class="comment">; saved rip 0x400cc1</span></span><br><span class="line"> called by frame <span class="meta">at</span> <span class="number">0x7fbffff910</span></span><br><span class="line"> source language c++.</span><br><span class="line"> Arglist <span class="meta">at</span> <span class="number">0x7fbffff890</span>, args: n=<span class="number">250</span></span><br><span class="line"> Locals <span class="meta">at</span> <span class="number">0x7fbffff890</span>, Previous frame<span class="string">'s sp is 0x7fbffff8a0</span></span><br><span class="line"><span class="string"> Saved registers:</span></span><br><span class="line"><span class="string">  rbp at 0x7fbffff890, rip at 0x7fbffff898</span></span><br><span class="line"><span class="string">(gdb) f 0</span></span><br><span class="line"><span class="string">#0  foo (n=250) at example_1.cpp:17</span></span><br><span class="line"><span class="string">17                      result+=n;</span></span><br></pre></td></tr></table></figure><p>1.8、修改环境命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="builtin-name">set</span> var <span class="attribute">i</span>=97</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="variable">$5</span> = 97</span><br><span class="line">(gdb) <span class="builtin-name">print</span> <span class="attribute">i</span>=98</span><br><span class="line"><span class="variable">$6</span> = 98</span><br><span class="line">(gdb) ignore 1 300</span><br><span class="line">Will ignore next 300 crossings of breakpoint 1.</span><br><span class="line">(gdb) finish</span><br><span class="line"><span class="builtin-name">Run</span> till exit <span class="keyword">from</span> #0  foo (<span class="attribute">n</span>=250) at example_1.cpp:17</span><br><span class="line">0x0000000000400cc1 <span class="keyword">in</span> main () at example_1.cpp:38</span><br><span class="line">38              cout&lt;&lt;<span class="string">"result[1-250]="</span>&lt;&lt;foo(250)&lt;&lt;endl;</span><br><span class="line">Value returned is <span class="variable">$8</span> = 38500</span><br><span class="line">(gdb) quit</span><br><span class="line">The program is running.  Exit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure><h2 id="不要放过core文件"><a href="#不要放过core文件" class="headerlink" title="不要放过core文件"></a>不要放过core文件</h2><blockquote><p>问 ：Core文件是什么？<br>答 ：a disk file containing an <span style="color:red">image of the process’s memory</span> at the time of termination</p></blockquote><p><br></p><blockquote><p>问 ：Core的作用？<br>答 ：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、让你在调试时，不用花费大量等待程序出错；<br>&nbsp;&nbsp;&nbsp;&nbsp;2、让你避免了单步调试的烦恼<br>&nbsp;&nbsp;&nbsp;&nbsp;3、让你定位错误所在</p></blockquote><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb &lt;<span class="function"><span class="keyword">program</span></span>&gt; core</span><br></pre></td></tr></table></figure><h3 id="查看程序信息的常用命令"><a href="#查看程序信息的常用命令" class="headerlink" title="查看程序信息的常用命令"></a>查看程序信息的常用命令</h3><p>1、查看栈信息：bt, f n, up/down，info frame<br>2、查看变量信息：info args|locals</p><h3 id="实战2-core文件调试"><a href="#实战2-core文件调试" class="headerlink" title="实战2 :  core文件调试"></a>实战2 :  core文件调试</h3><p>2.1、示例程序(crash2.c)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Strcpy</span><span class="params">(<span class="keyword">char</span> *to , <span class="keyword">char</span> *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(to , from);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">    Strcpy(s, <span class="string">"abcdefg"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2、查看信息</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./crash2 core.<span class="number">19562</span></span><br><span class="line">GNU gdb Red Hat Linux (<span class="number">6.3</span>.<span class="number">0.0</span>-<span class="number">1.96</span>rh)</span><br><span class="line">Copyright <span class="number">2004</span> Free Software Foundation, Inc.</span><br><span class="line">GDB <span class="keyword">is</span> free software, covered by the GNU General Public License, <span class="keyword">and</span> you are</span><br><span class="line">welcome <span class="keyword">to</span> change it <span class="keyword">and</span>/<span class="keyword">or</span> distribute copies <span class="keyword">of</span> it under certain conditions.</span><br><span class="line"><span class="keyword">Type</span> <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There <span class="keyword">is</span> absolutely no warranty <span class="keyword">for</span> GDB.  <span class="keyword">Type</span> <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>...Using host libthread_db <span class="keyword">library</span> <span class="string">"/lib64/tls/libthread_db.so.1"</span>.</span><br><span class="line"></span><br><span class="line">Core was generated by `./crash2'.</span><br><span class="line">Program terminated <span class="keyword">with</span> <span class="keyword">signal</span> <span class="number">11</span>, Segmentation fault.</span><br><span class="line">Reading symbols from /lib64/tls/libc.so.<span class="number">6</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x000000302af6f9a4 <span class="keyword">in</span> strcpy () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x000000302af6f9a4 <span class="keyword">in</span> strcpy () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00000000004004c5 <span class="keyword">in</span> Strcpy (<span class="keyword">to</span>=<span class="number">0</span>x0, from=<span class="number">0</span>x4005dc <span class="string">"abcdefg"</span>) at crash2.c:<span class="number">5</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x00000000004004e5 <span class="keyword">in</span> main () at crash2.c:<span class="number">10</span></span><br><span class="line">(gdb) f <span class="number">0</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x000000302af6f9a4 <span class="keyword">in</span> strcpy () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">(gdb) up</span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00000000004004c5 <span class="keyword">in</span> Strcpy (<span class="keyword">to</span>=<span class="number">0</span>x0, from=<span class="number">0</span>x4005dc <span class="string">"abcdefg"</span>) at crash2.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>                       strcpy(<span class="keyword">to</span> , from);</span><br><span class="line">(gdb) info args</span><br><span class="line"><span class="keyword">to</span> = <span class="number">0</span>x0</span><br><span class="line">from = <span class="number">0</span>x4005dc <span class="string">"abcdefg"</span></span><br><span class="line"></span><br><span class="line">//至此，已经清楚的发现了问题所在，<span class="keyword">to</span>指针为空</span><br></pre></td></tr></table></figure><h2 id="进阶之多线程程序调试"><a href="#进阶之多线程程序调试" class="headerlink" title="进阶之多线程程序调试"></a>进阶之多线程程序调试</h2><h3 id="多线程调试常用命令"><a href="#多线程调试常用命令" class="headerlink" title="多线程调试常用命令"></a>多线程调试常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> info &lt;...&gt;  // 强大的查看命令，如info threads</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> attach/detach &lt;pid&gt; // 挂载到进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> thread &lt;thread_no&gt; // 切换到线程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> thread apply &lt;thread_no_list&gt; &lt;cmd&gt;</span></span><br><span class="line"> // 对于list中的thread，执行cmd</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">break</span> &lt;linenum&gt; thread &lt;threadno&gt; <span class="keyword">if</span> ...</span></span><br></pre></td></tr></table></figure><h3 id="实战3-多线程程序调试"><a href="#实战3-多线程程序调试" class="headerlink" title="实战3 :  多线程程序调试"></a>实战3 :  多线程程序调试</h3><p>3.1、正常的示例程序(good_thread.c)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mut;</span><br><span class="line"><span class="keyword">int</span> number=<span class="number">0</span>, i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"thread1 : I'm thread 1\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread1 : number = %d\n"</span>,number);</span><br><span class="line">                pthread_mutex_lock(&amp;mut);</span><br><span class="line">                        number++;</span><br><span class="line">                pthread_mutex_unlock(&amp;mut);</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread1 :主函数在等我完成任务吗？\n"</span>);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread2 : I'm thread 2\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread2 : number = %d\n"</span>,number);</span><br><span class="line">                pthread_mutex_lock(&amp;mut);</span><br><span class="line">                        number++;</span><br><span class="line">                 pthread_mutex_unlock(&amp;mut);</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread2 :主函数在等我完成任务吗？\n"</span>);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;thread, <span class="number">0</span>, <span class="keyword">sizeof</span>(thread));          <span class="comment">//comment1</span></span><br><span class="line">       <span class="comment">/*创建线程*/</span></span><br><span class="line">        <span class="keyword">if</span>((temp = pthread_create(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>)) != <span class="number">0</span>)       <span class="comment">//comment2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程1创建失败!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程1被创建\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>((temp = pthread_create(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>)) != <span class="number">0</span>) <span class="comment">//comment3</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程2创建失败"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程2被创建\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_wait</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*等待线程结束*/</span></span><br><span class="line">        <span class="keyword">if</span>(thread[<span class="number">0</span>] !=<span class="number">0</span>) &#123;                   <span class="comment">//comment4</span></span><br><span class="line">                pthread_join(thread[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程1已经结束\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(thread[<span class="number">1</span>] !=<span class="number">0</span>) &#123;                <span class="comment">//comment5</span></span><br><span class="line">                pthread_join(thread[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程2已经结束\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*用默认属性初始化互斥锁*/</span></span><br><span class="line">        pthread_mutex_init(&amp;mut,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是主函数哦，我正在创建线程，呵呵\n"</span>);</span><br><span class="line">        thread_create();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是主函数哦，我正在等待线程完成任务阿，呵呵\n"</span>);</span><br><span class="line">        thread_wait();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.2、演示过程</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gdb</span>)</span><br><span class="line"><span class="number">21</span>              printf (<span class="string">"thread1 : I'm thread 1\n"</span>)<span class="comment">;</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>              for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt; MAX; i++)</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span>              &#123;</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span>                      printf(<span class="string">"thread1 : number = %d\n"</span>,number)<span class="comment">;</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span>                      pthread_mutex_lock(<span class="name">&amp;mut</span>)<span class="comment">;</span></span><br><span class="line">(<span class="name">gdb</span>) b <span class="number">27</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x40079e: file good_thread.c, line <span class="number">27</span>.</span><br><span class="line">(<span class="name">gdb</span>)</span><br><span class="line"><span class="number">51</span>              for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt; MAX; i++)</span></span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span>              &#123;</span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="number">55</span>                      printf(<span class="string">"thread2 : number = %d\n"</span>,number)<span class="comment">;</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">57</span>                      pthread_mutex_lock(<span class="name">&amp;mut</span>)<span class="comment">;</span></span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">59</span>                              number++<span class="comment">;</span></span><br><span class="line">(<span class="name">gdb</span>) b <span class="number">57</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0</span>x400838: file good_thread.c, line <span class="number">57</span>.</span><br><span class="line">(<span class="name">gdb</span>) r</span><br><span class="line">Starting program: /home/work/testers/sgc/study/goodthread</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">[New Thread <span class="number">182894112416</span> (<span class="name">LWP</span> <span class="number">22783</span>)]</span><br><span class="line">ÎÒÊÇÖ÷º¯ÊýÅ¶£¬ÎÒÕýÔÚ´´½¨Ïß³Ì£¬ºÇºÇ</span><br><span class="line">[New Thread <span class="number">1084229984</span> (<span class="name">LWP</span> <span class="number">22786</span>)]</span><br><span class="line">Ïß³Ì<span class="number">1</span>±»´´½¨</span><br><span class="line">thread1 : I'm thread <span class="number">1</span></span><br><span class="line">[Switching to Thread <span class="number">1084229984</span> (<span class="name">LWP</span> <span class="number">22786</span>)]</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, thread1 () at good_thread.c:<span class="number">27</span></span><br><span class="line"><span class="number">27</span>                      printf(<span class="string">"thread1 : number = %d\n"</span>,number)<span class="comment">;</span></span><br><span class="line">(<span class="name">gdb</span>) bt</span><br><span class="line">#0  thread1 () at good_thread.c:<span class="number">27</span></span><br><span class="line">#1  <span class="number">0</span>x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.<span class="number">0</span></span><br><span class="line">#2  <span class="number">0</span>x000000302afc6003 in clone () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">#3  <span class="number">0</span>x0000000000000000 in ?? ()</span><br><span class="line">(<span class="name">gdb</span>) info threads</span><br><span class="line">[New Thread <span class="number">1094719840</span> (<span class="name">LWP</span> <span class="number">22787</span>)]</span><br><span class="line">  <span class="number">3</span> Thread <span class="number">1094719840</span> (<span class="name">LWP</span> <span class="number">22787</span>)  <span class="number">0</span>x000000302afc5fc4 in clone () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">* 2 Thread 1084229984 (LWP 22786)  thread1 () at good_thread.c:27</span><br><span class="line">  1 Thread 182894112416 (LWP 22783)  0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6</span><br><span class="line">(gdb) thread 1</span><br><span class="line">[Switching to thread 1 (Thread 182894112416 (LWP 22783))]#0  0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6</span><br><span class="line">#1  0x000000302b805d86 in do_clone () from /lib64/tls/libpthread.so.0</span><br><span class="line">#2  0x000000302b806846 in pthread_create@@GLIBC_2.2.5 () from /lib64/tls/libpthread.so.0</span><br><span class="line">#3  0x00000000004008fd in thread_create () at good_thread.c:91</span><br><span class="line">#4  0x00000000004009a9 in main () at good_thread.c:135</span><br></pre></td></tr></table></figure><p>3.3、死锁示例程序（multi_thread.c）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> AccountA_mutex;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> AccountB_mutex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span> &#123;</span></span><br><span class="line">     <span class="keyword">char</span> account_name[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">int</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span>  <span class="title">accountA</span> = &#123;</span><span class="string">'A'</span>, <span class="number">100000</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span>  <span class="title">accountB</span> = &#123;</span><span class="string">'B'</span>, <span class="number">200000</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">accountAB</span> <span class="params">(<span class="keyword">void</span>* amount_ptr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> amount = *((<span class="keyword">int</span>*)amount_ptr);</span><br><span class="line">     pthread_mutex_lock(&amp;AccountA_mutex);</span><br><span class="line">     <span class="keyword">if</span> (accountA.balance &lt; amount)   &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"There is not enough memory in Account A!\n"</span>);</span><br><span class="line">             pthread_mutex_unlock(&amp;AccountA_mutex);</span><br><span class="line">             pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     accountA.balance -=amount;</span><br><span class="line">     sleep(<span class="number">2</span>);</span><br><span class="line">     pthread_mutex_lock(&amp;AccountB_mutex);</span><br><span class="line">     accountB.balance +=amount;</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountA_mutex);</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountB_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">accountBA</span> <span class="params">(<span class="keyword">void</span>* amount_ptr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> amount = *((<span class="keyword">int</span>*)amount_ptr);</span><br><span class="line">     pthread_mutex_lock(&amp;AccountB_mutex);</span><br><span class="line">     <span class="keyword">if</span> (accountB.balance &lt; amount)   &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"There is not enough memory in Account B!\n"</span>);</span><br><span class="line">             pthread_mutex_unlock(&amp;AccountB_mutex);</span><br><span class="line">             pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     accountB.balance -=amount;</span><br><span class="line">     pthread_mutex_lock(&amp;AccountA_mutex);</span><br><span class="line">     accountA.balance +=amount;</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountB_mutex);</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountA_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> threadid[THREAD_NUM];</span><br><span class="line">     <span class="keyword">pthread_t</span> pthread[THREAD_NUM];</span><br><span class="line">     <span class="keyword">void</span>* thResState;</span><br><span class="line">     <span class="keyword">int</span> res, flag;</span><br><span class="line">     <span class="keyword">int</span> transfer_amount[THREAD_NUM] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">800</span>,<span class="number">700</span>,<span class="number">600</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">300</span>,<span class="number">200</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">     pthread_attr_init(&amp;attr);</span><br><span class="line">     pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(flag=<span class="number">0</span>; flag&lt;THREAD_NUM; flag++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountAB, \</span><br><span class="line">                                (<span class="keyword">void</span>*)&amp;transfer_amount[flag]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">"Thread %d creation failed\n"</span>, flag);</span><br><span class="line">                      <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountBA, \</span><br><span class="line">                                (<span class="keyword">void</span>*)&amp;transfer_amount[flag]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">"Thread %d creation failed\n"</span>, flag);</span><br><span class="line">                  <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(flag=<span class="number">0</span>; flag&lt;THREAD_NUM; flag++)&#123;</span><br><span class="line">           res = pthread_join(pthread[flag], &amp;thResState);</span><br><span class="line">           <span class="keyword">if</span> (res != <span class="number">0</span>)&#123;</span><br><span class="line">                  perror(<span class="string">"Thread join failed"</span>);</span><br><span class="line">                  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"thread success  id %u state code %d\n"</span>,threadid[flag],thResState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Transitions are in progress.."</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\nAll the  money is transferred !!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.4、错误定位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o multi_thread multi_thread.c –lpthread</span><br><span class="line">$ ./multi_thread</span><br><span class="line">$ ps -eLF |grep multi</span><br><span class="line">work    21675 19997 21675  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21676  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21677  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21678  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21679  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21680  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21681  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21682  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21683  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21684  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21685  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21686  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21687  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21688  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21689  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21690  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21691  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21692  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21693  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21694  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21695  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ gdb</span><br><span class="line">GNU gdb Red Hat Linux (6.3.0.0-1.96rh)</span><br><span class="line">Copyright 2004 Free Software Foundation, Inc.</span><br><span class="line">GDB is free software, covered by the GNU General Public License, and you are</span><br><span class="line">welcome to <span class="keyword">change</span> it <span class="keyword">and</span>/<span class="keyword">or</span> <span class="keyword">distribute</span> copies <span class="keyword">of</span> it <span class="keyword">under</span> certain conditions.</span><br><span class="line"><span class="keyword">Type</span> <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There <span class="keyword">is</span> absolutely <span class="keyword">no</span> warranty <span class="keyword">for</span> GDB.  <span class="keyword">Type</span> <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured <span class="keyword">as</span> <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">(gdb) attach <span class="number">21680</span></span><br><span class="line">Attaching <span class="keyword">to</span> process <span class="number">21680</span></span><br><span class="line">Reading symbols <span class="keyword">from</span> /home/<span class="keyword">work</span>/testers/sgc/study/multi_thread...done.</span><br><span class="line"><span class="keyword">Using</span> host libthread_db <span class="keyword">library</span> <span class="string">"/lib64/tls/libthread_db.so.1"</span>.</span><br><span class="line">Reading symbols <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span>...done.</span><br><span class="line">[<span class="keyword">Thread</span> debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">182894112416</span> (LWP <span class="number">21675</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1283537248</span> (LWP <span class="number">21695</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1273047392</span> (LWP <span class="number">21694</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1262557536</span> (LWP <span class="number">21693</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1252067680</span> (LWP <span class="number">21692</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1241577824</span> (LWP <span class="number">21691</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1231087968</span> (LWP <span class="number">21690</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1220598112</span> (LWP <span class="number">21689</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1210108256</span> (LWP <span class="number">21688</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1199618400</span> (LWP <span class="number">21687</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1189128544</span> (LWP <span class="number">21686</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1178638688</span> (LWP <span class="number">21685</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1168148832</span> (LWP <span class="number">21684</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1157658976</span> (LWP <span class="number">21683</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1147169120</span> (LWP <span class="number">21682</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1136679264</span> (LWP <span class="number">21681</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1126189408</span> (LWP <span class="number">21680</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1115699552</span> (LWP <span class="number">21679</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1105209696</span> (LWP <span class="number">21678</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1094719840</span> (LWP <span class="number">21677</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1084229984</span> (LWP <span class="number">21676</span>)]</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">Reading symbols <span class="keyword">from</span> /lib64/tls/libc.so<span class="number">.6</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/tls/libc.so<span class="number">.6</span></span><br><span class="line">Reading symbols <span class="keyword">from</span> /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span></span><br><span class="line"><span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000432041e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000432049f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) info threads</span><br><span class="line">  <span class="number">21</span> <span class="keyword">Thread</span> <span class="number">1084229984</span> (LWP <span class="number">21676</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">20</span> <span class="keyword">Thread</span> <span class="number">1094719840</span> (LWP <span class="number">21677</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">19</span> <span class="keyword">Thread</span> <span class="number">1105209696</span> (LWP <span class="number">21678</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">18</span> <span class="keyword">Thread</span> <span class="number">1115699552</span> (LWP <span class="number">21679</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">17</span> <span class="keyword">Thread</span> <span class="number">1126189408</span> (LWP <span class="number">21680</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">16</span> <span class="keyword">Thread</span> <span class="number">1136679264</span> (LWP <span class="number">21681</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">15</span> <span class="keyword">Thread</span> <span class="number">1147169120</span> (LWP <span class="number">21682</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">14</span> <span class="keyword">Thread</span> <span class="number">1157658976</span> (LWP <span class="number">21683</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">13</span> <span class="keyword">Thread</span> <span class="number">1168148832</span> (LWP <span class="number">21684</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">12</span> <span class="keyword">Thread</span> <span class="number">1178638688</span> (LWP <span class="number">21685</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">11</span> <span class="keyword">Thread</span> <span class="number">1189128544</span> (LWP <span class="number">21686</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">10</span> <span class="keyword">Thread</span> <span class="number">1199618400</span> (LWP <span class="number">21687</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">Thread</span> <span class="number">1210108256</span> (LWP <span class="number">21688</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">Thread</span> <span class="number">1220598112</span> (LWP <span class="number">21689</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">7</span> <span class="keyword">Thread</span> <span class="number">1231087968</span> (LWP <span class="number">21690</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">6</span> <span class="keyword">Thread</span> <span class="number">1241577824</span> (LWP <span class="number">21691</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">Thread</span> <span class="number">1252067680</span> (LWP <span class="number">21692</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">4</span> <span class="keyword">Thread</span> <span class="number">1262557536</span> (LWP <span class="number">21693</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">3</span> <span class="keyword">Thread</span> <span class="number">1273047392</span> (LWP <span class="number">21694</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">2</span> <span class="keyword">Thread</span> <span class="number">1283537248</span> (LWP <span class="number">21695</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">1</span> <span class="keyword">Thread</span> <span class="number">182894112416</span> (LWP <span class="number">21675</span>)  <span class="number">0x000000302b806ffb</span> <span class="keyword">in</span> pthread_join () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line"></span><br><span class="line">(gdb) <span class="keyword">thread</span> <span class="keyword">apply</span> all bt</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">21</span> (<span class="keyword">Thread</span> <span class="number">1084229984</span> (LWP <span class="number">21676</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">20</span> (<span class="keyword">Thread</span> <span class="number">1094719840</span> (LWP <span class="number">21677</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000414011e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000414019f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">19</span> (<span class="keyword">Thread</span> <span class="number">1105209696</span> (LWP <span class="number">21678</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000041e021e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000041e029f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">18</span> (<span class="keyword">Thread</span> <span class="number">1115699552</span> (LWP <span class="number">21679</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000428031e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000428039f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">17</span> (<span class="keyword">Thread</span> <span class="number">1126189408</span> (LWP <span class="number">21680</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000432041e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000432049f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">16</span> (<span class="keyword">Thread</span> <span class="number">1136679264</span> (LWP <span class="number">21681</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000043c051e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000043c059f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">15</span> (<span class="keyword">Thread</span> <span class="number">1147169120</span> (LWP <span class="number">21682</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000446061e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000446069f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">14</span> (<span class="keyword">Thread</span> <span class="number">1157658976</span> (LWP <span class="number">21683</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000450071e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000450079f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">13</span> (<span class="keyword">Thread</span> <span class="number">1168148832</span> (LWP <span class="number">21684</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000045a081e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000045a089f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">12</span> (<span class="keyword">Thread</span> <span class="number">1178638688</span> (LWP <span class="number">21685</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000464091e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000464099f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">11</span> (<span class="keyword">Thread</span> <span class="number">1189128544</span> (LWP <span class="number">21686</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000046e0a1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000046e0a9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="keyword">Thread</span> <span class="number">10</span> (<span class="keyword">Thread</span> <span class="number">1199618400</span> (LWP <span class="number">21687</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004780b1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004780b9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">9</span> (<span class="keyword">Thread</span> <span class="number">1210108256</span> (LWP <span class="number">21688</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004820c1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004820c9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">8</span> (<span class="keyword">Thread</span> <span class="number">1220598112</span> (LWP <span class="number">21689</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000048c0d1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000048c0d9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">7</span> (<span class="keyword">Thread</span> <span class="number">1231087968</span> (LWP <span class="number">21690</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004960e1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004960e9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">6</span> (<span class="keyword">Thread</span> <span class="number">1241577824</span> (LWP <span class="number">21691</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004a00f1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004a00f9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">5</span> (<span class="keyword">Thread</span> <span class="number">1252067680</span> (LWP <span class="number">21692</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004aa101e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004aa109f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="keyword">Thread</span> <span class="number">4</span> (<span class="keyword">Thread</span> <span class="number">1262557536</span> (LWP <span class="number">21693</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004b4111e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004b4119f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">3</span> (<span class="keyword">Thread</span> <span class="number">1273047392</span> (LWP <span class="number">21694</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004be121e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004be129f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span> (<span class="keyword">Thread</span> <span class="number">1283537248</span> (LWP <span class="number">21695</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004c8131e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004c8139f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="comment">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">1</span> (<span class="keyword">Thread</span> <span class="number">182894112416</span> (LWP <span class="number">21675</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b806ffb</span> <span class="keyword">in</span> pthread_join () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000400b69</span> <span class="keyword">in</span> <span class="keyword">main</span> (argc=<span class="number">1</span>, argv=<span class="number">0x7fbffffa08</span>) <span class="keyword">at</span> multi_thread.c:<span class="number">76</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GDB是一个好用的抓虫工具，随意控制进程，随便查看内存和环境；上述只是新手学习过程中的一些记录，欢迎深入探讨。</p></image>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="GDB" scheme="https://www.shengguocun.com/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.shengguocun.com//blog/2018/01/12/hello-world/"/>
    <id>https://www.shengguocun.com//blog/2018/01/12/hello-world/</id>
    <published>2018-01-12T06:29:51.000Z</published>
    <updated>2018-05-07T07:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
