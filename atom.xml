<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>盛国存</title>
  
  <subtitle>个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shengguocun.com/"/>
  <updated>2018-05-07T12:49:50.000Z</updated>
  <id>https://www.shengguocun.com/</id>
  
  <author>
    <name>ShengGuocun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A Bite of Golang</title>
    <link href="https://www.shengguocun.com//blog/2018/04/20/a-bite-of-golang/"/>
    <id>https://www.shengguocun.com//blog/2018/04/20/a-bite-of-golang/</id>
    <published>2018-04-20T06:54:03.000Z</published>
    <updated>2018-05-07T12:49:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些小的经验，同时为了方便让读者了解到Go语言中的一些概念，文中包含了许多快速简洁的例子，读者后期可以去自行拓展。当然写这篇文章的灵感来源于GitHub上的 a bite of Python</p><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-0、环境搭建"><a href="#1-0、环境搭建" class="headerlink" title="1.0、环境搭建"></a>1.0、环境搭建</h3><h4 id="1、下载安装包安装"><a href="#1、下载安装包安装" class="headerlink" title="1、下载安装包安装"></a>1、下载安装包安装</h4><p>通过浏览器访问下面的地址 <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> 要是自己的网络不能翻墙的话，可以访问下面的Go语言中文网 <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a> 下载指定的版本的安装包直接下一步就可以安装完成；</p><h4 id="2、命令行安装"><a href="#2、命令行安装" class="headerlink" title="2、命令行安装"></a>2、命令行安装</h4><p>Mac 利器 home brew 安装 go</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade</span><br><span class="line">brew install git</span><br><span class="line">brew install mercurial</span><br><span class="line">brew install go</span><br></pre></td></tr></table></figure><p>安装完成之后</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GOROOT</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOROOT</span>=/usr/local/Cellar/go/1.7.4/libexec</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOPATH</span>=<span class="variable">$HOME</span>/GoLangProject</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH bin</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOPATH/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH root bin</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOROOT/bin</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>OK配合完成之后,输入go env验证一下是否配置成功</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~ sheng$ go env</span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"darwin"</span></span><br><span class="line">GOOS=<span class="string">"darwin"</span></span><br><span class="line">GOPATH=<span class="string">"/Users/verton/GoLangProject"</span></span><br><span class="line">GORACE=<span class="string">""</span></span><br><span class="line">GOROOT=<span class="string">"/usr/local/Cellar/go/1.7.4/libexec"</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/usr/local/Cellar/go/1.7.4/libexec/pkg/tool/darwin_amd64"</span></span><br><span class="line">CC=<span class="string">"clang"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/z2/h48yrw8131g824_bvtw6584r0000gn/T/go-build415367881=/tmp/go-build -gno-record-gcc-switches -fno-common"</span></span><br><span class="line">CXX=<span class="string">"clang++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br></pre></td></tr></table></figure><h3 id="1-1、变量定义"><a href="#1-1、变量定义" class="headerlink" title="1.1、变量定义"></a>1.1、变量定义</h3><h4 id="1、通过var关键字"><a href="#1、通过var关键字" class="headerlink" title="1、通过var关键字"></a>1、通过var关键字</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> int</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> string</span><br></pre></td></tr></table></figure><p>在Go语言中在定义变量的时候，是变量在前类型在后，现在你暂时先不用考虑那么多为什么，就先知道Go是这样的定义形式就可以了；当然可以多个变量一起定义,同时可以一起赋初值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c bool</span><br><span class="line"><span class="selector-tag">var</span> m,n string = <span class="string">"Hello"</span>,<span class="string">"World"</span></span><br><span class="line"><span class="selector-tag">var</span> (</span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line">    bb = <span class="string">"hello world"</span></span><br><span class="line">    cc = true</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然也可以让编译器自动决定类型，比如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s,m,<span class="selector-tag">p</span>,<span class="selector-tag">q</span> = <span class="number">1</span>,<span class="string">"hahah"</span>,false,<span class="string">"xixiix"</span></span><br></pre></td></tr></table></figure><h4 id="2、使用-定义变量"><a href="#2、使用-定义变量" class="headerlink" title="2、使用 := 定义变量"></a>2、使用 := 定义变量</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s,m,<span class="selector-tag">p</span>,<span class="selector-tag">q</span> := <span class="number">1</span>,<span class="string">"hahah"</span>,false,<span class="string">"xixiix"</span></span><br></pre></td></tr></table></figure><p>这样呢可以让代码写的更加简短一点，当然呢 := 只能在函数内使用，是不能在函数外使用的。（相关的函数的知识后面会做介绍）</p><h3 id="1-2、内建变量类型"><a href="#1-2、内建变量类型" class="headerlink" title="1.2、内建变量类型"></a>1.2、内建变量类型</h3><h4 id="1、bool-、string"><a href="#1、bool-、string" class="headerlink" title="1、bool 、string"></a>1、bool 、string</h4><p>这两个类型就不做过多的介绍，因为基本每一门语言里面都有这两个类型，在Go语言里面也是一样的</p><h4 id="2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr"><a href="#2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr" class="headerlink" title="2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr"></a>2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr</h4><p>上面这些就是Go的整数类型，加u和不加u的区别就是有无符号的区别，Go语言中的整数类型还分为两个大类，一个是规定长度的，比如：int8、int16、int32…，还有一种就是不规定长度的，它是根据操作系统来，在32位系统就是32位，在64位系统就是64位的，Go语言中没有int、long 这些类型，你想要定义一个相对较长的定义int64就可以了，最后uintptr就是Go语言的指针，后面我会再来介绍它</p><h4 id="3、byte、rune"><a href="#3、byte、rune" class="headerlink" title="3、byte、rune"></a>3、byte、rune</h4><p>byte就不用过多介绍了，大家都知道字节类型，那rune是什么呢，这就是Go语言的“char”，因为char只有一个字节在使用中会有很多的坑，Go语言针对这点痛点做了一些优化</p><h4 id="4、float32、float64、complex64、complex128"><a href="#4、float32、float64、complex64、complex128" class="headerlink" title="4、float32、float64、complex64、complex128"></a>4、float32、float64、complex64、complex128</h4><p>前面两个不过多介绍，浮点数类型32位和64位的，后面两个是一个复数的类型，complex64实部和虚部都是32位的，complex128实部和虚部都是64位的</p><h3 id="1-3、常量与枚举"><a href="#1-3、常量与枚举" class="headerlink" title="1.3、常量与枚举"></a>1.3、常量与枚举</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = <span class="number">1</span></span><br><span class="line">const b,c = <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">const (</span><br><span class="line">    d = <span class="number">5</span></span><br><span class="line">    e,f = <span class="number">6</span>,<span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>常量数值可以作为各种类型使用,比如以下代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s,<span class="selector-tag">p</span> = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">m := math.Sqrt(s*s + p*p)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure><p>这段代码语法是编译不通过的，因为Sqrt的参数必须是一个浮点数类型；但是呢我们把是s、p定义成常量就可以编译通过了</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s,p = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">m := math.<span class="built_in">Sqrt</span>(s*s + p*p)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure><p>Go语言中的枚举类型就是通过const来实现，同时Go语言中还可以通过iota实现自增的功能</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func enums()&#123;</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line"><span class="selector-tag">a</span> = iota</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br><span class="line">fmt.Println(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用上面这个函数显而易见，会输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="1-4、条件语句"><a href="#1-4、条件语句" class="headerlink" title="1.4、条件语句"></a>1.4、条件语句</h3><h4 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h4><p>正常的条件判断我这边就不做过多的介绍，当然Go语言有它特别的地方，if的条件里可以赋值，比如：</p><p>举个读文件的例子，ioutil.ReadFile 这个方法有两个返回值，后面会详细的讲解，常规的写法是</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename  = <span class="string">"file.txt"</span></span><br><span class="line">content,<span class="keyword">err</span> := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="built_in">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言可以整合成下面的写法</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename  = <span class="string">"file.txt"</span></span><br><span class="line"><span class="keyword">if</span> content,<span class="keyword">err</span> := ioutil.ReadFile(filename); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="built_in">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、switch"><a href="#2、switch" class="headerlink" title="2、switch"></a>2、switch</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func eval(a <span class="built_in">int</span>, b <span class="built_in">int</span>, op <span class="built_in">string</span>) <span class="built_in">int</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> <span class="built_in">int</span></span><br><span class="line">switch op &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="literal">result</span> = a + b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="literal">result</span> = a - b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line"><span class="literal">result</span> = a * b</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line"><span class="literal">result</span> = a / b</span><br><span class="line">default:</span><br><span class="line">panic(<span class="string">"unsupported op"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上面的这段代码，你发现和别的语言不一样的地方是怎么没有break，是的，Go语言中switch会自动break，除非使用fallthrough</p><p>同时，Go语言的switch还有另外一种写法，结合一个最常见的Switch用法举个例子吧，比如通过考试分数判断是否合格</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Wrong score"</span>)</span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">80</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">70</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line"><span class="keyword">case</span> score &gt; <span class="number">60</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="string">"D"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的一个写法可以发现switch后面是可以没有表达式的</p><h3 id="1-5、循环"><a href="#1-5、循环" class="headerlink" title="1.5、循环"></a>1.5、循环</h3><h4 id="1、for"><a href="#1、for" class="headerlink" title="1、for"></a>1、for</h4><p>for关键字和其他语言有着共同的功能，同时还充当的Go语言中的 while 功能，Go语言中没有 while 关键字</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> scanner.<span class="title">Scan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的循环代码省略了起始条件，省略了递增条件，就跟while的功能非常的类似</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面其实就是一个死循环，因为Go语言中经常会用到，后面的并发编程 Goroutine 的时候还会给大家继续介绍。</p><h3 id="1-6、函数"><a href="#1-6、函数" class="headerlink" title="1.6、函数"></a>1.6、函数</h3><h4 id="1、普通函数"><a href="#1、普通函数" class="headerlink" title="1、普通函数"></a>1、普通函数</h4><p>普通的函数定义我这边不再过多阐述，跟变量定义类似，函数名在前，函数返回类型在后</p><h4 id="2、多返回值"><a href="#2、多返回值" class="headerlink" title="2、多返回值"></a>2、多返回值</h4><p>这个是Go语言的不一样的地方，函数可以有多个返回值，比如 ioutil.ReadFile 这个函数就是有两个返回值，但是呢多返回值不要滥用，尽量贴合Go语言的风格，常规返回值和一个error，那我门这边可以将上面的加减乘除的例子做一下改造，因为panic之后程序就会终止了，我们可以将错误信息直接返回出来，让程序继续执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line"><span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line"><span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line"><span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line"><span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"unsupported op"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、函数可作为参数"><a href="#3、函数可作为参数" class="headerlink" title="3、函数可作为参数"></a>3、函数可作为参数</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">apply</span>(<span class="params">op func(<span class="keyword">int</span>, <span class="keyword">int</span></span>) <span class="keyword">int</span>, a, b <span class="keyword">int</span>) <span class="keyword">int</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言定义这种函数在前，参数在后的复合函数非常的方便，只需要apply一个函数就可以了，当然在现实的过程中有时候也会了偷下懒，相关的op函数就直接写成一个匿名函数了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"sub(3, 4) is:"</span>, apply(</span><br><span class="line">func(<span class="selector-tag">a</span> int, <span class="selector-tag">b</span> int) int &#123;</span><br><span class="line">return <span class="selector-tag">a</span> - b</span><br><span class="line">&#125;, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>这样也是OK的</p><h4 id="4、没有默认参数、没有可选参数"><a href="#4、没有默认参数、没有可选参数" class="headerlink" title="4、没有默认参数、没有可选参数"></a>4、没有默认参数、没有可选参数</h4><p>Go语言中没有其他语言类似Lambda这种很花哨的用法，除了一个可变参数列表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">s := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">s += numbers[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个参数求和函数</p><h3 id="1-7、指针"><a href="#1-7、指针" class="headerlink" title="1.7、指针"></a>1.7、指针</h3><h4 id="1、指针不能运算"><a href="#1、指针不能运算" class="headerlink" title="1、指针不能运算"></a>1、指针不能运算</h4><p>比如想对指针做加1运算，Go语言是不支持的；当然要是想在函数内部改变函数外面的变量的值，通过指针是如何实现的呢，如下图所示<br><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15235210375685.jpg" alt=""></p><h4 id="2、Go语言只有值传递"><a href="#2、Go语言只有值传递" class="headerlink" title="2、Go语言只有值传递"></a>2、Go语言只有值传递</h4><p>Go语言中想要改变变量的值，只能传一个指针进去，比如常见 a b 两个变量的值交换</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func swap(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> int) &#123;</span><br><span class="line">    *<span class="selector-tag">a</span>, *<span class="selector-tag">b</span> = *<span class="selector-tag">b</span>, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然呢，交换参数值是不建议上面的写法的</p><h2 id="2-内建容器"><a href="#2-内建容器" class="headerlink" title="2. 内建容器"></a>2. 内建容器</h2><h3 id="2-0、数组"><a href="#2-0、数组" class="headerlink" title="2.0、数组"></a>2.0、数组</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 [5]int</span><br><span class="line">arr2 := [3]int&#123;1, 3, 5&#125;</span><br><span class="line">arr3 := [...]int&#123;2, 4, 6, 8, 10&#125;</span><br><span class="line">var grid [<span class="string">4</span>][<span class="symbol">5</span>]int</span><br></pre></td></tr></table></figure><p>数组的定义和变量的定义类似，数组名在前类型在后；<br>常规的遍历操作也是类似</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, v := range arr &#123;</span><br><span class="line">fmt.Println(<span class="selector-tag">i</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 是数组的下标，v是数组的值</p><h4 id="2、数组是值类型"><a href="#2、数组是值类型" class="headerlink" title="2、数组是值类型"></a>2、数组是值类型</h4><p>和上面值传递的概念类似，通过传参在函数内部是改变不了数组的值的;当然要是想改变相关的数组的值，可以通过指针来改变的。接下来的Slice可以直接解决上述的问题。</p><h3 id="2-1、Slice-切片-的概念"><a href="#2-1、Slice-切片-的概念" class="headerlink" title="2.1、Slice(切片)的概念"></a>2.1、Slice(切片)的概念</h3><h4 id="1、Slice定义"><a href="#1、Slice定义" class="headerlink" title="1、Slice定义"></a>1、Slice定义</h4><p>Slice是什么呢？其实呢就是数组的一个View（视图），先来段代码热个身</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="string">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"arr[2:6] ="</span>, arr<span class="string">[2:6]</span>)</span><br><span class="line">fmt.Println(<span class="string">"arr[:6] ="</span>, arr<span class="string">[:6]</span>)</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="string">[2:6]</span> = <span class="string">[2 3 4 5]</span></span><br><span class="line">arr<span class="string">[:6]</span> = <span class="string">[0 1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>从上面的输出结果可以直接的看出，arr加一个下标区间都叫做Slice，Slice的区间是一个左闭右开的区间<br>当然我们还需要知道一个概念，Slice是没有数据的，是对底层Array的一个View，如何理解这个概念呢？简单的用一个例子来理解它</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSliceData</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">s1 := arr[<span class="number">2</span>:]</span><br><span class="line">fmt.Println(<span class="string">"s1 ="</span>, s1)</span><br><span class="line">s2 := arr[:]</span><br><span class="line">fmt.Println(<span class="string">"s2 ="</span>, s2)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"更新Slice数据 s1"</span>)</span><br><span class="line">updateSliceData(s1)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"更新Slice数据 s2"</span>)</span><br><span class="line">updateSliceData(s2)</span><br><span class="line">fmt.Println(s2)</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">s2 = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">更新Slice数据 s1</span><br><span class="line">[<span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">更新Slice数据 s2</span><br><span class="line">[<span class="number">666</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">666</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure><h4 id="2、ReSlice"><a href="#2、ReSlice" class="headerlink" title="2、ReSlice"></a>2、ReSlice</h4><p>就是在一个Slice上进一步slice，比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">ss := arr[:6]</span><br><span class="line">ss = ss[:5]</span><br><span class="line">ss = ss[2:]</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="3、Slice拓展"><a href="#3、Slice拓展" class="headerlink" title="3、Slice拓展"></a>3、Slice拓展</h4><p>首先我们先看一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">s1 := arr[2:6]</span><br><span class="line">s2 := s1[3:5]</span><br></pre></td></tr></table></figure><p>大家或许会有疑问，这个s2不会报错么，要是不报错结果又是多少呢？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>答案是可以，上述就是s1、s2的值，是不是跟你想的有点不一样。那么这又是为什么呢？</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15235352570650.jpg" alt=""></p><p>这就是为什么能把 6 这个值取出来的原因，因为slice是array的底层的一个view，是不是依然还是有点懵，具体又是如何实现的呢？</p><h4 id="4、Slice实现"><a href="#4、Slice实现" class="headerlink" title="4、Slice实现"></a>4、Slice实现</h4><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15236013496891.jpg" alt=""></p><p>从上图是不是大体明白为什么上面那个例子能把6取出来了；看到这里大家也能大体明白Slice内部的ptr、len、cap是什么意思，ptr指向slice的开头的元素，len是slice的长度，cap代表底层的array从ptr开始到结束的长度，Slice是可以向后扩展的，但是不能向前扩展，所以只要不超过cap的长度slice都是可以扩展的，但是常规的s[i]取值是不可以超过len的。<br>用一个例子来简单的理解一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Printf(<span class="string">"len(s1): %d   ; cap(s1): %d "</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s1): <span class="number">4</span>   ; <span class="built_in">cap</span>(s1): <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="2-2、Slice-切片-的操作"><a href="#2-2、Slice-切片-的操作" class="headerlink" title="2.2、Slice(切片)的操作"></a>2.2、Slice(切片)的操作</h3><h4 id="1、向Slice添加元素"><a href="#1、向Slice添加元素" class="headerlink" title="1、向Slice添加元素"></a>1、向Slice添加元素</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">s3</span> := append(<span class="built_in">s2</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">s4</span> := append(<span class="built_in">s3</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">s5</span> := append(<span class="built_in">s4</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="string">"s3, s4, s5 ="</span>, <span class="built_in">s3</span>, <span class="built_in">s4</span>, <span class="built_in">s5</span>)</span><br><span class="line">fmt.Println(<span class="string">"arr ="</span>, arr)</span><br></pre></td></tr></table></figure><p>上面的这个例子打印出来结果又是多少呢？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3, s4, s5 = [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">arr = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure><p>上面的9 ，10为什么不见了呢？因为Go语言在append数据超过cap长度的时候会分配一个更长的数组，如果arr不再使用的话就会被垃圾回收掉。<br>在append的过程中，由于是值传递的关系，len、cap都有可能会改变，所以呢必须要用一个新的slice来接收这个slice，通常会写成</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = append(s, value1)</span><br></pre></td></tr></table></figure><h4 id="2、创建slice"><a href="#2、创建slice" class="headerlink" title="2、创建slice"></a>2、创建slice</h4><p>当然slice也可以直接通过var关键字创建</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>这样创建的slice的初始值就是nil，别的语言中的null的意思，当然也是可以赋初值的，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure><p>就上面的Zero Value的Slice的情况，要是我这个时候对这个slice进行append操作会怎么样呢？这个slice的内部的len以及cap又是如何变化的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%v, len = %d, cap = %d\n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果我就不输出了，因为相对太长，我把相应的结果总结一下，就是len就是一个步长为1由1增至100，cap呢？当系统发现不够存储的时候会分配一个现有长度两倍的空间。</p><p>当然在实际生产过程中，大多是使用的make关键字来创建slice的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">8</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure><h4 id="3、Copy-Slice数据"><a href="#3、Copy-Slice数据" class="headerlink" title="3、Copy Slice数据"></a>3、Copy Slice数据</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written int64, err error)</span></span></span><br></pre></td></tr></table></figure><p>文档中可以看的很清晰，直接将第二个参数直接拷贝进第一个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br><span class="line">fmt.Println(s2)</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h4 id="4、Slice删除元素"><a href="#4、Slice删除元素" class="headerlink" title="4、Slice删除元素"></a>4、Slice删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br></pre></td></tr></table></figure><p>比如我要删除 s2 中的第 3 个元素该如何操作呢？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">s2</span> = append(<span class="built_in">s2</span>[:<span class="number">2</span>], <span class="built_in">s2</span>[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure><p>当然现实的使用中还会从slice中pop一个值出来，下面分别演示一下从s2头部pop和从s2尾部pop数据</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front := s2[0]</span><br><span class="line">s2 = s2[1:]</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail := <span class="built_in">s2</span>[len(<span class="built_in">s2</span>)-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">s2</span> = <span class="built_in">s2</span>[:len(<span class="built_in">s2</span>)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="2-3、Map"><a href="#2-3、Map" class="headerlink" title="2.3、Map"></a>2.3、Map</h3><h4 id="1、创建map"><a href="#1、创建map" class="headerlink" title="1、创建map"></a>1、创建map</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>上述就是常见的创建map的方式，但是m1、m2还是有区别的，m1是nil，m2是一个空map;常规的遍历map也是用 range 的方式就可以，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然细心的会发现，在遍历的过程中是不能保证顺序的，当然要是想顺序遍历，需要自己手动对key进行排序，可以将key存进slice，然后再通过slice遍历相关的key获取map的值。</p><h4 id="2、获取map元素"><a href="#2、获取map元素" class="headerlink" title="2、获取map元素"></a>2、获取map元素</h4><p>m[key] 一般就是这样获取map的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"name"</span> : <span class="string">"shengguocun"</span>,</span><br><span class="line"><span class="string">"gender"</span> : <span class="string">"male"</span>,</span><br><span class="line"><span class="string">"city"</span> : <span class="string">"hangzhou"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value1 := map1[<span class="string">"age"</span>]</span><br><span class="line">fmt.Println(value1)</span><br></pre></td></tr></table></figure><p>先来猜测一下，上述这段代码可以运行么？会不会报错？</p><p>答案是不会，这就是Go语言和别的语言不一样的地方，上述的例子中 value1 的值是一个空字符串，map中当key不存在时，会获取value类型的初始值。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gender, ok := map1[<span class="string">"gender"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Gender 的值为 : "</span>, gender)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Key 不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然Go语言的出现就是为了解决别的语言的痛点，所以在使用过程中不再需要每次获取某个 key 的时候都要去 isset 判断一下，Go的获取map的值的时候第二个返回值就是别的语言 isset 的功能；存在返回 true ，不存在返回 false。</p><h4 id="3、删除元素"><a href="#3、删除元素" class="headerlink" title="3、删除元素"></a>3、删除元素</h4><p>delete函数，就可以直接删除指定的key的值</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15238684220308.jpg" alt=""></p><p>这是Go语言的官方文档，不难理解比如要删除上面的 map1 的 city 的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delete</span><span class="params">(map1, <span class="string">"city"</span>)</span></span></span><br></pre></td></tr></table></figure><p>直接调用就可以</p><h4 id="4、map的key"><a href="#4、map的key" class="headerlink" title="4、map的key"></a>4、map的key</h4><p>为什么要把key单独拿出来说呢？因为map底层使用的是hash表，所以map的key必须可以比较相等；换句话说就是除了 slice、map、function的内建类型都可以作为key。</p><h3 id="2-4、字符和字符串处理"><a href="#2-4、字符和字符串处理" class="headerlink" title="2.4、字符和字符串处理"></a>2.4、字符和字符串处理</h3><h4 id="1、rune介绍"><a href="#1、rune介绍" class="headerlink" title="1、rune介绍"></a>1、rune介绍</h4><p>rune就是Go语言的字符串类型，其实可以理解为是 int32 的一个別名，下面我们通过例子来深入理解一下rune</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"你好,杭州"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">byte</span>(s1) &#123;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%X "</span>, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s1 &#123;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"(%d %X) "</span>, i, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你好,杭州</span><br><span class="line">E4 BD A0 E5 A5 BD <span class="number">2</span>C E6 <span class="number">9</span>D AD E5 B7 <span class="number">9</span>E</span><br><span class="line">(<span class="number">0</span> <span class="number">4</span>F60) (<span class="number">3</span> <span class="number">597</span>D) (<span class="number">6</span> <span class="number">2</span>C) (<span class="number">7</span> <span class="number">676</span>D) (<span class="number">10</span> <span class="number">5</span>DDE)</span><br></pre></td></tr></table></figure><p>从上述的例子我们可以直接的看出来，其实就是将UTF-8编码解码，然后再转成Unicode之后将它存放进一个rune（int32）中</p><h4 id="2、字符串处理"><a href="#2、字符串处理" class="headerlink" title="2、字符串处理"></a>2、字符串处理</h4><p>UTF-8编码的rune长度统计</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">count</span> := utf8.RuneCountInString(s1)</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Rune Count :"</span>, <span class="keyword">count</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rune Count : 5</span><br></pre></td></tr></table></figure><p>字符串的输出操作</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bytes </span>:= []<span class="keyword">byte(s1)</span></span><br><span class="line"><span class="keyword">for </span>len(<span class="keyword">bytes) </span>&gt; <span class="number">0</span> &#123;</span><br><span class="line">ch, size := utf8.DecodeRune(<span class="keyword">bytes)</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bytes </span>= <span class="keyword">bytes[size:]</span></span><br><span class="line"><span class="keyword"></span>fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用rune实现上述同样的功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s1) &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-面向“对象”"><a href="#3-面向“对象”" class="headerlink" title="3. 面向“对象”"></a>3. 面向“对象”</h2><h3 id="3-0、结构体和方法"><a href="#3-0、结构体和方法" class="headerlink" title="3.0、结构体和方法"></a>3.0、结构体和方法</h3><h4 id="1、结构体的创建"><a href="#1、结构体的创建" class="headerlink" title="1、结构体的创建"></a>1、结构体的创建</h4><p>go语言仅支持封装，不支持继承和多态；这句话怎么理解呢？就是说在Go语言内部没有class，只有struct；也没有复杂的继承和多态，那继承和多态的任务又是通过什么实现的呢？Go是面向接口编程，可以通过接口来实现继承和多态的相关的任务，后面我会再进行介绍。<br>下面先来介绍一下struct的创建：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Node</span> <span class="title">struct</span> &#123;</span><br><span class="line">Value       int</span><br><span class="line">Left, Right *<span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><p>通过type、struct关键字创建结构体类型，当然在创建了结构体类型之后，就可以创建相关类型的变量</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> root tree.Node</span><br><span class="line">root = tree.Node&#123;Value:<span class="number">1</span>&#125;</span><br><span class="line">root<span class="selector-class">.Value</span> = <span class="number">2</span></span><br><span class="line">root<span class="selector-class">.Left</span> = &amp;tree.Node&#123;Value:<span class="number">3</span>&#125;</span><br><span class="line">root<span class="selector-class">.Right</span> = &amp;tree.Node&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="2、方法创建"><a href="#2、方法创建" class="headerlink" title="2、方法创建"></a>2、方法创建</h4><p>结构体的方法的创建和普通的函数创建没有太大的区别，只是在方法名前面添加一个接收者，就相当于其他语言的this</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">Node</span>) Print() &#123;</span><br><span class="line">fmt.Print(<span class="keyword">node</span>.<span class="title">Value</span>, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是一个值接收者打印出Node的Value的值的方法。<br>当然要是需要改变Value的值的时候，就需要一个指针接收者。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">*Node</span>) SetValue(value int) &#123;</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Value</span> = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个疑问，要是对一个值为nil的Node进行 SetValue 操作会发生什么？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> pRoot *tree.Node</span><br><span class="line">pRoot.SetValue(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>虽说nil指针可以调用方法，但是下面的Value是拿不到，自然就会报下面的错了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory<span class="built_in"> address </span><span class="keyword">or</span> <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation <span class="attribute">code</span>=0x1 <span class="attribute">addr</span>=0x0 <span class="attribute">pc</span>=0x20c3]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">panic(0x8f100, 0xc42000a070)</span><br></pre></td></tr></table></figure><p>实际使用过程中可以添加相关的判断在做处理。结合上面的知识我们不难写出一个树的遍历的方法的代码</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">*Node</span>) Traverse()  &#123;</span><br><span class="line"></span><br><span class="line">if <span class="keyword">node</span> <span class="title">== nil</span> &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Print</span>()</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Left</span>.Traverse()</span><br><span class="line"><span class="keyword">node</span>.<span class="title">Right</span>.Traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1、包和封装"><a href="#3-1、包和封装" class="headerlink" title="3.1、包和封装"></a>3.1、包和封装</h3><h4 id="1、命名规范"><a href="#1、命名规范" class="headerlink" title="1、命名规范"></a>1、命名规范</h4><ul><li>名字一般使用 CamelCase（驼峰式）</li><li>首字母大写：Public</li><li>首字母小写：Private</li></ul><h4 id="2、包的概念"><a href="#2、包的概念" class="headerlink" title="2、包的概念"></a>2、包的概念</h4><ul><li>每个目录一个包，但是包名和目录名不一定要一样的，但是每个目录只能包含一个包；</li><li>main包是一个相对特殊的，main包包含一个可执行入口；</li><li>为结构体定义的方法必须放在同一个包内</li></ul><p>当然上面的例子已经在不经意间提前引入了package的概念</p><h3 id="3-2、扩展已有类型"><a href="#3-2、扩展已有类型" class="headerlink" title="3.2、扩展已有类型"></a>3.2、扩展已有类型</h3><p>在面向对象中，我们想要扩展一下别人的类，我们通常继承一下就好了，但是Go语言中没有继承的概念，我们该如何处理呢？</p><h4 id="1、定义别名（1-9新特性）"><a href="#1、定义别名（1-9新特性）" class="headerlink" title="1、定义别名（1.9新特性）"></a>1、定义别名（1.9新特性）</h4><p>在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型</p><p>基本语法就是：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">identifier </span>= <span class="keyword">Type</span></span><br></pre></td></tr></table></figure><p>比如内建的byte类型，其实是uint8的类型别名，而rune其实是int32的类型别名。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// byte <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> uint8 <span class="keyword">and</span> <span class="keyword">is</span> equivalent <span class="keyword">to</span> uint8 <span class="keyword">in</span> <span class="keyword">all</span> ways. It <span class="keyword">is</span></span><br><span class="line">// used, by convention, <span class="keyword">to</span> distinguish byte values from <span class="number">8</span>-<span class="built_in">bit</span> <span class="built_in">unsigned</span></span><br><span class="line">// <span class="built_in">integer</span> values.</span><br><span class="line"><span class="keyword">type</span> byte = uint8</span><br><span class="line"></span><br><span class="line">// rune <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> int32 <span class="keyword">and</span> <span class="keyword">is</span> equivalent <span class="keyword">to</span> int32 <span class="keyword">in</span> <span class="keyword">all</span> ways. It <span class="keyword">is</span></span><br><span class="line">// used, by convention, <span class="keyword">to</span> distinguish <span class="built_in">character</span> values from <span class="built_in">integer</span> values.</span><br><span class="line"><span class="keyword">type</span> rune = int32</span><br></pre></td></tr></table></figure><p>通过别名的方式就可以拓展了，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> T3 = T1</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t1 T1)</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t3 *T3)</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> t1 T1</span><br><span class="line"><span class="comment">// var t2 T2</span></span><br><span class="line"><span class="keyword">var</span> t3 T3</span><br><span class="line">t1.say()</span><br><span class="line">t1.greeting()</span><br><span class="line">t3.say()</span><br><span class="line">t3.greeting()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然要是T1也定义了 greeting 的方法，那么编译会报错的，因为有重复的方法定义。</p><h4 id="2、使用组合"><a href="#2、使用组合" class="headerlink" title="2、使用组合"></a>2、使用组合</h4><p>比如我们想扩展上面的树的包，实现一个自己的中序遍历，该如何实现呢？通过代码来理解一下使用组合的概念</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type myNode <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">node *tree.<span class="type">Node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNodeNode *myNode)</span></span> <span class="type">Traverse</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> myNodeNode == <span class="literal">nil</span> || myNodeNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">left</span> := myNode&#123;myNodeNode.node.<span class="type">Left</span>&#125;</span><br><span class="line"><span class="keyword">right</span> := myNode&#123;myNodeNode.node.<span class="type">Right</span>&#125;</span><br><span class="line"><span class="keyword">left</span>.ownFunc()</span><br><span class="line">myNodeNode.node.<span class="type">Print</span>()</span><br><span class="line"><span class="keyword">right</span>.ownFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、GOPATH以及目录结构"><a href="#3-3、GOPATH以及目录结构" class="headerlink" title="3.3、GOPATH以及目录结构"></a>3.3、GOPATH以及目录结构</h3><ul><li>默认在 ～／go 目录下（unix或者Linux环境），%USERPROFILE%\go 目录下（windows环境）</li><li>官方推荐：所有的项目和第三方库都放在同一个GOPATH下</li><li>当然也可以将每个项目放在不同的GOPATH下</li></ul><p>如何查看自己的GOPATH呢？</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ sheng$ echo <span class="variable">$GOPATH</span></span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject</span></span><br></pre></td></tr></table></figure><h4 id="1、go-get获取第三方库"><a href="#1、go-get获取第三方库" class="headerlink" title="1、go get获取第三方库"></a>1、go get获取第三方库</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> url</span><br></pre></td></tr></table></figure><p>这样是可以获取GitHub上面的三方的库，但是Golang.org上面要是不能翻墙是获取不了的，这里我给大家介绍一个新的工具 <strong>gopm</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheng$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gpmgo/gopm</span><br></pre></td></tr></table></figure><p>一行命令就可以装好了，这个时候再get三方的库就毫无压力了，因为这个国内有相关的镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopm <span class="builtin-name">get</span> -g url</span><br></pre></td></tr></table></figure><p>采用-g 参数，可以把依赖包下载到GOPATH目录中</p><h4 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h4><ul><li>src<ul><li>git repo 1</li><li>git repo 2</li></ul></li><li>pkg<ul><li>git repo 1</li><li>git repo 2</li></ul></li><li>bin<ul><li>执行文件 1 2</li></ul></li></ul><p>从上述的目录结构上我们可以看出来，src pkg 是对应的，src 是我们的代码的位置以及三方库的位置，pkg 是build的中间过程，可以暂时先不用关注，bin下面就是可执行文件。</p><h2 id="4-面向接口"><a href="#4-面向接口" class="headerlink" title="4. 面向接口"></a>4. 面向接口</h2><h3 id="4-0、Duck-Typing的概念"><a href="#4-0、Duck-Typing的概念" class="headerlink" title="4.0、Duck Typing的概念"></a>4.0、Duck Typing的概念</h3><p>很多语言都有duck typing的概念， 用一个简单的例子来描述一下这个概念</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15240576798805.jpg" alt=""></p><p>大黄鸭是鸭子么？这个答案是要看基于什么角度来看，从生物角度来看，那它当然不是鸭子，连基本的生命都没有；但是从duck typing的角度来看它就是一个鸭子，因为它外部长得像鸭子，通俗点概括一下duck typing的概念就是：描述事物的外部行为而非内部结构。</p><p>从严格意义上讲，go语言只能说是类似duck typing，go语言不是动态绑定的，go语言是编译时绑定的。</p><h3 id="4-1、接口的定义和实现"><a href="#4-1、接口的定义和实现" class="headerlink" title="4.1、接口的定义和实现"></a>4.1、接口的定义和实现</h3><p>在Go语言中，接口interface其实和其他语言的接口意思也没什么区别。一个结构体必须实现了一个接口的所有方法，才能被一个接口对象接受，这一点和Java语言中的接口的要求是一样的。interface理解其为一种类型的规范或者约定。</p><h4 id="1、接口的定义"><a href="#1、接口的定义" class="headerlink" title="1、接口的定义"></a>1、接口的定义</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span>&#123;</span><br><span class="line">    Get(url <span class="built_in">string</span>) <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就定义了一个接口，它包含一个Get函数。</p><h4 id="2、接口的实现"><a href="#2、接口的实现" class="headerlink" title="2、接口的实现"></a>2、接口的实现</h4><p>现在我们就来实现一下这个接口。比如我们做一个拉取某个页面的操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rick</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"shengguocun.com/retriever/rick"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span>&#123;</span><br><span class="line">Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Get(<span class="string">"http://www.shengguocun.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r Retriever</span><br><span class="line">r = rick.Retriever&#123;&#125;</span><br><span class="line">fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述rick.Retriever就实现了Retriever接口。</p><h3 id="4-2、接口值的类型"><a href="#4-2、接口值的类型" class="headerlink" title="4.2、接口值的类型"></a>4.2、接口值的类型</h3><h4 id="1、接口变量里面有什么"><a href="#1、接口变量里面有什么" class="headerlink" title="1、接口变量里面有什么"></a>1、接口变量里面有什么</h4><p>继续使用上面的例子</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r Retriever</span><br><span class="line">r = rick.Retriever&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"<span class="subst">\n</span> %T %v <span class="subst">\n</span>"</span>, r, r)</span><br></pre></td></tr></table></figure><p>会输出什么呢？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rick</span><span class="selector-class">.Retriever</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这就是常规的值传递，没有什么特别的地方。要是 Retriever 这个struct很大，我们不希望通过传值的方法去拷贝，而是通过指针访问Get方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r Retriever</span><br><span class="line">r = &amp;rick.Retriever&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"<span class="subst">\n</span> %T %v <span class="subst">\n</span>"</span>, r, r)</span><br></pre></td></tr></table></figure><p>这时候的Type、Value又是什么？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-tag">rick</span><span class="selector-class">.Retriever</span> &amp;&#123;&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到是一个指针，所以我们一般用到接口的指针，因为它的肚子里含有一个指针，通常我们会说“<strong>接口变量自带指针</strong>”，那我们现在用两个图来总结一下上面的概念</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15244909642810.jpg" alt=""></p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15244910308713.jpg" alt=""></p><p>概括为：接口变量里面可以是实现者的类型和实现者的值，或者是接口类型里面可以是实现者的类型和实现者的指针，同时指向实现者。</p><h4 id="2、查看接口变量"><a href="#2、查看接口变量" class="headerlink" title="2、查看接口变量"></a>2、查看接口变量</h4><p>说到这里要提到一个特殊的接口，空接口 interface{} ，对于空接口 interface{} 其实和泛型的概念很像，任何类型都实现了空接口。在方法需要返回多个类型的时候，返回值的类型我们一般定义为 interface{} 。</p><p>这时我们现在引入获取接口变量肚子里的类型的另外一种写法，叫 Type Assertion（断言）。比如</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> interface&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"Are you ok?"</span>, <span class="selector-tag">a</span>.(string))</span><br></pre></td></tr></table></figure><p>然而上述的写法一旦断言失败，会报出panic错误，当然这样的程序就显得十分的不友好。我们需要在断言前进行一个判断。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">value</span>, ok := a.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"断言失败，这不是一个string类型"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"值为："</span>, <span class="keyword">value</span>)</span><br></pre></td></tr></table></figure><p>另外我们可以结合switch进行类型判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r = balabalaFunction()</span><br><span class="line"><span class="keyword">switch</span> v := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Println(<span class="string">"type bool..."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">"type int..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips:转换类型的时候如果是string可以不用断言，使用fmt.Sprint()函数可以达到想要的效果。</p><h3 id="4-3、接口的组合"><a href="#4-3、接口的组合" class="headerlink" title="4.3、接口的组合"></a>4.3、接口的组合</h3><h4 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h4><p>什么叫接口的组合？当然这就是它的字面上的意思，接口可以组合其他的接口。这种方式等效于在接口中添加其他的接口的方法。在系统函数中就有很多这样的组合，比如：ReadWriter</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ReadWriter <span class="keyword">is</span> the <span class="keyword">interface</span> that groups the basic Read <span class="keyword">and</span> Write methods.</span><br><span class="line"><span class="keyword">type</span> <span class="type">ReadWriter </span><span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在常见的读写文件的时候，网络相关以及一些底层的东西经常会遇到 Reader 、Writer</p><h4 id="2、实例演示"><a href="#2、实例演示" class="headerlink" title="2、实例演示"></a>2、实例演示</h4><p>为了更好的理解接口的组合的概念，下面用一个简单的例子来进一步了解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Reader接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">read()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Writer接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">write()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现上述两个接口</span></span><br><span class="line"><span class="keyword">type</span> myReaderWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw *myReaderWriter)</span> <span class="title">read</span><span class="params">()</span></span>  &#123;</span><br><span class="line">fmt.Println(<span class="string">"myReaderWriter read func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw *myReaderWriter)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"myReadWriter writer func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个接口，组合上述两个接口</span></span><br><span class="line"><span class="keyword">type</span> ReaderWriterV1 <span class="keyword">interface</span> &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> ReaderWriterV2 <span class="keyword">interface</span> &#123;</span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mrw := &amp;myReaderWriter&#123;&#125;</span><br><span class="line"><span class="comment">//mrw对象实现了read()方法和write()方法，因此可以赋值给ReaderWriterV1和ReaderWriterV2</span></span><br><span class="line"><span class="keyword">var</span> rwv1 ReaderWriterV1 = mrw</span><br><span class="line">rwv1.read()</span><br><span class="line">rwv1.write()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rwv2 ReaderWriterV2 = mrw</span><br><span class="line">rwv2.write()</span><br><span class="line">rwv2.read()</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时，ReaderWriterV1和ReaderWriterV2两个接口对象可以相互赋值</span></span><br><span class="line">rwv1 = rwv2</span><br><span class="line">rwv2 = rwv1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、常用的系统接口"><a href="#4-4、常用的系统接口" class="headerlink" title="4.4、常用的系统接口"></a>4.4、常用的系统接口</h3><h4 id="1、Stringer"><a href="#1、Stringer" class="headerlink" title="1、Stringer"></a>1、Stringer</h4><p>这个就是常见的 toString 的功能，</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Stringer <span class="keyword">is</span> implemented by any value that <span class="built_in">has</span> <span class="keyword">a</span> String method,</span><br><span class="line">// which defines the ``native<span class="string">''</span> format <span class="keyword">for</span> that value.</span><br><span class="line">// The String method <span class="keyword">is</span> used <span class="keyword">to</span> <span class="keyword">print</span> <span class="built_in">values</span> passed <span class="keyword">as</span> <span class="keyword">an</span> operand</span><br><span class="line">// <span class="keyword">to</span> any format that accepts <span class="keyword">a</span> <span class="built_in">string</span> <span class="built_in">or</span> <span class="keyword">to</span> <span class="keyword">an</span> unformatted printer</span><br><span class="line">// such <span class="keyword">as</span> <span class="keyword">Print</span>.</span><br><span class="line"><span class="built_in">type</span> Stringer interface &#123;</span><br><span class="line">String() <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stringer接口定义在fmt包中，该接口包含String()函数。任何类型只要定义了String()函数，进行Print输出时，就可以得到定制输出。比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">age <span class="keyword">int</span></span><br><span class="line">gender <span class="keyword">string</span></span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"age:%d, gender:%s, name:%s"</span>, p.age, p.gender, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i Person = Person&#123;</span><br><span class="line">age: <span class="number">25</span>,</span><br><span class="line">gender: <span class="string">"male"</span>,</span><br><span class="line">name: <span class="string">"sheng.guocun"</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%s\n"</span>, i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br></pre></td></tr></table></figure><h4 id="2、Reader、Writer"><a href="#2、Reader、Writer" class="headerlink" title="2、Reader、Writer"></a>2、Reader、Writer</h4><p>Reader Writer 上面有提到过，就是常见的读写文件的时候经常会用到，就是对文件的一个抽象，但是不仅这些，比如常见的</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewScanner returns a new Scanner to read from r.</span></span><br><span class="line"><span class="comment">// The split function defaults to ScanLines.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span></span> *<span class="type">Scanner</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;<span class="type">Scanner</span>&#123;</span><br><span class="line">r:            r,</span><br><span class="line"><span class="built_in">split</span>:        <span class="type">ScanLines</span>,</span><br><span class="line">maxTokenSize: <span class="type">MaxScanTokenSize</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这的参数也是一个Reader，还有很多的底层的代码都是基于 Reader Writer 的，这里就不一一举例了。</p><h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><h3 id="5-0、函数式编程"><a href="#5-0、函数式编程" class="headerlink" title="5.0、函数式编程"></a>5.0、函数式编程</h3><p>Go语言作为一个通用型语言，它对函数式编程主要体现在闭包上面。</p><h4 id="1、函数式编程-VS-函数指针"><a href="#1、函数式编程-VS-函数指针" class="headerlink" title="1、函数式编程 VS 函数指针"></a>1、函数式编程 VS 函数指针</h4><ul><li><p>函数是一等公民：参数、变量、返回值都可以是函数，在别的语言中大多不是这样的，比如在C++里面只有函数指针，在Java里面我们只能调用，不能把函数传给别人。</p></li><li><p>高阶函数：参数可以是函数，1.6.3里面的apply函数就是一个高阶函数。</p></li><li><p>函数 –&gt; 闭包：首先用个例子来了解一下闭包的用法</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum += v</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++  &#123;</span><br><span class="line">fmt.Printf(<span class="string">"0 + 1 + 2 + ... + %d = %d\n"</span>, i, a(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">6</span> = <span class="number">21</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">8</span> = <span class="number">36</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">9</span> = <span class="number">45</span></span><br></pre></td></tr></table></figure><p>上述的 v 就称为局部变量， sum 称为自由变量，<code>func(v int) int {        sum += v        return sum    }</code> 称为函数体，整个就叫做一个闭包。用一张图来概括就是：</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15245726261451.jpg" alt=""></p><h4 id="2、“正统”函数式编程"><a href="#2、“正统”函数式编程" class="headerlink" title="2、“正统”函数式编程"></a>2、“正统”函数式编程</h4><ul><li><p>不可变性：不能有状态，只有常量和函数；当然这和平常的函数不一样，连变量都没有，甚至连选择语句、循环语句都没有。</p></li><li><p>函数只能有一个参数</p></li></ul><p>要是上面的累加想做一个稍微正统函数怎么做呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iAdder <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">adderV2</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">iAdder</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> base + v, adderV2(base + v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := adderV2(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">int</span></span><br><span class="line">s, a = a(i)</span><br><span class="line">fmt.Printf(<span class="string">"0 + 1 + 2 + ... + %d = %d\n"</span>, i, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然正统的不一定是最好的，正统式的写法经常导致代码的可读性变得不是很好。</p><h3 id="5-1、函数式编程实例演示"><a href="#5-1、函数式编程实例演示" class="headerlink" title="5.1、函数式编程实例演示"></a>5.1、函数式编程实例演示</h3><h4 id="1、斐波那契数列"><a href="#1、斐波那契数列" class="headerlink" title="1、斐波那契数列"></a>1、斐波那契数列</h4><p>Go语言的官方案列中，对闭包的讲解通过一个常见的例子：斐波那契数列，为了更好的理解闭包的感念，那这里我们就将这个例子再来演示一遍</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Fibonacci() func() int &#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">return func() int &#123;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = <span class="selector-tag">b</span>, a+b</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们要打印这一串斐波那契数列，我们就需要不停的调用上面的斐波那契数列的生成器。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f := Fibonacci()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 3</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 5</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">()</span></span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h4 id="2、为函数实现接口"><a href="#2、为函数实现接口" class="headerlink" title="2、为函数实现接口"></a>2、为函数实现接口</h4><p>这个斐波那契数列的调用的生成器跟文件有点像，我们可以把它包装成一个 <code>io.Reader</code> 这样就跟打印一个文件一样生成这个斐波那契数列。</p><p>首先我们先定义我们的类型 <code>func() int</code> ，就取名Generate好了</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Generate <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>同时需要将 <code>Fibonacci()</code> 函数的类型改掉</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Fibonacci() Generate &#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">return func() int &#123;</span><br><span class="line"><span class="selector-tag">a</span>, <span class="selector-tag">b</span> = <span class="selector-tag">b</span>, a+b</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个类型就可以实现接口，这就是Go语言灵活的地方，下一步我们实现这个Reader接口</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> (<span class="selector-tag">gen</span> <span class="selector-tag">Generate</span>) <span class="selector-tag">Read</span>(<span class="selector-tag">p</span> <span class="selector-attr">[]</span><span class="selector-tag">byte</span>) (<span class="selector-tag">n</span> <span class="selector-tag">int</span>, <span class="selector-tag">err</span> <span class="selector-tag">error</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">nextNum </span>:= <span class="built_in">gen</span>()</span><br><span class="line">numString := fmt.<span class="built_in">Sprintf</span>(<span class="string">"%d \n"</span>, nextNum)</span><br><span class="line"></span><br><span class="line">return strings.<span class="built_in">NewReader</span>(numString).<span class="built_in">Read</span>(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们会发现函数也可以实现接口，这就是Go语言的不一样的地方，因为函数是一等公民，它既可以作为参数，也可以作为接收者。首先我们要先取到下一个元素 <code>nextNum</code> ,然后将下一个元素写进 <em>p</em> 。然后我们直接用一个写好的文件打印的函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">printFileContents</span>(<span class="selector-tag">reader</span> <span class="selector-tag">io</span><span class="selector-class">.Reader</span>) &#123;</span><br><span class="line"><span class="attribute">scanner </span>:= bufio.<span class="built_in">NewScanner</span>(reader)</span><br><span class="line"></span><br><span class="line">for scanner.<span class="built_in">Scan</span>() &#123;</span><br><span class="line">fmt.<span class="built_in">Println</span>(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们就可以直接调用了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">main</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="attribute">f </span>:= <span class="built_in">Fibonacci</span>()</span><br><span class="line"><span class="built_in">printFileContents</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上述的代码是存在瑕疵的，比如这个 <code>printFileContents</code> 函数会一直读下去，就变成一个死循环了，我们需要设置其终止条件。比如上面的 <em>p</em> 太小的话，只读了一半，当然这边就留给读者后期拓展了。</p><h2 id="6-错误处理和资源管理"><a href="#6-错误处理和资源管理" class="headerlink" title="6. 错误处理和资源管理"></a>6. 错误处理和资源管理</h2><p>我们实际的代码不止 <code>Hello World</code> ,我们的代码是要运行在服务器上的，要和各种各样的用户进行交互，所以我们这里就要了解一下Go语言的资源管理和出错处理。</p><h3 id="6-0、defer调用"><a href="#6-0、defer调用" class="headerlink" title="6.0、defer调用"></a>6.0、defer调用</h3><h4 id="1、确保在函数结束时调用"><a href="#1、确保在函数结束时调用" class="headerlink" title="1、确保在函数结束时调用"></a>1、确保在函数结束时调用</h4><p>比如一个常见的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我要是想要让1在2后面输出该如何做呢？你说调换一下顺序呗，道理我都懂，但是我们今天要介绍的不是这个，我们只需要在打印1之前加一个 <em>defer</em> 就可以了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line">fmt.Println(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要是有多个defer呢？它的输出顺序又是什么样的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，输出的结果又是什么？</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这里我们可以发现 <em>defer</em> 的调用实际是一个栈，先进后出。当然 <em>defer</em> 的最大的好处是什么呢？就是当程序中间有return返回甚至panic的时候，依然不影响 defer 后面的代码的执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"whoops, something went wrong...."</span>)</span><br><span class="line">fmt.Println(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码在panic之后，1 2 依然能够正常输出。</p><h4 id="2、场景演示"><a href="#2、场景演示" class="headerlink" title="2、场景演示"></a>2、场景演示</h4><p>当然说了这么多，我们在代码中常见的使用defer的场景有哪些呢？比如我们创建文件，写文件这些，过去我们用别的语言经常会在处理文件的最后释放句柄，因为中间隔了很多的文件操作，经常可能会忘记释放句柄。那Go语言就针对这样的场景做了非常好的优化，通过defer关键字实现，下面我们就通过一个简单的写文件事例来演示一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">filename := <span class="string">"demo.txt"</span></span><br><span class="line">file, err := os.Create(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">defer</span> writer.Flush()</span><br><span class="line"></span><br><span class="line">fmt.Fprintln(writer, <span class="string">"你好，杭州"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15248139076584.jpg" alt=""></p><p>一个完整的事例就演示到这边，比如常见的 Open／Close、Lock／Unlock这些成对出现的都可以使用 <em>defer</em></p><h3 id="6-1、错误处理概念"><a href="#6-1、错误处理概念" class="headerlink" title="6.1、错误处理概念"></a>6.1、错误处理概念</h3><p>因为在我们实际的程序中，有错直接panic中断程序执行，这时非常不友好的，通常我们会对其出错处理。比如上面的事例中 <code>os.Create</code> 函数返回的 <code>err</code> 不为 <code>nil</code> 的时候，我们需要做一个出错处理，</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename := <span class="string">"demo.txt"</span></span><br><span class="line"><span class="keyword">file</span>, <span class="keyword">err</span> := os.Create(filename)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">fmt.Println(<span class="keyword">err</span>.<span class="keyword">Error</span>())</span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以直接打印出相关的错误信息，然后直接返回。这就是常见的错误处理方式之一，当然在函数内部也可以将错误信息直接作为结果返回。</p><h3 id="6-2、panic和recover"><a href="#6-2、panic和recover" class="headerlink" title="6.2、panic和recover"></a>6.2、panic和recover</h3><h4 id="1、panic"><a href="#1、panic" class="headerlink" title="1、panic"></a>1、panic</h4><ul><li>停止当前函数执行</li></ul><p>panic和我们其他语言的throw exception很像</p><ul><li>一直向上返回，执行每一层的defer</li></ul><p>当然相对还是友好的，每层的defer还是会用到，一层一层的返回，返回到最后程序就会自动退出了</p><ul><li>如果没有遇见recover，程序退出</li></ul><h4 id="2、recover"><a href="#2、recover" class="headerlink" title="2、recover"></a>2、recover</h4><ul><li><p>仅在defer调用中使用</p></li><li><p>获取panic的值</p></li><li><p>如果无法处理，可充新panic</p></li></ul><p>主要的特性就可以用上述几句话概括，为了更好的理解上述的概念，下面用一个简短的代码来学以致用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryDefer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"就打印到这吧"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个 panic 和 defer 的结合使用，他的输出结果会是什么样的呢？</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="string">panic:</span> 就打印到这吧</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.tryDefer()</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>web/web.<span class="string">go:</span><span class="number">11</span> +<span class="number">0x11d</span></span><br><span class="line">main.main()</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>web/web.<span class="string">go:</span><span class="number">18</span> +<span class="number">0x20</span></span><br></pre></td></tr></table></figure><p>从上述输出结果我们可以看到panic的前两个特性，那结合recover又会是什么样的呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// The recover built-in function allows a program to manage behavior of a</span><br><span class="line">// panicking goroutine. Executing a <span class="keyword">call</span> <span class="keyword">to</span> <span class="keyword">recover</span> inside a <span class="keyword">deferred</span></span><br><span class="line">// <span class="keyword">function</span> (but <span class="keyword">not</span> <span class="keyword">any</span> <span class="keyword">function</span> called <span class="keyword">by</span> it) stops the panicking <span class="keyword">sequence</span></span><br><span class="line">// <span class="keyword">by</span> restoring <span class="keyword">normal</span> execution <span class="keyword">and</span> retrieves the <span class="keyword">error</span> <span class="keyword">value</span> passed <span class="keyword">to</span> the</span><br><span class="line">// <span class="keyword">call</span> <span class="keyword">of</span> panic. <span class="keyword">If</span> <span class="keyword">recover</span> <span class="keyword">is</span> called outside the <span class="keyword">deferred</span> <span class="keyword">function</span> it will</span><br><span class="line">// <span class="keyword">not</span> <span class="keyword">stop</span> a panicking sequence. <span class="keyword">In</span> this <span class="keyword">case</span>, <span class="keyword">or</span> <span class="keyword">when</span> the goroutine <span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line">// panicking, <span class="keyword">or</span> <span class="keyword">if</span> the argument supplied <span class="keyword">to</span> panic was nil, <span class="keyword">recover</span> <span class="keyword">returns</span></span><br><span class="line">// nil. Thus the <span class="keyword">return</span> <span class="keyword">value</span> <span class="keyword">from</span> <span class="keyword">recover</span> reports whether the goroutine <span class="keyword">is</span></span><br><span class="line">// panicking.</span><br><span class="line">func <span class="keyword">recover</span>() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"错误信息: "</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(errors.New(<span class="string">"这是一个 error"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面我们可以看到 recover 是一个interface， 所以在判断的时候需要判断 r 是否是一个 error，结果自然会是输出</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息:  这是一个 <span class="keyword">error</span></span><br></pre></td></tr></table></figure><p>那我们再用一个实际一点的例子来测试一下，比如除数为0的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tryRecover</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> err, ok := r.(error); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">"错误信息: "</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">b := <span class="number">0</span></span><br><span class="line">a := <span class="number">5</span> / b</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息:  runtime error: <span class="keyword">integer</span> <span class="built_in">divide</span> <span class="keyword">by</span> <span class="literal">zero</span></span><br></pre></td></tr></table></figure><p>上面的两个例子简单介绍了panic、recover的基本使用，下面通过一个稍微实际一点的例子来综合讲述一下一般的项目中是如何统一处理错误的。</p><h3 id="6-3、服务器统一出错处理"><a href="#6-3、服务器统一出错处理" class="headerlink" title="6.3、服务器统一出错处理"></a>6.3、服务器统一出错处理</h3><p>现在呢我们就通过一个Http服务来展开如何统一处理服务器出错这件事，结合一个实际读取目录内文件的例子来简单介绍一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">"/list/"</span>,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">path := request.URL.Path[<span class="built_in">len</span>(<span class="string">"/list/"</span>):]</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line">all, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer.Write(all)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServe(<span class="string">":2872"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在GOPATH下有一个 <code>demo.txt</code> 文件，浏览器输入一下地址 <code>http://localhost:2872/list/demo.txt</code> ,浏览器正确输出结果</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15254248021435.jpg" alt=""></p><p>万一我访问一个不存在的文件呢？会得到什么样的结果，比如我现在访问 <code>http://localhost:2872/list/demo.txts</code> GOPATH目录下没有demo.txts文件，自然你会想到会panic一个错误</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="regexp">/05/</span><span class="number">04</span> <span class="number">17</span>:<span class="number">08</span>:<span class="number">54</span> <span class="string">http:</span> panic serving [::<span class="number">1</span>]:<span class="number">51946</span>: open demo.<span class="string">txts:</span> no such file or directory</span><br><span class="line">goroutine <span class="number">5</span> [running]:</span><br><span class="line">net/http.(*conn).serve.func1(<span class="number">0xc4200968c0</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>net<span class="regexp">/http/</span>server.<span class="string">go:</span><span class="number">1726</span> +<span class="number">0xd0</span></span><br><span class="line">panic(<span class="number">0x124fde0</span>, <span class="number">0xc420086fc0</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>runtime/panic.<span class="string">go:</span><span class="number">502</span> +<span class="number">0x229</span></span><br><span class="line">main.main.func1(<span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject/</span>src<span class="regexp">/shengguocun.com/</span>web/web.<span class="string">go:</span><span class="number">52</span> +<span class="number">0x144</span></span><br><span class="line">net/http.HandlerFunc.ServeHTTP(<span class="number">0x12aff28</span>, <span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>net<span class="regexp">/http/</span>server.<span class="string">go:</span><span class="number">1947</span> +<span class="number">0x44</span></span><br><span class="line">net/http.(*ServeMux).ServeHTTP(<span class="number">0x140b3e0</span>, <span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>go<span class="regexp">/1.10.2/</span>libexec<span class="regexp">/src/</span>net<span class="regexp">/http/</span>server.<span class="string">go:</span><span class="number">2337</span> +<span class="number">0x130</span></span><br><span class="line">net/http.serverHandler.ServeHTTP(<span class="number">0xc420089110</span>, <span class="number">0x12d1420</span>, <span class="number">0xc42010e000</span>, <span class="number">0xc42010a000</span>)</span><br></pre></td></tr></table></figure><p>从上面的部分的报错信息来看，</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15254260616558.jpg" alt=""></p><p>相关的错误信息都是 <code>/usr/local/Cellar/go/1.10.2/libexec/src/net/http/server.go</code> 的 <code>serve</code> 函数报出的，具体是哪一步报出的我就不细说了，有兴趣的可以自己按照例子自己查阅相关的源码，说到这那错误统一处理又是如何处理呢？<br>我们先把第一个panic替换成</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path := request.URL.Path[len(<span class="string">"/list/"</span>):]</span><br><span class="line"><span class="keyword">file</span>, <span class="keyword">err</span> := os.<span class="keyword">Open</span>(path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line"></span><br><span class="line">http.<span class="keyword">Error</span>(writer, <span class="keyword">err</span>.<span class="keyword">Error</span>(), http.StatusInternalServerError)</span><br><span class="line"><span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来访问上述地址</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15254277514513.jpg" alt=""></p><p>相比之前，提示稍微友好一点了，但是这对用户来讲还是不合适的，直接将程序内部错误信息输出给用户有些欠妥。我们可以包装成一个外部的Error，首先我们先定义一个函数appHandler, 返回一个error</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> appHandler func(writer http.<span class="type">ResponseWriter</span>, request *http.<span class="type">Request</span>) error</span><br></pre></td></tr></table></figure><p>然后定义一个 errWrapper 函数, 返回一个handler 里面需要的函数</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">type appHandler <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errWrapper</span><span class="params">(handler appHandler)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(http.ResponseWriter, *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">err := handler(writer, request)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> os.<span class="type">IsNotExist</span>(err):</span><br><span class="line">    http.<span class="type">Error</span>(writer, http.<span class="type">StatusText</span>(http.<span class="type">StatusNotFound</span>), http.<span class="type">StatusNotFound</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将writer和request传进handler，通过switch判断err的类型，做一个统一的返回处理；这时我们需要将原来的业务逻辑的代码稍微做一下调整，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http.HandleFunc(<span class="string">"/list/"</span>,</span><br><span class="line">errWrapper(<span class="function"><span class="keyword">func</span><span class="params">(writer http.ResponseWriter, request *http.Request)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">path := request.URL.Path[<span class="built_in">len</span>(<span class="string">"/list/"</span>):]</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span>  file.Close()</span><br><span class="line"></span><br><span class="line">all, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">writer.Write(all)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">err := http.ListenAndServe(<span class="string">":2872"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>http.HandleFunc</code> 的第二个参数我们需要改为 <code>errWrapper</code> 同时将原来的函数作为参数传进去，当然这个函数为了代码的可读性应该单独抽离出来，相应的返回直接返回error就可以了，这时候我们再去访问之前的一个不存在的URL</p><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15256970597886.jpg" alt=""></p><p>这时候的错误就明显友好了很多，将到这就是一个简单的统一错误处理的思路。</p><h2 id="7-测试和性能调优"><a href="#7-测试和性能调优" class="headerlink" title="7. 测试和性能调优"></a>7. 测试和性能调优</h2><h3 id="7-0、测试"><a href="#7-0、测试" class="headerlink" title="7.0、测试"></a>7.0、测试</h3><h3 id="7-1、代码覆盖率和性能测试"><a href="#7-1、代码覆盖率和性能测试" class="headerlink" title="7.1、代码覆盖率和性能测试"></a>7.1、代码覆盖率和性能测试</h3><h3 id="7-2、使用pprof进行性能调优"><a href="#7-2、使用pprof进行性能调优" class="headerlink" title="7.2、使用pprof进行性能调优"></a>7.2、使用pprof进行性能调优</h3><h3 id="7-3、生成文档和事例代码"><a href="#7-3、生成文档和事例代码" class="headerlink" title="7.3、生成文档和事例代码"></a>7.3、生成文档和事例代码</h3><h2 id="8-Goroutine"><a href="#8-Goroutine" class="headerlink" title="8. Goroutine"></a>8. Goroutine</h2><h3 id="8-0、Goroutine介绍"><a href="#8-0、Goroutine介绍" class="headerlink" title="8.0、Goroutine介绍"></a>8.0、Goroutine介绍</h3><h3 id="8-1、Go语言调度器"><a href="#8-1、Go语言调度器" class="headerlink" title="8.1、Go语言调度器"></a>8.1、Go语言调度器</h3><h2 id="9-Channel"><a href="#9-Channel" class="headerlink" title="9. Channel"></a>9. Channel</h2><h3 id="9-0、Channel介绍"><a href="#9-0、Channel介绍" class="headerlink" title="9.0、Channel介绍"></a>9.0、Channel介绍</h3><h3 id="9-1、使用Channel等待任务结束"><a href="#9-1、使用Channel等待任务结束" class="headerlink" title="9.1、使用Channel等待任务结束"></a>9.1、使用Channel等待任务结束</h3><h3 id="9-2、使用Channel进行树遍历"><a href="#9-2、使用Channel进行树遍历" class="headerlink" title="9.2、使用Channel进行树遍历"></a>9.2、使用Channel进行树遍历</h3><h3 id="9-3、用select进行调度"><a href="#9-3、用select进行调度" class="headerlink" title="9.3、用select进行调度"></a>9.3、用select进行调度</h3><h3 id="9-4、传统同步机制"><a href="#9-4、传统同步机制" class="headerlink" title="9.4、传统同步机制"></a>9.4、传统同步机制</h3><h2 id="10-Http及其他标准库"><a href="#10-Http及其他标准库" class="headerlink" title="10. Http及其他标准库"></a>10. Http及其他标准库</h2><h3 id="10-0、Http标准库介绍"><a href="#10-0、Http标准库介绍" class="headerlink" title="10.0、Http标准库介绍"></a>10.0、Http标准库介绍</h3><h3 id="10-1、其他库介绍"><a href="#10-1、其他库介绍" class="headerlink" title="10.1、其他库介绍"></a>10.1、其他库介绍</h3><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0. 前言&quot;&gt;&lt;/a&gt;0. 前言&lt;/h2&gt;&lt;p&gt;A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些
      
    
    </summary>
    
    
      <category term="Go语言" scheme="https://www.shengguocun.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
      <category term="入门" scheme="https://www.shengguocun.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>GDB抓虫之旅</title>
    <link href="https://www.shengguocun.com//blog/2018/03/15/taste-gdb/"/>
    <id>https://www.shengguocun.com//blog/2018/03/15/taste-gdb/</id>
    <published>2018-03-15T05:59:24.000Z</published>
    <updated>2018-03-15T06:08:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">问: gdb是什么？</span></span><br><span class="line"><span class="section">答: 强大的UNIX下命令行调试工具。</span></span><br><span class="line"></span><br><span class="line"><span class="section">问: gdb能干什么？</span></span><br><span class="line"><span class="section">答: 让你随心所欲的驾驭你的程序；Start、Stop、Examine、Change。</span></span><br><span class="line"></span><br><span class="line"><span class="section">问: 我们为什么要学习gdb？</span></span><br><span class="line"><span class="section">答: 欲善其事，必先利其器；利用gdb进一步的定位程序异常。</span></span><br><span class="line"></span><br><span class="line"><span class="section">问: 本次分享的宗旨?</span></span><br><span class="line"><span class="section">答: gdb的介绍和使用入门，为大家抓虫多提供一个选择。</span></span><br></pre></td></tr></table></figure><h2 id="抓虫从0开始"><a href="#抓虫从0开始" class="headerlink" title="抓虫从0开始"></a>抓虫从0开始</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><blockquote><p>1.包含有调试信息的可执行文件</p><p>2.编译时加-g选项即可，不建议开优化选项</p></blockquote><h3 id="GDB的启动"><a href="#GDB的启动" class="headerlink" title="GDB的启动"></a>GDB的启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb &lt;program&gt;</span><br><span class="line">gdb &lt;program&gt; core</span><br><span class="line">gdb &lt;program&gt; &lt;PID&gt;</span><br><span class="line">(gdb) file &lt;program&gt;</span><br></pre></td></tr></table></figure><h3 id="抓虫流程"><a href="#抓虫流程" class="headerlink" title="抓虫流程"></a>抓虫流程</h3><image src="http://nos.netease.com/ceb-report-document/detail_data/consume_detail_969e5fd49156d7ba2f98a301a2bb81da.jpeg?imageView&thumbnail=300x0"><h3 id="实战1-GDB基础命令的使用"><a href="#实战1-GDB基础命令的使用" class="headerlink" title="实战1 :  GDB基础命令的使用"></a>实战1 :  GDB基础命令的使用</h3><p>1.1、示例程序(example_1.cpp)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result+=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s1=<span class="string">"dafdf"</span>;</span><br><span class="line">    <span class="keyword">char</span> * s2;</span><br><span class="line"><span class="comment">//  s1=s2;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result[1-100]="</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"result[1-250]="</span>&lt;&lt;foo(<span class="number">250</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2、调试准备<br>编译命令：g++ -g -Wall -o example_1 example_1.cpp</p><p>1.3、启动gdb</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ gdb example_1</span><br><span class="line">GNU gdb Red Hat Linux (6.3.0.0-1.96rh)</span><br><span class="line">Copyright 2004 Free Software Foundation, Inc.</span><br><span class="line">GDB is free software, covered by the GNU General Public License, <span class="keyword">and</span> you are</span><br><span class="line">welcome <span class="keyword">to</span> change it <span class="keyword">and</span>/<span class="keyword">or</span> distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There is absolutely <span class="literal">no</span> warranty <span class="keyword">for</span> GDB. <span class="built_in"> Type </span><span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span><span class="built_in">..</span>.Using host libthread_db library <span class="string">"/lib64/tls/libthread_db.so.1"</span>.</span><br></pre></td></tr></table></figure><p>1.4、辅助性命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) cd <span class="built_in">..</span></span><br><span class="line">Working directory /home/work/testers/sgc.</span><br><span class="line">(gdb) shell ls</span><br><span class="line">autotest <span class="built_in"> client </span> Makefile  spanti  spantispam_if.h  study</span><br><span class="line">(gdb) cd study/</span><br><span class="line">Working directory /home/work/testers/sgc/study.</span><br><span class="line">(gdb) pwd</span><br><span class="line">Working directory /home/work/testers/sgc/study.</span><br><span class="line">(gdb) help run</span><br><span class="line">Start debugged program.  You may specify arguments <span class="keyword">to</span> give it.</span><br><span class="line">Args may include <span class="string">"*"</span>, <span class="keyword">or</span> <span class="string">"[...]"</span>; they are expanded using <span class="string">"sh"</span>.</span><br><span class="line">Input <span class="keyword">and</span> output redirection with <span class="string">"&gt;"</span>, <span class="string">"&lt;"</span>, <span class="keyword">or</span> <span class="string">"&gt;&gt;"</span> are also allowed.</span><br><span class="line"></span><br><span class="line">With <span class="literal">no</span> arguments, uses arguments last specified (with <span class="string">"run"</span> <span class="keyword">or</span> <span class="string">"set args"</span>).</span><br><span class="line"><span class="keyword">To</span> cancel previous arguments <span class="keyword">and</span> <span class="builtin-name">run</span> with <span class="literal">no</span> arguments,</span><br><span class="line">use <span class="string">"set args"</span> without arguments.</span><br></pre></td></tr></table></figure><p>1.5、设置断点命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看源代码信息</span></span><br><span class="line">(gdb) l</span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br><span class="line"><span class="number">18</span>              &#125;</span><br><span class="line"><span class="number">19</span>              <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span>      &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>      <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">24      </span>&#123;</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span>              <span class="built_in">string</span> s1=<span class="string">"dafdf"</span>;</span><br><span class="line">(gdb) l <span class="number">1</span></span><br><span class="line"><span class="number">1</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="number">2</span>       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>       <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="number">6</span>       <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">7       </span>&#123;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">10</span></span><br><span class="line">(gdb) l example_1.cpp:<span class="number">16</span></span><br><span class="line"><span class="number">11</span>      &#125;</span><br><span class="line"><span class="number">12</span>      <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">13      </span>&#123;</span><br><span class="line"><span class="number">14</span>              <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>              <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">16</span>              &#123;</span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br><span class="line"><span class="number">18</span>              &#125;</span><br><span class="line"><span class="number">19</span>              <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">20</span></span><br><span class="line">(gdb) <span class="function">l <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">8</span></span><br><span class="line"><span class="function">9               <span class="keyword">return</span> 1</span>;</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span>      &#125;</span><br><span class="line"><span class="number">12</span>      <span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">13      </span>&#123;</span><br><span class="line"><span class="number">14</span>              <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line"><span class="number">15</span>              <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line"><span class="number">16</span>              &#123;</span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置断点</span></span><br><span class="line">(gdb) <span class="selector-tag">b</span> <span class="number">17</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x400c07: file example_1<span class="selector-class">.cpp</span>, line <span class="number">17</span>.</span><br><span class="line">(gdb) <span class="selector-tag">b</span> main</span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0</span>x400c27: file example_1<span class="selector-class">.cpp</span>, line <span class="number">26</span>.</span><br><span class="line">(gdb) info br</span><br><span class="line">Num Type           Disp Enb Address            What</span><br><span class="line"><span class="number">1</span>   breakpoint     keep y   <span class="number">0</span>x0000000000400c07 <span class="keyword">in</span> foo(int) at example_1<span class="selector-class">.cpp</span>:<span class="number">17</span></span><br><span class="line"><span class="number">2</span>   breakpoint     keep y   <span class="number">0</span>x0000000000400c27 <span class="keyword">in</span> main at example_1<span class="selector-class">.cpp</span>:<span class="number">26</span></span><br></pre></td></tr></table></figure><p>1.6、执行控制命令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting <span class="string">program:</span> <span class="regexp">/home/</span>work<span class="regexp">/testers/</span>sgc<span class="regexp">/study/</span>example_1</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">2</span>, main () at example_1.<span class="string">cpp:</span><span class="number">26</span></span><br><span class="line"><span class="number">26</span>              string s1=<span class="string">"dafdf"</span>;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">result[<span class="number">1</span><span class="number">-100</span>]=<span class="number">5050</span></span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, foo (n=<span class="number">250</span>) at example_1.<span class="string">cpp:</span><span class="number">17</span></span><br><span class="line"><span class="number">17</span>                      result+=n;</span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">15</span>              <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br></pre></td></tr></table></figure><p>1.7、程序信息查看命令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//查看变量信息</span><br><span class="line">(gdb) p result</span><br><span class="line"><span class="number">$1</span> = <span class="number">250</span></span><br><span class="line">(gdb) p s1</span><br><span class="line"><span class="number">$2</span> = <span class="number">1431655765</span></span><br><span class="line"> (gdb) disp result</span><br><span class="line"><span class="number">1</span>: result = <span class="number">250</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, foo (n=<span class="number">250</span>) <span class="meta">at</span> example_1.cpp:<span class="number">17</span></span><br><span class="line"><span class="number">17</span>                      result+=n<span class="comment">;</span></span><br><span class="line"><span class="number">1</span>: result = <span class="number">250</span></span><br><span class="line">(gdb) info locals</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line">result = <span class="number">250</span></span><br><span class="line"></span><br><span class="line">//查看栈信息</span><br><span class="line">(gdb) <span class="keyword">bt</span></span><br><span class="line">#<span class="number">0</span>  foo (n=<span class="number">250</span>) <span class="meta">at</span> example_1.cpp:<span class="number">17</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000400cc1</span> <span class="keyword">in</span> main () <span class="meta">at</span> example_1.cpp:<span class="number">38</span></span><br><span class="line">(gdb) info f</span><br><span class="line">Stack level <span class="number">0</span>, frame <span class="meta">at</span> <span class="number">0x7fbffff8a0</span>:</span><br><span class="line"> <span class="built_in">rip</span> = <span class="number">0x400c07</span> <span class="keyword">in</span> foo(<span class="keyword">int</span>) (example_1.cpp:<span class="number">17</span>)<span class="comment">; saved rip 0x400cc1</span></span><br><span class="line"> called by frame <span class="meta">at</span> <span class="number">0x7fbffff910</span></span><br><span class="line"> source language c++.</span><br><span class="line"> Arglist <span class="meta">at</span> <span class="number">0x7fbffff890</span>, args: n=<span class="number">250</span></span><br><span class="line"> Locals <span class="meta">at</span> <span class="number">0x7fbffff890</span>, Previous frame<span class="string">'s sp is 0x7fbffff8a0</span></span><br><span class="line"><span class="string"> Saved registers:</span></span><br><span class="line"><span class="string">  rbp at 0x7fbffff890, rip at 0x7fbffff898</span></span><br><span class="line"><span class="string">(gdb) f 0</span></span><br><span class="line"><span class="string">#0  foo (n=250) at example_1.cpp:17</span></span><br><span class="line"><span class="string">17                      result+=n;</span></span><br></pre></td></tr></table></figure><p>1.8、修改环境命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="builtin-name">set</span> var <span class="attribute">i</span>=97</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="variable">$5</span> = 97</span><br><span class="line">(gdb) <span class="builtin-name">print</span> <span class="attribute">i</span>=98</span><br><span class="line"><span class="variable">$6</span> = 98</span><br><span class="line">(gdb) ignore 1 300</span><br><span class="line">Will ignore next 300 crossings of breakpoint 1.</span><br><span class="line">(gdb) finish</span><br><span class="line"><span class="builtin-name">Run</span> till exit <span class="keyword">from</span> #0  foo (<span class="attribute">n</span>=250) at example_1.cpp:17</span><br><span class="line">0x0000000000400cc1 <span class="keyword">in</span> main () at example_1.cpp:38</span><br><span class="line">38              cout&lt;&lt;<span class="string">"result[1-250]="</span>&lt;&lt;foo(250)&lt;&lt;endl;</span><br><span class="line">Value returned is <span class="variable">$8</span> = 38500</span><br><span class="line">(gdb) quit</span><br><span class="line">The program is running.  Exit anyway? (y <span class="keyword">or</span> n) y</span><br></pre></td></tr></table></figure><h2 id="不要放过core文件"><a href="#不要放过core文件" class="headerlink" title="不要放过core文件"></a>不要放过core文件</h2><blockquote><p>问 ：Core文件是什么？<br>答 ：a disk file containing an <span style="color:red">image of the process’s memory</span> at the time of termination</p></blockquote><p><br></p><blockquote><p>问 ：Core的作用？<br>答 ：<br>&nbsp;&nbsp;&nbsp;&nbsp;1、让你在调试时，不用花费大量等待程序出错；<br>&nbsp;&nbsp;&nbsp;&nbsp;2、让你避免了单步调试的烦恼<br>&nbsp;&nbsp;&nbsp;&nbsp;3、让你定位错误所在</p></blockquote><h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gdb &lt;<span class="function"><span class="keyword">program</span></span>&gt; core</span><br></pre></td></tr></table></figure><h3 id="查看程序信息的常用命令"><a href="#查看程序信息的常用命令" class="headerlink" title="查看程序信息的常用命令"></a>查看程序信息的常用命令</h3><p>1、查看栈信息：bt, f n, up/down，info frame<br>2、查看变量信息：info args|locals</p><h3 id="实战2-core文件调试"><a href="#实战2-core文件调试" class="headerlink" title="实战2 :  core文件调试"></a>实战2 :  core文件调试</h3><p>2.1、示例程序(crash2.c)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Strcpy</span><span class="params">(<span class="keyword">char</span> *to , <span class="keyword">char</span> *from)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(to , from);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">    Strcpy(s, <span class="string">"abcdefg"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2、查看信息</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ gdb ./crash2 core.<span class="number">19562</span></span><br><span class="line">GNU gdb Red Hat Linux (<span class="number">6.3</span>.<span class="number">0.0</span>-<span class="number">1.96</span>rh)</span><br><span class="line">Copyright <span class="number">2004</span> Free Software Foundation, Inc.</span><br><span class="line">GDB <span class="keyword">is</span> free software, covered by the GNU General Public License, <span class="keyword">and</span> you are</span><br><span class="line">welcome <span class="keyword">to</span> change it <span class="keyword">and</span>/<span class="keyword">or</span> distribute copies <span class="keyword">of</span> it under certain conditions.</span><br><span class="line"><span class="keyword">Type</span> <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There <span class="keyword">is</span> absolutely no warranty <span class="keyword">for</span> GDB.  <span class="keyword">Type</span> <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-redhat-linux-gnu"</span>...Using host libthread_db <span class="keyword">library</span> <span class="string">"/lib64/tls/libthread_db.so.1"</span>.</span><br><span class="line"></span><br><span class="line">Core was generated by `./crash2'.</span><br><span class="line">Program terminated <span class="keyword">with</span> <span class="keyword">signal</span> <span class="number">11</span>, Segmentation fault.</span><br><span class="line">Reading symbols from /lib64/tls/libc.so.<span class="number">6</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">Reading symbols from /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/ld-linux-x86-<span class="number">64</span>.so.<span class="number">2</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x000000302af6f9a4 <span class="keyword">in</span> strcpy () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x000000302af6f9a4 <span class="keyword">in</span> strcpy () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00000000004004c5 <span class="keyword">in</span> Strcpy (<span class="keyword">to</span>=<span class="number">0</span>x0, from=<span class="number">0</span>x4005dc <span class="string">"abcdefg"</span>) at crash2.c:<span class="number">5</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0</span>x00000000004004e5 <span class="keyword">in</span> main () at crash2.c:<span class="number">10</span></span><br><span class="line">(gdb) f <span class="number">0</span></span><br><span class="line">#<span class="number">0</span>  <span class="number">0</span>x000000302af6f9a4 <span class="keyword">in</span> strcpy () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">(gdb) up</span><br><span class="line">#<span class="number">1</span>  <span class="number">0</span>x00000000004004c5 <span class="keyword">in</span> Strcpy (<span class="keyword">to</span>=<span class="number">0</span>x0, from=<span class="number">0</span>x4005dc <span class="string">"abcdefg"</span>) at crash2.c:<span class="number">5</span></span><br><span class="line"><span class="number">5</span>                       strcpy(<span class="keyword">to</span> , from);</span><br><span class="line">(gdb) info args</span><br><span class="line"><span class="keyword">to</span> = <span class="number">0</span>x0</span><br><span class="line">from = <span class="number">0</span>x4005dc <span class="string">"abcdefg"</span></span><br><span class="line"></span><br><span class="line">//至此，已经清楚的发现了问题所在，<span class="keyword">to</span>指针为空</span><br></pre></td></tr></table></figure><h2 id="进阶之多线程程序调试"><a href="#进阶之多线程程序调试" class="headerlink" title="进阶之多线程程序调试"></a>进阶之多线程程序调试</h2><h3 id="多线程调试常用命令"><a href="#多线程调试常用命令" class="headerlink" title="多线程调试常用命令"></a>多线程调试常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> info &lt;...&gt;  // 强大的查看命令，如info threads</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> attach/detach &lt;pid&gt; // 挂载到进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> thread &lt;thread_no&gt; // 切换到线程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> thread apply &lt;thread_no_list&gt; &lt;cmd&gt;</span></span><br><span class="line"> // 对于list中的thread，执行cmd</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">break</span> &lt;linenum&gt; thread &lt;threadno&gt; <span class="keyword">if</span> ...</span></span><br></pre></td></tr></table></figure><h3 id="实战3-多线程程序调试"><a href="#实战3-多线程程序调试" class="headerlink" title="实战3 :  多线程程序调试"></a>实战3 :  多线程程序调试</h3><p>3.1、正常的示例程序(good_thread.c)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">pthread_t</span> thread[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mut;</span><br><span class="line"><span class="keyword">int</span> number=<span class="number">0</span>, i;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"thread1 : I'm thread 1\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread1 : number = %d\n"</span>,number);</span><br><span class="line">                pthread_mutex_lock(&amp;mut);</span><br><span class="line">                        number++;</span><br><span class="line">                pthread_mutex_unlock(&amp;mut);</span><br><span class="line">                sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread1 :主函数在等我完成任务吗？\n"</span>);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread2 : I'm thread 2\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread2 : number = %d\n"</span>,number);</span><br><span class="line">                pthread_mutex_lock(&amp;mut);</span><br><span class="line">                        number++;</span><br><span class="line">                 pthread_mutex_unlock(&amp;mut);</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread2 :主函数在等我完成任务吗？\n"</span>);</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_create</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;thread, <span class="number">0</span>, <span class="keyword">sizeof</span>(thread));          <span class="comment">//comment1</span></span><br><span class="line">       <span class="comment">/*创建线程*/</span></span><br><span class="line">        <span class="keyword">if</span>((temp = pthread_create(&amp;thread[<span class="number">0</span>], <span class="literal">NULL</span>, thread1, <span class="literal">NULL</span>)) != <span class="number">0</span>)       <span class="comment">//comment2</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程1创建失败!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程1被创建\n"</span>);</span><br><span class="line">        <span class="keyword">if</span>((temp = pthread_create(&amp;thread[<span class="number">1</span>], <span class="literal">NULL</span>, thread2, <span class="literal">NULL</span>)) != <span class="number">0</span>) <span class="comment">//comment3</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程2创建失败"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程2被创建\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_wait</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*等待线程结束*/</span></span><br><span class="line">        <span class="keyword">if</span>(thread[<span class="number">0</span>] !=<span class="number">0</span>) &#123;                   <span class="comment">//comment4</span></span><br><span class="line">                pthread_join(thread[<span class="number">0</span>],<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程1已经结束\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(thread[<span class="number">1</span>] !=<span class="number">0</span>) &#123;                <span class="comment">//comment5</span></span><br><span class="line">                pthread_join(thread[<span class="number">1</span>],<span class="literal">NULL</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"线程2已经结束\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">/*用默认属性初始化互斥锁*/</span></span><br><span class="line">        pthread_mutex_init(&amp;mut,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是主函数哦，我正在创建线程，呵呵\n"</span>);</span><br><span class="line">        thread_create();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是主函数哦，我正在等待线程完成任务阿，呵呵\n"</span>);</span><br><span class="line">        thread_wait();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.2、演示过程</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">gdb</span>)</span><br><span class="line"><span class="number">21</span>              printf (<span class="string">"thread1 : I'm thread 1\n"</span>)<span class="comment">;</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span>              for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt; MAX; i++)</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span>              &#123;</span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span>                      printf(<span class="string">"thread1 : number = %d\n"</span>,number)<span class="comment">;</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span>                      pthread_mutex_lock(<span class="name">&amp;mut</span>)<span class="comment">;</span></span><br><span class="line">(<span class="name">gdb</span>) b <span class="number">27</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0</span>x40079e: file good_thread.c, line <span class="number">27</span>.</span><br><span class="line">(<span class="name">gdb</span>)</span><br><span class="line"><span class="number">51</span>              for (<span class="name">i</span> = <span class="number">0</span><span class="comment">; i &lt; MAX; i++)</span></span><br><span class="line"><span class="number">52</span></span><br><span class="line"><span class="number">53</span>              &#123;</span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="number">55</span>                      printf(<span class="string">"thread2 : number = %d\n"</span>,number)<span class="comment">;</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">57</span>                      pthread_mutex_lock(<span class="name">&amp;mut</span>)<span class="comment">;</span></span><br><span class="line"><span class="number">58</span></span><br><span class="line"><span class="number">59</span>                              number++<span class="comment">;</span></span><br><span class="line">(<span class="name">gdb</span>) b <span class="number">57</span></span><br><span class="line">Breakpoint <span class="number">2</span> at <span class="number">0</span>x400838: file good_thread.c, line <span class="number">57</span>.</span><br><span class="line">(<span class="name">gdb</span>) r</span><br><span class="line">Starting program: /home/work/testers/sgc/study/goodthread</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">[New Thread <span class="number">182894112416</span> (<span class="name">LWP</span> <span class="number">22783</span>)]</span><br><span class="line">ÎÒÊÇÖ÷º¯ÊýÅ¶£¬ÎÒÕýÔÚ´´½¨Ïß³Ì£¬ºÇºÇ</span><br><span class="line">[New Thread <span class="number">1084229984</span> (<span class="name">LWP</span> <span class="number">22786</span>)]</span><br><span class="line">Ïß³Ì<span class="number">1</span>±»´´½¨</span><br><span class="line">thread1 : I'm thread <span class="number">1</span></span><br><span class="line">[Switching to Thread <span class="number">1084229984</span> (<span class="name">LWP</span> <span class="number">22786</span>)]</span><br><span class="line"></span><br><span class="line">Breakpoint <span class="number">1</span>, thread1 () at good_thread.c:<span class="number">27</span></span><br><span class="line"><span class="number">27</span>                      printf(<span class="string">"thread1 : number = %d\n"</span>,number)<span class="comment">;</span></span><br><span class="line">(<span class="name">gdb</span>) bt</span><br><span class="line">#0  thread1 () at good_thread.c:<span class="number">27</span></span><br><span class="line">#1  <span class="number">0</span>x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.<span class="number">0</span></span><br><span class="line">#2  <span class="number">0</span>x000000302afc6003 in clone () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">#3  <span class="number">0</span>x0000000000000000 in ?? ()</span><br><span class="line">(<span class="name">gdb</span>) info threads</span><br><span class="line">[New Thread <span class="number">1094719840</span> (<span class="name">LWP</span> <span class="number">22787</span>)]</span><br><span class="line">  <span class="number">3</span> Thread <span class="number">1094719840</span> (<span class="name">LWP</span> <span class="number">22787</span>)  <span class="number">0</span>x000000302afc5fc4 in clone () from /lib64/tls/libc.so.<span class="number">6</span></span><br><span class="line">* 2 Thread 1084229984 (LWP 22786)  thread1 () at good_thread.c:27</span><br><span class="line">  1 Thread 182894112416 (LWP 22783)  0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6</span><br><span class="line">(gdb) thread 1</span><br><span class="line">[Switching to thread 1 (Thread 182894112416 (LWP 22783))]#0  0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6</span><br><span class="line">#1  0x000000302b805d86 in do_clone () from /lib64/tls/libpthread.so.0</span><br><span class="line">#2  0x000000302b806846 in pthread_create@@GLIBC_2.2.5 () from /lib64/tls/libpthread.so.0</span><br><span class="line">#3  0x00000000004008fd in thread_create () at good_thread.c:91</span><br><span class="line">#4  0x00000000004009a9 in main () at good_thread.c:135</span><br></pre></td></tr></table></figure><p>3.3、死锁示例程序（multi_thread.c）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUM 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> AccountA_mutex;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> AccountB_mutex;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span> &#123;</span></span><br><span class="line">     <span class="keyword">char</span> account_name[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">int</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span>  <span class="title">accountA</span> = &#123;</span><span class="string">'A'</span>, <span class="number">100000</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span>  <span class="title">accountB</span> = &#123;</span><span class="string">'B'</span>, <span class="number">200000</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">accountAB</span> <span class="params">(<span class="keyword">void</span>* amount_ptr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> amount = *((<span class="keyword">int</span>*)amount_ptr);</span><br><span class="line">     pthread_mutex_lock(&amp;AccountA_mutex);</span><br><span class="line">     <span class="keyword">if</span> (accountA.balance &lt; amount)   &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"There is not enough memory in Account A!\n"</span>);</span><br><span class="line">             pthread_mutex_unlock(&amp;AccountA_mutex);</span><br><span class="line">             pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     accountA.balance -=amount;</span><br><span class="line">     sleep(<span class="number">2</span>);</span><br><span class="line">     pthread_mutex_lock(&amp;AccountB_mutex);</span><br><span class="line">     accountB.balance +=amount;</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountA_mutex);</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountB_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">accountBA</span> <span class="params">(<span class="keyword">void</span>* amount_ptr)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> amount = *((<span class="keyword">int</span>*)amount_ptr);</span><br><span class="line">     pthread_mutex_lock(&amp;AccountB_mutex);</span><br><span class="line">     <span class="keyword">if</span> (accountB.balance &lt; amount)   &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"There is not enough memory in Account B!\n"</span>);</span><br><span class="line">             pthread_mutex_unlock(&amp;AccountB_mutex);</span><br><span class="line">             pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     accountB.balance -=amount;</span><br><span class="line">     pthread_mutex_lock(&amp;AccountA_mutex);</span><br><span class="line">     accountA.balance +=amount;</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountB_mutex);</span><br><span class="line">     pthread_mutex_unlock(&amp;AccountA_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> threadid[THREAD_NUM];</span><br><span class="line">     <span class="keyword">pthread_t</span> pthread[THREAD_NUM];</span><br><span class="line">     <span class="keyword">void</span>* thResState;</span><br><span class="line">     <span class="keyword">int</span> res, flag;</span><br><span class="line">     <span class="keyword">int</span> transfer_amount[THREAD_NUM] = &#123;<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>,<span class="number">900</span>,<span class="number">800</span>,<span class="number">700</span>,<span class="number">600</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">300</span>,<span class="number">200</span>&#125;;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">     pthread_attr_init(&amp;attr);</span><br><span class="line">     pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(flag=<span class="number">0</span>; flag&lt;THREAD_NUM; flag++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountAB, \</span><br><span class="line">                                (<span class="keyword">void</span>*)&amp;transfer_amount[flag]) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">"Thread %d creation failed\n"</span>, flag);</span><br><span class="line">                      <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountBA, \</span><br><span class="line">                                (<span class="keyword">void</span>*)&amp;transfer_amount[flag]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">"Thread %d creation failed\n"</span>, flag);</span><br><span class="line">                  <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(flag=<span class="number">0</span>; flag&lt;THREAD_NUM; flag++)&#123;</span><br><span class="line">           res = pthread_join(pthread[flag], &amp;thResState);</span><br><span class="line">           <span class="keyword">if</span> (res != <span class="number">0</span>)&#123;</span><br><span class="line">                  perror(<span class="string">"Thread join failed"</span>);</span><br><span class="line">                  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">printf</span>(<span class="string">"thread success  id %u state code %d\n"</span>,threadid[flag],thResState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Transitions are in progress.."</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"\nAll the  money is transferred !!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.4、错误定位</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g -o multi_thread multi_thread.c –lpthread</span><br><span class="line">$ ./multi_thread</span><br><span class="line">$ ps -eLF |grep multi</span><br><span class="line">work    21675 19997 21675  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21676  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21677  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21678  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21679  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21680  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21681  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21682  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21683  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21684  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21685  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21686  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21687  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21688  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21689  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21690  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21691  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21692  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21693  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21694  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line">work    21675 19997 21695  0   21 52124  464   0 00:25 pts/8    00:00:00 ./multi_thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ gdb</span><br><span class="line">GNU gdb Red Hat Linux (6.3.0.0-1.96rh)</span><br><span class="line">Copyright 2004 Free Software Foundation, Inc.</span><br><span class="line">GDB is free software, covered by the GNU General Public License, and you are</span><br><span class="line">welcome to <span class="keyword">change</span> it <span class="keyword">and</span>/<span class="keyword">or</span> <span class="keyword">distribute</span> copies <span class="keyword">of</span> it <span class="keyword">under</span> certain conditions.</span><br><span class="line"><span class="keyword">Type</span> <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There <span class="keyword">is</span> absolutely <span class="keyword">no</span> warranty <span class="keyword">for</span> GDB.  <span class="keyword">Type</span> <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured <span class="keyword">as</span> <span class="string">"x86_64-redhat-linux-gnu"</span>.</span><br><span class="line">(gdb) attach <span class="number">21680</span></span><br><span class="line">Attaching <span class="keyword">to</span> process <span class="number">21680</span></span><br><span class="line">Reading symbols <span class="keyword">from</span> /home/<span class="keyword">work</span>/testers/sgc/study/multi_thread...done.</span><br><span class="line"><span class="keyword">Using</span> host libthread_db <span class="keyword">library</span> <span class="string">"/lib64/tls/libthread_db.so.1"</span>.</span><br><span class="line">Reading symbols <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span>...done.</span><br><span class="line">[<span class="keyword">Thread</span> debugging <span class="keyword">using</span> libthread_db enabled]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">182894112416</span> (LWP <span class="number">21675</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1283537248</span> (LWP <span class="number">21695</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1273047392</span> (LWP <span class="number">21694</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1262557536</span> (LWP <span class="number">21693</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1252067680</span> (LWP <span class="number">21692</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1241577824</span> (LWP <span class="number">21691</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1231087968</span> (LWP <span class="number">21690</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1220598112</span> (LWP <span class="number">21689</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1210108256</span> (LWP <span class="number">21688</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1199618400</span> (LWP <span class="number">21687</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1189128544</span> (LWP <span class="number">21686</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1178638688</span> (LWP <span class="number">21685</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1168148832</span> (LWP <span class="number">21684</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1157658976</span> (LWP <span class="number">21683</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1147169120</span> (LWP <span class="number">21682</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1136679264</span> (LWP <span class="number">21681</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1126189408</span> (LWP <span class="number">21680</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1115699552</span> (LWP <span class="number">21679</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1105209696</span> (LWP <span class="number">21678</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1094719840</span> (LWP <span class="number">21677</span>)]</span><br><span class="line">[<span class="keyword">New</span> <span class="keyword">Thread</span> <span class="number">1084229984</span> (LWP <span class="number">21676</span>)]</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">Reading symbols <span class="keyword">from</span> /lib64/tls/libc.so<span class="number">.6</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/tls/libc.so<span class="number">.6</span></span><br><span class="line">Reading symbols <span class="keyword">from</span> /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span>...done.</span><br><span class="line">Loaded symbols <span class="keyword">for</span> /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span></span><br><span class="line"><span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line"></span><br><span class="line">(gdb) bt</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000432041e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000432049f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">(gdb) info threads</span><br><span class="line">  <span class="number">21</span> <span class="keyword">Thread</span> <span class="number">1084229984</span> (LWP <span class="number">21676</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">20</span> <span class="keyword">Thread</span> <span class="number">1094719840</span> (LWP <span class="number">21677</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">19</span> <span class="keyword">Thread</span> <span class="number">1105209696</span> (LWP <span class="number">21678</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">18</span> <span class="keyword">Thread</span> <span class="number">1115699552</span> (LWP <span class="number">21679</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">17</span> <span class="keyword">Thread</span> <span class="number">1126189408</span> (LWP <span class="number">21680</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">16</span> <span class="keyword">Thread</span> <span class="number">1136679264</span> (LWP <span class="number">21681</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">15</span> <span class="keyword">Thread</span> <span class="number">1147169120</span> (LWP <span class="number">21682</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">14</span> <span class="keyword">Thread</span> <span class="number">1157658976</span> (LWP <span class="number">21683</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">13</span> <span class="keyword">Thread</span> <span class="number">1168148832</span> (LWP <span class="number">21684</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">12</span> <span class="keyword">Thread</span> <span class="number">1178638688</span> (LWP <span class="number">21685</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">11</span> <span class="keyword">Thread</span> <span class="number">1189128544</span> (LWP <span class="number">21686</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">10</span> <span class="keyword">Thread</span> <span class="number">1199618400</span> (LWP <span class="number">21687</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">9</span> <span class="keyword">Thread</span> <span class="number">1210108256</span> (LWP <span class="number">21688</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">8</span> <span class="keyword">Thread</span> <span class="number">1220598112</span> (LWP <span class="number">21689</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">7</span> <span class="keyword">Thread</span> <span class="number">1231087968</span> (LWP <span class="number">21690</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">6</span> <span class="keyword">Thread</span> <span class="number">1241577824</span> (LWP <span class="number">21691</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">5</span> <span class="keyword">Thread</span> <span class="number">1252067680</span> (LWP <span class="number">21692</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">4</span> <span class="keyword">Thread</span> <span class="number">1262557536</span> (LWP <span class="number">21693</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">3</span> <span class="keyword">Thread</span> <span class="number">1273047392</span> (LWP <span class="number">21694</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">2</span> <span class="keyword">Thread</span> <span class="number">1283537248</span> (LWP <span class="number">21695</span>)  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">  <span class="number">1</span> <span class="keyword">Thread</span> <span class="number">182894112416</span> (LWP <span class="number">21675</span>)  <span class="number">0x000000302b806ffb</span> <span class="keyword">in</span> pthread_join () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line"></span><br><span class="line">(gdb) <span class="keyword">thread</span> <span class="keyword">apply</span> all bt</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">21</span> (<span class="keyword">Thread</span> <span class="number">1084229984</span> (LWP <span class="number">21676</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">20</span> (<span class="keyword">Thread</span> <span class="number">1094719840</span> (LWP <span class="number">21677</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000414011e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000414019f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">19</span> (<span class="keyword">Thread</span> <span class="number">1105209696</span> (LWP <span class="number">21678</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000041e021e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000041e029f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">18</span> (<span class="keyword">Thread</span> <span class="number">1115699552</span> (LWP <span class="number">21679</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000428031e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000428039f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">17</span> (<span class="keyword">Thread</span> <span class="number">1126189408</span> (LWP <span class="number">21680</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000432041e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000432049f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">16</span> (<span class="keyword">Thread</span> <span class="number">1136679264</span> (LWP <span class="number">21681</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000043c051e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000043c059f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">15</span> (<span class="keyword">Thread</span> <span class="number">1147169120</span> (LWP <span class="number">21682</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000446061e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000446069f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">14</span> (<span class="keyword">Thread</span> <span class="number">1157658976</span> (LWP <span class="number">21683</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000450071e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000450079f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">13</span> (<span class="keyword">Thread</span> <span class="number">1168148832</span> (LWP <span class="number">21684</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000045a081e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000045a089f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">12</span> (<span class="keyword">Thread</span> <span class="number">1178638688</span> (LWP <span class="number">21685</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x00000000464091e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x00000000464099f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">11</span> (<span class="keyword">Thread</span> <span class="number">1189128544</span> (LWP <span class="number">21686</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000046e0a1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000046e0a9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="keyword">Thread</span> <span class="number">10</span> (<span class="keyword">Thread</span> <span class="number">1199618400</span> (LWP <span class="number">21687</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004780b1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004780b9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">9</span> (<span class="keyword">Thread</span> <span class="number">1210108256</span> (LWP <span class="number">21688</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004820c1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004820c9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">8</span> (<span class="keyword">Thread</span> <span class="number">1220598112</span> (LWP <span class="number">21689</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000048c0d1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="comment">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span></span><br><span class="line">#<span class="number">2</span>  <span class="number">0x0000000048c0d9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">7</span> (<span class="keyword">Thread</span> <span class="number">1231087968</span> (LWP <span class="number">21690</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004960e1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004960e9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">6</span> (<span class="keyword">Thread</span> <span class="number">1241577824</span> (LWP <span class="number">21691</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004a00f1e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004a00f9f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">5</span> (<span class="keyword">Thread</span> <span class="number">1252067680</span> (LWP <span class="number">21692</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004aa101e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004aa109f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"><span class="keyword">Thread</span> <span class="number">4</span> (<span class="keyword">Thread</span> <span class="number">1262557536</span> (LWP <span class="number">21693</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004b4111e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004b4119f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">3</span> (<span class="keyword">Thread</span> <span class="number">1273047392</span> (LWP <span class="number">21694</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004be121e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004be129f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">2</span> (<span class="keyword">Thread</span> <span class="number">1283537248</span> (LWP <span class="number">21695</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b80adfb</span> <span class="keyword">in</span> __lll_mutex_lock_wait () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x000000004c8131e0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">2</span>  <span class="number">0x000000004c8139f0</span> <span class="keyword">in</span> ?? ()</span><br><span class="line">#<span class="number">3</span>  <span class="number">0x000000302b807bd4</span> <span class="keyword">in</span> pthread_mutex_lock () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">4</span>  <span class="number">0x0000000000000000</span> <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line"><span class="comment">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span></span><br><span class="line"><span class="keyword">Thread</span> <span class="number">1</span> (<span class="keyword">Thread</span> <span class="number">182894112416</span> (LWP <span class="number">21675</span>)):</span><br><span class="line">#<span class="number">0</span>  <span class="number">0x000000302b806ffb</span> <span class="keyword">in</span> pthread_join () <span class="keyword">from</span> /lib64/tls/libpthread.so<span class="number">.0</span></span><br><span class="line">#<span class="number">1</span>  <span class="number">0x0000000000400b69</span> <span class="keyword">in</span> <span class="keyword">main</span> (argc=<span class="number">1</span>, argv=<span class="number">0x7fbffffa08</span>) <span class="keyword">at</span> multi_thread.c:<span class="number">76</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GDB是一个好用的抓虫工具，随意控制进程，随便查看内存和环境；上述只是新手学习过程中的一些记录，欢迎深入探讨。</p></image>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
      <category term="GDB" scheme="https://www.shengguocun.com/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.shengguocun.com//blog/2018/01/12/hello-world/"/>
    <id>https://www.shengguocun.com//blog/2018/01/12/hello-world/</id>
    <published>2018-01-12T06:29:51.000Z</published>
    <updated>2018-05-07T07:20:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
