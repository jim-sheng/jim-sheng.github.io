[{"title":"Vanilla （lua web framework）中文文档 [2018.09.19]","date":"2018-09-19T13:18:21.000Z","path":"/blog/2018/09/19/quick-start-Vanilla-lua-web-framework/","text":"0、前言香草/Vanilla是一个基于Openresty实现的高性能Web应用开发框架. 邮件列表 vanilla-en &#x76;&#97;&#x6e;&#x69;&#x6c;&#x6c;&#97;&#45;&#101;&#x6e;&#64;&#x67;&#x6f;&#111;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#115;&#46;&#x63;&#111;&#x6d; vanilla-devel &#x76;&#x61;&#x6e;&#x69;&#x6c;&#x6c;&#x61;&#x2d;&#100;&#101;&#x76;&#x65;&#x6c;&#x40;&#x67;&#111;&#111;&#103;&#108;&#101;&#x67;&#x72;&#x6f;&#117;&#112;&#115;&#x2e;&#99;&#x6f;&#109; vanilla中文邮件列表 &#x76;&#x61;&#x6e;&#105;&#108;&#x6c;&#x61;&#64;&#x67;&#111;&#111;&#103;&#x6c;&#x65;&#103;&#114;&#111;&#117;&#112;&#115;&#x2e;&#99;&#111;&#x6d; 推荐始终使用最新版的Vanilla 当前Vanilla最新版本0.1.0.rc6，支持命令： vanilla-0.1.0.rc6（你没看错，自0.1.0.rc5起，vanilla的命令行和框架代码都带着版本号，方便多版本共存，也方便框架升级） v-console-0.1.0.rc6 特性 提供很多优良组件诸如：bootstrap、 router、 controllers、 models、 views。 强劲的插件体系。 多 Application 部署。 多版本框架共存，支持便捷的框架升级。 一键 nginx 配置、 应用部署。 便捷的服务批量管理。 你只需关注自身业务逻辑。 0.1、安装1$ ./setup-framework -v $VANILLA_PROJ_ROOT -o $OPENRESTY_ROOT #运行 ./setup-framework -h 查看更多参数细节 0.2、快速开始部署你的第一个Vanilla Application 1$ ./setup-vanilal-demoapp [-a $VANILLA_APP_ROOT -u $VANILLA_APP_USER -g $VANILLA_APP_GROUP -e $VANILLA_RUNNING_ENV] #运行 ./setup-vanilal-demoapp -h 查看更多参数细节 启动你的 Vanilla 服务 1$ ./$VANILLA_APP_ROOT/va-appname-service start 社区组织 QQ群&amp;&amp;微信公众号 Openresty/Vanilla 开发 1 群：205773855 Openresty/Vanilla 开发 2 群：419191655 Openresty 技术交流 1 群：34782325 Openresty 技术交流 2 群：481213820 Openresty 技术交流 3 群：124613000 Vanilla开发微信公众号:Vanilla-OpenResty(Vanilla相关资讯、文档推送) 1、快速上手1.1、Hello World1.1.1、Vanilla 的安装安装准备 安装好 OpenResty Vanilla Github 地址：https://github.com/idevz/vanilla 安装 123456789# 1.git clone 最新 Vanilla 版本（或者下载相应的 Vanilla release 版本）git clone https://github.com/idevz/vanilla.git# 2. 切换到 Vanilla 文件夹cd vanilla# 3.编译 vanilla： ./setup-framework -v $VANILLA_PROJ_ROOT -o $OPENRESTY_ROOT 其中 $VANILLA_PROJ_ROOT 为 vanilla 框架安装目录。 -o 为 openresty 安装目录./setup-framework -v /application/vanilla -o /application/openresty 经过这 3 步如果没有报错，则安装 vanilla 成功 创建 vanilla 项目 12345678910111213141516171819202122232425262728293031#1. 创建 vanilla 的运行用户useradd -s /sbin/nologin -M nginxid nginx # 可以查看到创建的用户# 2、创建 vanilla 项目, -a 为 项目路径，-u 为执行用户 -g 为用户组 （在根目录 /home/webserver 下创建名为 cms 的项目）./setup-vanilla-demoapp -a /home/webserver/cms -u nginx -g nginx# 3、删掉默认 Nginx 服务pkill -9 nginx# 4、切换到项目文件夹 编辑项目配置文件，改成你要的cd /home/webserver/cmscd nginx_confvim va-nginx.confvim va-nginx-development.conf# 5、同步配置文件到运行目录./va-cms-service initconf dev -f #开发模式./va-cms-service initconf -f #生产模式# 6、启动项目（2选1）./va-cms-service start dev # 启动开发模式./va-cms-service start # 启动生产模式 服务启动后，开发环境默认启动在 9110 端口，http://localhost:9110 即可访问 vanilla 常用命令 启动项目： ./va-cms-service start 或者 ./va-orcms-service start dev 重启项目 ./va-cms-service restart 或者 ./va-orcms-service restart dev 停止项目： ./va-cms-service stop 或者 ./va-orcms-service stop dev 创建配置文件 ./va-cms-service initconf dev -f 1.2、如何调试1.2.1、Vanilla 的 调试除了查看 nginx 错误日志辅助开发外，为了方便 Vanilla 项目的开发和调试，Vanilla 提供了诸如 print_r 之类的对象输出方法，以及详细友好的页面报错输出，你不需要到服务器日志去查看，就能所见即所得的开发调试代码. sprint_r，print_r，lprint_r，err_log sprint_r 将 LUA 对象等格式化为易读的字符串返回 print_r 类似 ngx.say 的效果，将对象、变量等以易读的格式进行输出，适用于 Vanilla 开发的 Web 服务 lprint_r print_r 的 CLI 版本，适用于 v-console 命令行环境 1234567891011╰─○ v-console-0.1.0.rc6Lua 5.1.4 Copyright (C) 1994-2008 Lua.org, PUC-Riov-console&gt;a=&#123;&#125;v-console&gt;a.v1='a_v1'v-console&gt;a.v2='a_v2'v-console&gt;lprint_r(a)&#123; v2 = \"a_v2\", v1 = \"a_v1\"&#125;v-console&gt; err_log err_log 方法是对 ngx.ERR 的封装，将 msg 记录到 nginx 错误日志 1.3、如何新增一个Controller1.3.1、Vanilla 的 controllervanilla 的 controller 是业务处理的关键，vanilla 通过对 URI 的路由，找到本次请求对应的 controller 和 action。 最简单的 Controller 自动生成的 demo 中默认生成了 IndexController 和 index action（function IndexController:index()），默认使用简单路由协议（vanilla.v.routes.simple）对 URI 进行路由 12345678910111213141516171819local IndexController = &#123;&#125;-- curl http://localhost:9110function IndexController:index() local view = self:getView() local p = &#123;&#125; p['vanilla'] = 'Welcome To Vanilla...' .. user_service:get() p['zhoujing'] = 'Power by Openresty' -- view:assign(p) do return view:render('index/index.html', p) end return view:display()end-- curl http://localhost:9110/index/action_bfunction IndexController:action_b() return 'index-&gt;action_b'endreturn IndexController 以上代码解释 关于上面的 controller 实例代码，我们只需关注下面几点 IndexController:index （index Controller 中的 index Action），通过 self:getView() 方法获取视图实例 可以通过先调用 view:assign(p) 将所需要的参数传入视图，再调用 view:display() 进行模板渲染，或者可以直接调用 view:render(&#39;index/index.html&#39;, p) 方法，指定需要渲染的模板，并同时传入相应的参数 模板参数都是与 LUA 数组的形式进行传递 每个 action 的返回值都必须是字符串，所以可以知道 view:display() 和 view:render() 方法都是返回字符串 IndexController:action_b （index Controller 中的 action_b Action，这里注意，action 的方法名必须小写），使用默认的简单路由协议，访问 URI 为 curl http://localhost:9110/index/action_b 注：目前 vanilla 所默认使用的模板引擎是 appo 老师开发的 resty-template，模板详细的使用文档请移步 appo 老师处参阅。 1.3.2、新添加一个 Controller给 Vanilla 添加一个新的 Controller 非常简单，只需要在项目的 controllers 目录，实现一个 LUA 包，包导入的函数即为各个 action， 文件名与 controller 同名。例如添加一个名为 idevz 的 controller， 且实现一个名为 dohello 的 action（）。 123456local IdevzController = &#123;&#125;-- curl http://localhost:9110/idevz/dohellofunction IdevzController:dohello() return 'do-hello-action.'endreturn IdevzController 1.4、如何使用Models/Dao1.4.1、Vanilla 的 DAOvanilla 的 DAO 预设为项目对数据源的封装，一切对数据源的操作都可以封装成 DAO，方便维护、管理、缓存等。 Vanilla 的 DAO 在项目的 models/dao 路径下，一般使用 LoadModel 方法进行加载 最简单的 DAO 由自动生成的 demo 中默认生成了 TableDao，可以看出 TableDao 只是一个普通的 LUA 包。 123456789101112131415161718192021local TableDao = &#123;&#125;function TableDao:set(key, value) self.__cache[key] = value return trueendfunction TableDao:new() local instance = &#123; set = self.set, __cache = &#123;&#125; &#125; setmetatable(instance, TableDao) return instanceendfunction TableDao:__index(key) local out = rawget(rawget(self, '__cache'), key) if out then return out else return false endendreturn TableDao 以上代码解释 DAO 可以是任何对数据层访问封装的 LUA 包，实现方式非常自由。 1.5、如何使用Models/Service1.5.1、Vanilla 的 Servicevanilla 的 Service 预设为项目对某些通用业务逻辑封装为独立的 Service，方便维护、管理、缓存等。 Vanilla 的 Service 在项目的 models/service 路径下，一般使用 LoadModel 方法进行加载 最简单的 Service 由自动生成的 demo 中默认生成了 UserService，可以看出 UserService 也只是一个普通的 LUA 包。不过 Service 一般调用更底层的 DAO ，并对之做必要封装，并将相关的 Service 暴露给 Controller 使用 123456789local table_dao = LoadApplication('models.dao.table'):new()local UserService = &#123;&#125;function UserService:get() table_dao:set('zhou', 'UserService res') return table_dao.zhouendreturn UserService 以上代码解释 Service 可以是任何对数据层访问封装的 LUA 包 2、APIs2.1、配置2.1.1、配置香草/Vanilla的配置由以下三个部分组成. App配置 Nginx配置 WAF配置 App配置 应用基础配置（config/application.lua） 1234567891011121314151617Appconf.sysconf = &#123; --系统预加载配置文件 'v_resource',&#125;Appconf.name = 'app_name' --app名称，执行vanilla new命令时给定的应用名Appconf.route='vanilla.v.routes.simple' --路由器，指定URL路由方式，目的解析出需要执行的controller与actionAppconf.bootstrap='application.bootstrap' --初始化bootstrap（用来对应用进行初始化操作）Appconf.app=&#123;&#125; --app相关配置Appconf.app.root='./' --当前vanilla start命令执行路径Appconf.controller=&#123;&#125; --当前app的controller相关配置Appconf.controller.path=Appconf.app.root .. 'application/controllers/' --controller文件所在路径（使用默认生成路径即可）Appconf.view=&#123;&#125; --当前app的视图层相关配置Appconf.view.path=Appconf.app.root .. 'application/views/' --模板路径Appconf.view.suffix='.html' --模板后缀Appconf.view.auto_render=true --是否开启自动渲染 应用基础配置的引用 12-- 如上的配置，可以在代码中通过 Registry['APP_CONF'] 表来进行获取，比如获取 APP_NAMElocal app_name = Registry['APP_CONF']['name'] 错误处理配置（config/errors.lua） 根据errors.lua文件中实例，配置用户级别错误码. 123local Errors = &#123; [1000] = &#123; status = 500, message = \"Controller Err.\" &#125;,&#125; Restful 路由协议配置（config/restful.lua） 根据 URI 需要来自定义路由协议的配置 12345678910111213141516171819local restful = &#123; v1=&#123;&#125;, v=&#123;&#125;&#125;restful.v.GET = &#123; &#123;pattern = '/', controller = 'index', action = 'index'&#125;, &#123;pattern = '/:category', controller = 'index', action = 'list'&#125;&#125;restful.v.POST = &#123; &#123;pattern = '/post', controller = 'index', action = 'post'&#125;,&#125;restful.v1.GET = &#123; &#123;pattern = '/api', controller = 'index', action = 'api_get'&#125;,&#125;return restful 系统相关配置（sys/*） 比如DB、MC等资源配置，系统相关的分机房配置等（在某些大公司，这部分配置又运维人员统一管理和下发），文件格式目前使用相对更运维友好的 ini 文件，开发中可以方便的在 Registry[‘sys_conf’] 中获取相关数据，如 Registry[&#39;sys_conf&#39;][&#39;cache&#39;][&#39;lrucache&#39;] 获取 lrucache 相关配置 系统缓存相关配置 （sys/cache） 12345678910111213141516171819202122[shared_dict]dict=idevzexptime=100[memcached]instances=127.0.0.1:11211 127.0.0.1:11211exptime=60timeout=100poolsize=100idletimeout=10000[redis]instances=127.0.0.1:6379 127.0.0.1:6379exptime=60timeout=100poolsize=100idletimeout=10000[lrucache]items=200exptime=60useffi=false 目前这部分配置一般由 vanilla.v.libs.cache 来使用 目前支持的配置项如 poolsize（连接池大小）、timeout（数据获取超时等） 系统缓存相关配置 （sys/v_resource） 12345678910111213141516171819202122[mc]conf=127.0.0.1:7348 127.0.0.1:11211[redis]conf=127.0.0.1:7348 127.0.0.1:7349[redisq]conf=127.0.0.1:7348 127.0.0.1:7349[db.user.write]host =127.0.0.1port =3306dbname =user.infouser =idevzpasswd =idevz[db.user.read]host =127.0.0.1port =3306dbname =user.infouser =idevzpasswd =idevz 对所使用的数据资源做配置 Registry[&#39;sys_conf&#39;][&#39;v_resource）&#39;][&#39;db.user.write&#39;][&#39;host&#39;] 获取写库的 HOST 信息 Nginx配置 自动生成的 Nginx 配置文件 初始化项目的时候会在项目目录下（nginx_conf/）自动生成这个项目所对应的两套（分别对应开发和线上环境）配置文件，生成的两套配置文件中，每套都包含 nginx.conf 和 vhost 两个配置文件 生产环境 va-nginx.conf 文件 va-nginx.conf 配置文件内容包含 nginx 配置主干（main、events、http 等重点配置段），包括用户、组的配置，工作进程等等通用配置，关键的还有 lua_package_path、lua_package_cpath 的配置，还有框架初始化文件（vanilla/framework/init.lua）的加载 vhost/app_name.conf 文件 vhost/app_name.conf 文件是当前应用的相关配置，包括 APP_NAME、VANILLA_VERSION、$template_root、$va_cache_status 等全局变量的初始化，$document_root，Server_name 等的设置，还有关键的应用入口（content_by_lua_file），lua_shared_dict 等的设置，不过这些设置都是自动生成的，开发人员没有特殊需求的话，并不需要关注这些 开发环境 va-nginx-development.conf 文件 va-nginx-development.conf 文件的内容跟开发环境类似，唯一的区别在于加载框架初始化文件（vanilla/framework/init.lua）的方式为 init_by_lua_file dev_vhost/app_name.conf 文件 默认的dev_vhost/app_name.conf 文件的配置同生产环境的配置基本一样，关键不同在于 lua_code_cache 的设置 注：所以初始化项目后，首先需要执行 sudo ./va-app_name-service initconf dev 命令，就是为了将自动生成的配置文件部署到 OpenResty 默认的配置文件路径下，如果需要更新 va-nginx（-development）.conf 则还需要在命令后面加上 -f 参数进行强行部署，每次如果需要修改配置，也只需修改这部分配置，然后执行 initconf 即可 nginx.lua( vanilla-0.1.0.rc5 后废弃此配置 ) 分为ngx_conf.common和ngx_conf.env两个部分，common是对Openresty指令集的配置如INIT_BY_LUA，可以是包或者文件(BY_LUA_FILE)，env是环境的部分，包括了开发环境，测试环境和生产环境端口和缓存配置等控制. 123456789ngx_conf.common = &#123; INIT_BY_LUA = 'nginx.init', CONTENT_BY_LUA_FILE = './pub/index.lua'&#125;ngx_conf.env = &#123;&#125;ngx_conf.env.development = &#123; LUA_CODE_CACHE = false, PORT = 7200&#125; WAF配置 waf.lua 包括WAF规则的配置，及各种规则参数的配置，相关使用方法详见 waf 2.2、Bootstrap2.2.1、使用 Bootstrap 来做服务初始化Vanilla 使用 Bootstrap 来做应用初始化的工作，用户可以在此对应用做一些配置（比如所使用的路由协议，使用何种视图引擎），对配置做一些初始化加载，初始化 WAF，初始化 Plugins 等操作，Vanilla 运行在 OpenResty content_by_lua\\这个 Phrase，使用 Bootstrap 可以很好的实现对请求的细粒度控制* Bootstrap 即类 application.bootstrap Bootstrap 的实现其实是一个名为 application.bootstrap 的 Vanilla 类，实现了构造器初始化的属性只有一个（当前请求所使用的 dispatcher），我们只需要关注根据需求实现各种 init 方法即可，最后只要在 boot_list 方法返回的列表中的 init 方法都会被顺序执行 12345678910111213function Bootstrap:boot_list() return &#123; -- Bootstrap.initWaf, -- Bootstrap.initErrorHandle, Bootstrap.initRoute, -- Bootstrap.initView, -- Bootstrap.initPlugin, &#125;endfunction Bootstrap:__construct(dispatcher) self.dispatcher = dispatcherend 上面的定义代表只有 initRoute 方法会被执行，而上面两个方法的实现我们并不需要关心和更改，只需要定义各种 init 方法，并更新 boot_list 返回的表元素即可，比如下面初始化路由协议的 initRoute 12345function Bootstrap:initRoute() local router = self.dispatcher:getRouter() local restful_route = restful:new(self.dispatcher:getRequest()) router:addRoute(restful_route, true)end 注：可以通过 self.dispatcher 获取当前请求相关的详细信息，并进行相关控制 2.3、Controllers2.3.1、Vanilla 的 controllervanilla 的 controller 是业务处理的关键，基本的用法请参考上文 (如何新增一个Controller) 。 关于 Controller Vanilla 的 Controller 可以是任何普通的 LUA 包，只不过导入的方法被用作处理请求的 Action。如下示例： 12345678910111213141516171819local IndexController = &#123;&#125;-- curl http://localhost:9110function IndexController:index() local view = self:getView() local p = &#123;&#125; p['vanilla'] = 'Welcome To Vanilla...' .. user_service:get() p['zhoujing'] = 'Power by Openresty' -- view:assign(p) do return view:render('index/index.html', p) end return view:display()end-- curl http://localhost:9110/index/action_bfunction IndexController:action_b() return 'index-&gt;action_b'endreturn IndexController 更面向对象的 Controller Vanilla 支持使用 Class 方法来声明一个 Controller，实例如下： 12345678local IndexController = Class('controllers.index')-- curl http://localhost:9110/index/action_bfunction IndexController:action_b() return 'index-&gt;action_b'endreturn IndexController 这种情况下，可以定义 Controller 的构造器来对其进行初始化。示例如下： 123456789101112local IndexController = Class('controllers.index')function IndexController:__construct() self.aa = aa(&#123;info='ppppp'&#125;)end-- curl http://localhost:9110/index/action_bfunction IndexController:action_b() return 'index-&gt;action_b'endreturn IndexController 甚至还可以声明一个 Controller 基类，处理某些通用的逻辑，相关的详细用法参见 Vanilla面向对象 相关章节。 关于 Action 的返回值 Vanilla 底层会将 Action 执行的结果，完全使用 ngx.print 进行输出，所以 Action 的返回值必须不能为空。而由于 Vanilla 的 Response 中，提供了给响应添加头尾的 Response:appendBody 和 Response:prependBody 方法，最终的结果会将这些部分合起来一起返回，所以 Action 的返回值要求如下： Action 返回值必须非空 Action 返回值可以为一维索引数组（不可以是多维 Hash 数组）或者字符串 2.4、模板引擎2.4.1、Vanilla 的视图引擎为去除模板运行时模板解析带来的不必要开销，从 vanilla-0.1.0.rc7 起 Vanilla 开始支持 OpenResty 官方的 Lemplate 模板引擎，下面将简要介绍 Vanilla 中 Lemplate 的用法，以及 Vanilla View 接口介绍 Vanilla 的视图渲染 Vanilla 在 vanilla.v.dispatcher 中导入了默认的模板引擎（local View = LoadV &#39;vanilla.v.views.rtpl&#39;），但是可以在 Bootstrap 中实现 initView 来修改所使用的视图引擎。而 Vanilla 的模板渲染，只需要在相应的 Action 中获取当前视图实例，注入数据，展示即可。下面就以 Lemplate 模板引擎为例，展示相关用法 首先在 Bootstrap 中实现 initView 方法，修改项目所使用的视图引擎 12345678910111213141516-- application/bootstrap.luafunction Bootstrap:initView() local view = LoadV('vanilla.v.views.lemplate'):new(self.dispatcher.application.config.view) self.dispatcher:setView(view)end-- boot_list 中打开 Bootstrap.initView 方法调用function Bootstrap:boot_list() return &#123; -- Bootstrap.initWaf, -- Bootstrap.initErrorHandle, -- Bootstrap.initRoute, Bootstrap.initView, -- Bootstrap.initPlugin, &#125;end 运行 ./va-{app_name}-service ltpl 命令调用 Lemplate 编译你的 TT2 模板 下面是 TT2 模板示意 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;[% title %]&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;[% FOREACH userinfo IN userlists %]&lt;p&gt; &lt;h6&gt;姓名：[% userinfo.name %] / 地址：[% userinfo.addr %]&lt;/h6&gt;&lt;/p&gt;[% END %]&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在 Vanilla Action 中调用编译好的模板 12345678function IndexController:index() local view = self:getView() local users = &#123; &#123;name='idevz', addr='yunnan'&#125;, &#123;name='vanilla', addr='beijing'&#125;, &#125; return view:assign(&#123;userlists=users, title = 'Vanilla-Lemplate'&#125;)end 注： local view = self:getView() 获取当前视图实例 view:assign({userlists=users, title = &#39;Vanilla-Lemplate&#39;}) 将数据注入视图 注：以上为 Lemplate 所使用的 TT2 模板实例，关于 Lemplate 的详细使用，可参考其详细 文档 2.5、插件2.5.1、Vanilla 的插件体系为了减少运行占用的系统资源，使开发更简便，Vanilla 默认只运行在 content_by_lua 这个 phrase，但是为了支持业务开发有层次化的请求控制，Vanilla 实现了便捷的插件机制，提供了六个钩子，给请求的细粒度控制提供了可能。下面我们来看看如何使用 Vanilla Plugin 的简单使用 在 Vanilla 项目中使用插件是非常简单的，只需要在 application/plugins/ 路径下实现 Vanilla 的插件 LUA 包即可，插件包可以按需实现 6 个钩子的方法。默认生成的 demo 项目中自动生成了一个 admin plugin，见 application/plugins/admin.lua。六个钩子方法按需实现，空方法可去掉，如下所示： 123456789101112local AdminPlugin = LoadV('vanilla.v.plugin'):new()function AdminPlugin:routerStartup(request, response) print_r('&lt;pre&gt;') if request.method == 'GET' then print_r('-----------' .. sprint_r(request.headers) .. '----------') else print_r(request.headers) endendreturn AdminPlugin Vanilla Plugin 的调用 Vanilla Plugins 的调用非常简单，只需要在 application/bootstrap.lua 中实现 initPlugin 方法，并调用 dispatcher 的插件注册方法将插件注入项目（ self.dispatcher:registerPlugin(admin_plugin)），即能在对应的时机执行相关钩子对应的方法 123456789101112131415161718local Bootstrap = Class('application.bootstrap')function Bootstrap:initPlugin() local admin_plugin = LoadPlugin('plugins.admin'):new() self.dispatcher:registerPlugin(admin_plugin);endfunction Bootstrap:boot_list() return &#123; Bootstrap.initPlugin, &#125;endfunction Bootstrap:__construct(dispatcher) self.dispatcher = dispatcherendreturn Bootstrap Vanilla 支持的插件钩子 以下列出 Vanilla 支持的 6 中插件钩子 123456function Plugin:routerStartup(request, response) -- 开始路由function Plugin:routerShutdown(request, response) -- 路由结束function Plugin:dispatchLoopStartup(request, response) -- 开始请求分发function Plugin:preDispatch(request, response) -- 预分发（载入相关的 controller）function Plugin:postDispatch(request, response) -- 请求响应function Plugin:dispatchLoopShutdown(request, response) -- 请求分发执行结束 2.6、路由2.6.1、Vanilla 的路由体系Vanilla 实现的路由体系有一个路由器（vanilla.v.router）和若干路由协议构成（Vanilla 默认实现了 vanilla.v.routes.simple 和 vanilla.v.routes.restful 两种路由协议，默认使用 simple 路由来路由请求），请求处理的开始阶段，Vanilla 通过调用路由器协议栈中的各种路由协议，计算出处理当前请求的 controller 和 action，这就是 Vanilla 路由体系的职责所在。如果默认的两种路由协议不能满足你的 URI 路由需求，你可以参考我的一篇《如何给Vanilla(OpenResty)添加一个路由协议》的博文 Vanilla 路由器 Vanilla 的路由器 vanilla.v.router 是请求路由的基础，路由器提供了对路由协议的添加 addRoute(route, only_one)，删除 removeRoute(route_name)，获取路由列表 getRoutes() 等方法，用户可以调用这些方法来管理路由协议栈并使用路由器，不过用户不需要关心路由器的实现，而只需要关注路由协议的实现。 给路由器添加一条路由协议 路由器只有唯一一个 vanilla.v.router，但路由协议可以有多个，通过 addRoute(route, only_one) 方法的调用可以向路由协议栈添加一条路由协议，第二个参数为可选参数，当设置为 true 时，代表将清空路由协议栈，只使用当前添加的这条路由协议，因为 Vanilla 路由请求的方式是路由器根据路由协议栈中的路由协议挨条解析，直到找到匹配的 controller 和 action 为止，太多的路由协议栈可能影响路由性能。 删除一条路由协议 Vanilla 的每条路由协议都有 route_name 属性，删除时只需要调用 removeRoute(route_name) 获取当前所使用的路由协议 Vanilla 支持获取当前请求所使用的路由协议，只需调用 getCurrentRoute() 方法，调用 getCurrentRouteName() 方法可以获取当前路由协议名 路由协议 路由协议非常的简单，因为路由协议的关键功能在于为当前请求找到对应的 controller 和 action，核心在于根据当前请求实例 request，通过实现 match 方法，来获取结果，下面是根据 vanilla.v.routes.simple 路由协议提炼出来的路由协议简单骨架： 12345678910111213141516171819local Simple = &#123;&#125;function Simple:new(request) local instance = &#123; route_name = 'vanilla.v.routes.simple', request = request &#125; setmetatable(instance, &#123; __index = self, __tostring = function(self) return self.route_name end &#125;) return instanceendfunction Simple:match()endreturn Simple 注：我们需要关注以下两点 route_name 这是路由协议栈索引的关键，协议栈中的路由协议依靠 route_name 进行管理 request 是当前请求的实例，包含了当前请求携带的 URI，http_header 等数据，是请求路由的依据 2.7、异常处理2.7.1、Vanilla 的错误处理Vanilla 的错误处理分为框架系统错误和应用错误两种类型，系统错误由框架控制，一般导致致命错误，直接抛出 500 内部错误，切不再往下执行，而应用错误则可以通过定义 errorController 来自定义处理 Vanilla 应用错误 Vanilla 提供了方便的错误处理方式，避免当代码运行报错后，页面只显示一个 500 错误的白页，没有详细报错信息，影响开发效率，Vanilla 的应用错误处理非常简单，在业务开发中，我们所关注的各个组件比如 DAO、Service、Controller、Action、Library 等都可能报错，Controller Action 作为 Vanilla 项目处理请求的执行体，一切业务组件的错误都可以通过一个统一的处理口径 errorController 来方便的处理。在业务组件开发过程中的错误，或者用户自定义的错误，都可以在 errorController 中得到捕获和处理，默认初始化的 demo 项目中，application/controllers/ 路径下，默认定义了一个 error.lua 文件，这就是前面所说的 errorController，下面我们具体来看看这段代码： 12345678910111213141516171819local ErrorController = &#123;&#125;local ngx_log = ngx.loglocal ngx_redirect = ngx.redirectlocal os_getenv = os.getenvfunction ErrorController:error() local env = os_getenv('VA_ENV') or 'development' if env == 'development' then local view = self:getView() view:assign(self.err) return view:display() else local helpers = require 'vanilla.v.libs.utils' ngx_log(ngx.ERR, helpers.sprint_r(self.err)) -- return ngx_redirect(\"http://sina.cn?vt=4\", ngx.HTTP_MOVED_TEMPORARILY) return helpers.sprint_r(self.err) endendreturn ErrorController 代码释意：（你只需要关注以下几点，即可随意，按需定义适合你的 errorController） 这是一个普通的 LUA 包，一个普通的 Vanilla Controller，唯一需要注意的一点就是需要实现一个 error 方法，注意方法名小写 可以通过对运行环境的判断来，对不同的运行环境进行不同的错误处理，比如开发环境可能需要直接将错误打印到页面，而生产环境可能需要出错误页面等 Vanilla 框架系统错误（致命错误） 当有些 Vanilla 项目所必须的配置或者关键步骤执行异常而影响项目往下运行的情况下，会抛出致命错误，并结束当前请求，目前有以下几种情况 关键配置缺少 项目未配置项目名 name，或者未指定项目根路径 root，Vanilla 有很多地方依赖项目名，比如缓存的 KEY 设置，项目的各类包加载依赖于项目根路径做全局加载，多 APP 支持也依赖与此。如果 config/application.lua 中缺少这两个配置，则会如下错误： 1234Sys Err: Please set app name and app root in config/application.lua like: Appconf.name = 'idevz.org' Appconf.app.root='/data1/VANILLA_ROOT/idevz.org/' bootstrap 报错 Bootstrap 中的各种 init 方法并不是必须的，但是如果这部分方法定义后，执行错误，将影响整体项目的正常运行，所以 application/bootstrap.lua 中的运行报错也会报出系统致命错误，举例如下： 123456function Bootstrap:initRoute() local router = self.dispatcher:getRouter() local restful_route = restful:new(self.dispatcher:getRequest()) router:addRoute(restful_route, true) print_r('xx' .. false)end 注：以上代码，最后一行操作试图将字符串与 bool 值 false 连接，会报出致命错误，如下： 12&lt;pre /&gt;\"...g/idevz/code/www/vanilla/orcon/application/bootstrap.lua:18: attempt to concatenate a boolean value\" dispatch 执行报错 dispatch 属于框架的请求分发操作，请求分发执行出错直接导致致命错误，不过这个错误由框架自己处理，用户不需要关注 2.8、内建类2.8.1、Vanilla 的內建变量和方法为方便业务开发，Vanilla 提供了一些比较实用的內建方法和变量，这里我们说明如下，随着框架的更新，本页面会及时更新，欢迎随时关注。 Vanilla 的內建变量 Vanilla 的內建变量很多来自于 nginx.conf，其他则来自于 ngx.var，Vanilla 将这些变量都缓存在了 Registry 中 Registry 变量 Registry 是 Vanilla 中为了全局数据共享，及高效数据访问而封装的一个全局表，这里缓存了刻画当前请求比较全的数据，具体列表说明如下： 12345678910111213141516171819-- 以下数据以 \"curl http://domain.org/?arg1=aa1&amp;arg2=aa2\" 访问为例进行说明Registry['APP_CONF'] -- 当前应用的配置数据，来自于（config/application.lua）Registry['sys_conf'] -- 当前应用的系统配置，来自于（sys/*路径，比如可以使用 Registry['sys_conf']['cache'] 获取 sys/cache 文件中关于 cache 的配置）Registry['REQ_URI'] -- 当前请求的 URI ，为 \"/\"Registry['REQ_ARGS'] -- 当前请求的参数字符串，即 Query_String，为 \"arg1=aa1&amp;arg2=aa2\"Registry['REQ_ARGS_ARR'] -- 当前请求的参数列表，为一个 LUA 数组Registry['REQ_HEADERS'] -- 当前请求的请求头数组Registry['APP_NAME'] -- 应用名称Registry['APP_ROOT'] -- 应用所在根目录Registry['APP_HOST'] -- 当前请求的 HOST 信息Registry['APP_PORT'] -- 当前请求的 PORT 信息Registry['VANILLA_ROOT'] -- VANIALLA 框架的根目录Registry['VANILLA_VERSION'] -- 当前所使用的 VANILLA 版本号Registry['VANILLA_APPLICATION'] -- 'vanilla.v.application' LUA 包Registry['VANILLA_UTILS'] -- 'vanilla.v.libs.utils' LUA 包Registry['VANILLA_CACHE_LIB'] -- 'vanilla.v.cache' LUA 包Registry['VANILLA_COOKIE_LIB'] -- 'vanilla.v.libs.cookie' LUA 包Registry['APP_BOOTS'] -- 应用 'application.bootstrap' LUA 包Registry['APP_PAGE_CACHE_CONF'] -- 应用 Page Cache 相关配置 注：上面很多全局变量是从 ngx.var. 获取来的结果缓存的，这样避免每次都请求 ngx.var 而减少这部分性能开销，并且其中有些信息比如 APP_NAME，APP_ROOT 等服务一经启动就不会更改，而像 `REQ_相关的数据则是每次请求都不一样，好在一次请求可能对这部分数据会多次调用，所以将其缓存在Registry` 表中* Vanilla 的內建函数 Vanilla 有很多内建的函数，这些函数有些来自于 Vanilla 框架本身功能性的一些 LUA 包中，比如 vanilla.v.controller、vanilla.v.request、vanilla.v.response 等，另一些比如通用的方法，比如 print_r、 page_cache 和 vanilla_init，再有比如 Vanilla 定义的各种包加载函数，列表如下： 1234567LoadLibrary -- 加载项目 library 路径下的 LUA 包LoadController -- 加载项目 controllerLoadModel -- 加载项目 model 路径下的包，包括 DAO 和 ServiceLoadPlugin -- 加载项目 plugins 路径下所定义的插件LoadApplication -- 加载项目 application 路径下的 LUA 包LoadApp -- 加载项目根目录下面的 LUA 包LoadV -- 加载 Vanilla 框架相关的 LUA 包 注：以上有些加载器功能重复，目的在于减短所传递参数的长度，比如加载 Index Controller， 使用 LoadController 方法是，只需要写 LoadController(&#39;index&#39;)， 而如果使用方法 LoadApp 则应该写成LoadApp(‘application.controllers.index’)` 方法 page_cache 该方法调用 Vanilla 封装的页面缓存逻辑，详细内容参见 (进阶/页缓存) 单步调试方法 print_r、sprint_r 等 调试系列方法主要为了开发时能清晰方便的查看变量状态，记录开发日志等功能，详细内容参见 (快速上手/如何调试) 方法 init_vanilla 方法 init_vanilla 主要完成框架基础功能的初始化，比如 Registry 的初始化，各种 Loader 的定义，页面缓存的实现等，本方法默认在应用请求处理入口的第一句语句执行 3、Libs3.1、Cookie3.1.1、Vanilla 中使用 CookieVanilla 中封装了 vanilla.v.libs.cookie 包，源至 lua-resty-cookie，提供了简单的 get、set、getAll 等方法来控制 Cookie，下面具体使用举例如下： vanilla.v.libs.cookie 包使用 一例胜千言： 1234567891011121314151617181920local IndexController = &#123;&#125;-- 载入 vanilla.v.libs.cookie 包local vcookie_lib = LoadV('vanilla.v.libs.cookie')function IndexController:index() -- 实例化 vanilla.v.libs.cookie 类 local cookie = vcookie_lib() -- 调用 set 方法，设置 cookie cookie:set('idevz', 'kkkk', &#123;expires=1000&#125;) cookie:set('idevz_api', 'kkkk', &#123;expires=1000,path='/'&#125;) -- 调用 getAll 方法，获取所有 cookie，也可以调用 get 获取单个cookie print_r(cookie:getAll()) do return '' endendreturn IndexController 注： vanilla.v.libs.cookie 支持以下 cookie 选项 1234567pathdomainmax_agesecurehttponlysamesiteextension 4、进阶4.1、页缓存4.1.1、Vanilla 的 Page Cachevanilla 的 Page Cache 实现了类似 Nginx 的 FastCGICache 或者 ProxyCache 的访问结果整体缓存，以 URI 的一定规则作为缓存的 KEY，属于内存型 Cache，存储位置可配置，默认存储在 OpenResty 共享字典（Share Dict）中，默认生成的项目中 Page Cache 为关闭状态 Page Cache 相关配置 Page Cache 相关的所有配置见项目的 config/application.lua 中， Appconf.page_cache 相关配置段，如下所示： 12345678Appconf.page_cache = &#123;&#125;Appconf.page_cache.cache_on = true-- Appconf.page_cache.cache_handle = 'lru'Appconf.page_cache.no_cache_cookie = 'va-no-cache'Appconf.page_cache.no_cache_uris = &#123; 'uris'&#125;Appconf.page_cache.build_cache_key_without_args = &#123;'rd'&#125; 配置释意 cache_on 缓存开关，true 为开启 Page Cache，false 则为关闭 cache_handle 设置 Page Cache 的存储介质，目前支持 Memcache、Redis、resty.lrucache、OpenResty Share Dict，默认为 OpenResty Share Dict no_cache_cookie 设置不缓存的 cookie KEY，Vanilla Page Cache 使用这个设置所指的 cookie KEY 来对某些特殊页面不缓存，默认当页面中有 KEY 为 va-no-cache 这个 COOKIE 的时候，当前页面不缓存 no_cache_uris 设置不缓存的 URI 列表，默认配置例如 http://app.com/uris 命中 uris 则，当前页面不缓存 build_cache_key_without_args 设置在缓存 KEY 中去除某些参数，比如某些 API 的版本号，或者随机数等，默认配置中的 rd 设置代表，当 URI 中有 rd 参数时，则生成的 Page Cache KEY 中清除这个参数 注：缓存的清理，只需要在请求的 URL 中，添加参数 vapurge 4.2、面向对象4.2.1、面向对象的 VanillaLua 提供了部分面向对象的语法糖，这仅仅能在开发中提供一个功能不完备的独立 Class 的使用，有 self 可以来引用 LUA 表的某些属性和方法，但是更多的面向对象特性，比如继承，比如类的构造等，LUA 支持的并不是非常好，日常的业务开发中，我们确实有些通用的逻辑可能需要复用，或者数据需要共享，需要有父子关系等等。所以我们在 Vanilla 中，简单封装了部分面向对象的特性，这里我们简单介绍其使用方法。 一个简单的 Vanilla 类 下面我们看一个例子： 类定义 12345678910111213local LibA = Class(\"LibA\")function LibA:idevzDo(params) local params = params or &#123; lib_bb = 'idevzDo LibA'&#125; return paramsendfunction LibA:__construct( data ) self.name = 'name--&gt;' .. data.name self.sex = 'sex--&gt;' .. data.sexendreturn LibA 代码释意： Class(&quot;LibA&quot;) 声明一个 Vanilla 类，类名为 LibA LibA:__construct( data ) 提供了一个类 LibA 的构造器，并对相应的属性进行初始化 类使用 123local LibA = LoadLibrary('aa')local liba_instance = LibA(&#123;name='idevz',sex='man'&#125;)print_r(liba_instance.sex) 执行结果 sex--&gt;man 代码释意：（类使用的时候需要注意，类的使用分为类文件的加载 Load( 如这里的 LoadLibrary ) 和实例化 LibA()） 两个步骤 local LibA = LoadLibrary(&#39;aa&#39;) 载入类名为 LibA 的类 local liba_instance = LibA({name=&#39;idevz&#39;,sex=&#39;man&#39;}) 传入表 {name=&#39;idevz&#39;,sex=&#39;man&#39;} 对类进行相关的实例化 liba_instance.sex 是对实例属性的引用 注：载入和实例化也可以一步达成 local liba_instance = LoadLibrary(&#39;aa&#39;)({name=&#39;idevz&#39;,sex=&#39;man&#39;}) 类继承 下面我么定义一个类 LibB，并使之集成于 LibA 类定义 123456789local LibB = Class(\"LibB\", LoadLibrary('LibA'))function LibB:__construct( data ) local data = data or &#123;name='kk', sex='xxx'&#125; data.sex = data.sex .. '--&gt;son' self.parent:__construct(data)endreturn LibB 代码释意： Class(&quot;LibB&quot;, LoadLibrary(&#39;LibA&#39;)) 声明一个 Vanilla 类，类名为 LibB 继承自类 LibA self.parent:__construct(data) 构造器中调用父类的构造器 类使用 123local LibB = LoadLibrary('LibB')local libb_instance = LibB(&#123;name='idevz',sex='man'&#125;)print_r(libb_instance:idevzDo(&#123;doo='xxx'&#125;)['doo']) 执行结果 xxx 代码释意： libb_instance:idevzDo 调用父类的 idevzDo 方法 4.3、Vanilla 包开发4.3.1、Vanilla 的包开发可以使用任意 LUA 包的开发方式来开发 Vanilla 包（Controllers，Library，Dao，Services等），也可以使用 Vanilla 所提供的 (面向对象) 方式进行开发 对 Controller 使用继承和构造器 下面我们看一个例子： 12345678local IndexController = Class('controllers.index', LoadApplication('controllers.base'))function IndexController:__construct() self.parent:__construct()endreturn IndexController 5、OpenResty5.1、OR文档精炼OR文档精炼 感谢春哥给我们带来这么好的平台，在这里希望能通读 OR 文档，把自己的理解记录下来，并与时俱进的更新 5.1.1、描述 / Descriptionlua-nginx-module 模块通过标准的 Lua 5.1 解释器，或者 LuaJIT 2.0/2.1 在 Nginx 运行环境中嵌入 Lua，并利用 Nginx 的子请求，允许在 Nginx 的时间模块中集成强大的 Lua 线程（Lua 协程）。 与 Apache 的 mod_lua 和 Lighttpd 的 mod_magnet 不同的是，只要使用 lua-nginx-module 模块为 Lua 提供的 Nginx API 来处理上游服务的请求，诸如 MySQL、PostgreSQL、Memcached、Redis 或者上游的 HTTP Web 服务，网络传输都是 100% 非阻塞的。 至少下面列举的这些 Lua 包，和 Nginx 模块可以与 ngx_lua 模块完美结合使用： 5.1.2、ngx.timer ngx.timer.at 语法： ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...) 上下文： init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua* 使用一个自定义函数以及可选的自定义参数创建一个 Nginx 计时器 第一个参数 delay 以秒为单位指定计时器的延迟时间，支持分秒设置，比如 0.001 在这里表示 1 毫秒延迟。delay 同样可以设置为 0 ，此时如果当前句柄正被唤醒则计时器将立即获得执行。（in which case the timer will immediately expire when the current handler yields execution.//TODO yields） 第二个参数 callback 可以是任何 Lua 函数，后期延迟时间到了，该函数将被以一个后台 “轻线程” 的形式被调用。这个自定义的回调函数将被 Nginx 核心使用 premature 参数、user_arg1、user_arg2 等参数自动调用，参数 premature 是一个 boolean 值，表示当前定时器是否过期以后，而 user_arg1、user_arg2 等参数就是调用 ngx.timer.at 时所传递的余下参数列表。 当 Nginx 工作进程尝试关闭，比如在 Nginx 由于收到 HUP 信号而触发了 Nginx 配置重载的时候，或者 Nginx 服务正在关闭的时候，将会出现无效的计时器（//TODO Premature timer）。当 Nginx 工作进程尝试关闭，将无法通过调用 ngx.timer.at 来创建一个新的非零延迟的计时器，并且此时 ngx.timer.at 将返回 nil 和 “process exiting” 错误。 这个 API 从 v0.9.3 版本开始，即使 Nginx 工作进程开始关闭的时候，仍然允许创建零延迟计时器。 当一个计时器到期时，计时器中用户定义回调的 Lua 代码将在一个与创建这个计时器的源请求完全隔离的 “轻线程” 中运行，所以，源请求生命周期内的对象，比如 cosockets 并不能与回调函数共享。 下面来看一个简单的例子： 1234567891011121314151617location / &#123; ... log_by_lua_block &#123; local function push_data(premature, uri, args, status) -- push the data uri, args, and status to the remote -- via ngx.socket.tcp or ngx.socket.udp -- (one may want to buffer the data in Lua a bit to -- save I/O operations) end local ok, err = ngx.timer.at(0, push_data, ngx.var.uri, ngx.var.args, ngx.header.status) if not ok then ngx.log(ngx.ERR, \"failed to create timer: \", err) return end &#125;&#125; 还可以创建一个无限执行的计时器，例如，一个每 5 秒触发执行一次的计时器，在它的回调方法中递归的调用 ngx.timer.at ，这里给出这样的一个例子。 12345678910111213141516171819local delay = 5local handlerhandler = function (premature) -- do some routine job in Lua just like a cron job if premature then return end local ok, err = ngx.timer.at(delay, handler) if not ok then ngx.log(ngx.ERR, \"failed to create the timer: \", err) return endendlocal ok, err = ngx.timer.at(delay, handler)if not ok then ngx.log(ngx.ERR, \"failed to create the timer: \", err) returnend 因为定时器的回调函数都是运行在后端，而且他们的运行时间不会叠加到客户端请求的相应时间中，它们可能会因为 Lua 语法错误，或者过多的客户端请求而很容易在服务端造成累积，或者耗尽系统资源。为了防止出现像 Nginx 服务器宕机这种极端结果，在一个 Nginx 工作进程中提供了对 “等待中的计时器” 和 “运行中的计时器” 这两种计时器的数量限制。这里 “等待中的计时器” 是指还没有过期的计时器，而 “运行中的计时器” 是指那些用户回调方法当前正在运行的计时器。 一个 Nginx 进程中所允许的 “等待中的计时器” 允许的最大数量由 lua_max_pending_timers 指令控制。而允许的 “运行中的计时器” 允许的最大数量由 lua_max_running_timers 指令控制。 目前的实现，每个 “运行中的计时器” 都会从 nginx.conf 配置中 worker_connections 指令配置的全局连接列表中占用一个 （虚） 连接记录，所以必须确保 worker_connections 指令设置了一个足够大的值能同时包含真正的连接数和计时器回调函数运行所需要的虚连接数（这个连接数是有 lua_max_running_timers 指令设限的）。 许多 Nginx 的 Lua API 能在计时器回调函数的上下文中使用，比如操作流和数据包的 cosockets API（ngx.socket.tcp 和 ngx.socket.udp），共享内存字典（ngx.shared.DICT），用户协程函数（coroutine.*），用户“轻线程”（ngx.thread.*），ngx.exit，ngx.now/ngx.time，ngx.md5/ngx.sha1_bin等都是可用的，但是相关子请求的 API （诸如ngx.location.capture），ngx.req.* API，下游输出 API （诸如 ngx.say，ngx.print 和 ngx.flush）都是明确在此上下文中不支持的。 你可以给计时器的回调函数传递大部分的标准 Lua 值类型（nils、布尔、数字、字符串、表、闭包、文件句柄等），要么显示的使用用户参数或者隐式的使用回调函数闭包的上游值。然而有一些例外诸如：你不能传递任何由 coroutine.create 和 ngx.thread.spawn 返回的线程对象，或者任何由 ngx.socket.tcp、ngx.socket.udp 和 ngx.req.socket 返回的 cosocket 对象，因为这些对象的生命周期是与创建他们的请求上下文绑定的，而计时器的回调函数（设计时）是与创建他们的请求上下文分离的，并且运行在它自己的（虚）请求上下文中。如果你试图跨越创建这些线程和 cosocket 的请求上下文边界来共享这些线程和 cosocket 对象，将会报错，对线程将报错 no co ctx found，对 cosocket 将报错 bad request，然而在计时器回调函数内部来创建这些对象则是没问题的。 这个 API 在 v0.8.0 版本第一次释出。 ngx.timer.running_count 语法： count = ngx.timer.running_count() 上下文： init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua* 返回当前正在运行的计时器数量。这个指令在 v0.9.20 版本第一次释出。 ngx.timer.pending_count 语法： count = ngx.timer.pending_count() 上下文： init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua* 返回当前正在等待的计时器数量。这个指令在 v0.9.20 版本第一次释出。 5.1.3、ngx.config ngx.config.subsystem 语法： subsystem = ngx.config.subsystem 上下文： set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua* 这个字符串字段表示了当前基于哪个 Nginx 子系统，对当前模块（ngx_stream_lua_module），这个字段始终返回 “http”，而对 ngx_stream_lua_module 模块，这个字段将返回 “stream” 这个字段在 v0.10.1 版本第一次释出。 ngx.config.debug 语法： debug = ngx.config.debug 上下文： set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua* *这个布尔字段表示了当前 Nginx 是否打开 debug 编译选项，如编译时配置为 ./configure option --with-debug。 这个字段在 v0.8.7 版本第一次释出。 5.1.4、coroutine coroutine.create 语法： co = coroutine.create(f) 上下文： rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua* 使用 Lua 函数创建一个用户态 Lua 协程， 并返回一个协程对象。与标准 Lua 中的协程创建的 API coroutine.create 类似，但是工作在 ngx_lua 模块创建的 Lua 协程上下文中，这个 API 第一次是被使用在 0.9.2 版本的 `init_by_lua` 上下文中。* 这个 API 在 v0.6.0 版本第一次释出。 5.1.5、ngx.thread ngx.config.subsystem 语法： co = ngx.thread.spawn(func, arg1, arg2, ...) 上下文： rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua* 使用 Lua 函数 func 以及可选的参数 arg1，arg2 等生成一个新的用户“轻线程”，返回一个 Lua 线程（或者 Lua 协程）对象代表这个 “轻线程”“轻线程”仅仅是一种特殊的由 ngx_lua 模块来调度的 Lua 协程。在 ngx.thread.spawn 返回之前， func 函数将会被使用响应的可选参数进行调用，直到此函数调用返回、或者因为错误而终止或是因为通过使用 Nginx 的 I/O 操作 API 导致请求挂起（如 tcpsock:receive 操作）。在 ngx.thread.spawn 返回后，新被创建的“轻线程”将在各种 I/O 事件中保持通常的异步运行。 所有在 rewrite_by_lua、access_by_lua 和 content_by_lua 运行的 Lua 代码块都在一个由 ngx_lua 自动创建的样板“轻线程”中，这些样板“轻线程”通常又叫“入口线程”。 默认情况下，相应的 Nginx 处理程序（例如 rewrite_by_lua 处理程序）不会终止直到“入口线程”和所有的用户“轻线程”都终止，一个“轻线程（要么是“入口线程”要么是“用户轻线程”因为调用 ngx.exit，ngx.exec，ngx.redirect 或者 ngx.req.set_uri(uri, true)）或者“入口线程”因为报错而终止。当一个用户“轻线程”因为报错而终止，他将不会像“入口线程”一样终止其他线程的运行。 因为 Nginx 子请求模块的限制，一般不允许中止一个正在运行中的 Nginx 子请求。所以同样禁止中止一个运行中的正在等待一个或多个 Nginx 子请求的“轻线程”。你应该调用 ngx.thread.wait 来在结束前等待这些“轻线程”结束。这里有个值得注意的例外是你可以通过使用而且只能使用 ngx.ERROR(-1),408,444或者499 状态调用 ngx.exit 来中止等待的子请求。 “轻线程”不是使用预先抢占的方式来调度的，换句话说，没有自动执行的时间片，一个“轻线程”将保持在 CPU 运行，直到一个（非阻塞）I/O 操作在一个单线程运行不能被完成。 The “light threads” are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A “light thread” will keep running exclusively on the CPU untila (nonblocking) I/O operation cannot be completed in a single run,it calls coroutine.yield to actively give up execution, orit is aborted by a Lua error or an invocation of ngx.exit, ngx.exec, ngx.redirect, or ngx.req.set_uri(uri, true).For the first two cases, the “light thread” will usually be resumed later by the ngx_lua scheduler unless a “stop-the-world” event happens. User “light threads” can create “light threads” themselves. And normal user coroutines created by coroutine.create can also create “light threads”. The coroutine (be it a normal Lua coroutine or a “light thread”) that directly spawns the “light thread” is called the “parent coroutine” for the “light thread” newly spawned. The “parent coroutine” can call ngx.thread.wait to wait on the termination of its child “light thread”. You can call coroutine.status() and coroutine.yield() on the “light thread” coroutines. The status of the “light thread” coroutine can be “zombie” if the current “light thread” already terminates (either successfully or with an error),its parent coroutine is still alive, andits parent coroutine is not waiting on it with ngx.thread.wait.The following example demonstrates the use of coroutine.yield() in the “light thread” coroutines to do manual time-slicing:","tags":[{"name":"Lua","slug":"Lua","permalink":"https://www.shengguocun.com/tags/Lua/"},{"name":"Vanilla","slug":"Vanilla","permalink":"https://www.shengguocun.com/tags/Vanilla/"},{"name":"中文文档","slug":"中文文档","permalink":"https://www.shengguocun.com/tags/中文文档/"}]},{"title":"Nginx初探","date":"2018-08-01T10:51:04.000Z","path":"/blog/2018/08/01/nginx-book/","text":"","tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.shengguocun.com/tags/Nginx/"},{"name":"基础概念","slug":"基础概念","permalink":"https://www.shengguocun.com/tags/基础概念/"}]},{"title":"基于Go语言的简易基金定投系统","date":"2018-05-18T13:30:07.000Z","path":"/blog/2018/05/18/automatic-investment-plan-by-golang/","text":"0、前言在平时基金定投的过程中，因为各家基金公司的系统定投系统功能太过单一，即使定期不定额的方式也不能满足多个梯度的自定义的需求，只能设置高于成本某个阈值或者低于成本某个阈值设置相应的定投值；但是我们想有梯度的定投而不是简单的三个点。为了满足当前我的简单的需求（希望能够有更灵活的自定义定投设置），靠人不如靠自己，下面就开始吧。 1、概念介绍净值估算净值估算每个交易日9：30-15：00盘中实时更新（QDII基金为海外交易时段），是按照基金持仓、指数走势和基金过往业绩估算，估算数据并不代表真实净值，仅供参考，请以基金管理人披露净值为准。 指数温度指数温度 = ( PE + PB ) / 2 PEPE就是我们一般所说的市盈率，即每股股价与每股收益的比率．用来反映投资该股票的风险，一般来说比率越低越安全； PBPB即市净率。市净率 = 股票市价 / 每股净资产，市净率越低的股票，其投资价值越高。","tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://www.shengguocun.com/tags/Go语言/"},{"name":"基金","slug":"基金","permalink":"https://www.shengguocun.com/tags/基金/"},{"name":"定投","slug":"定投","permalink":"https://www.shengguocun.com/tags/定投/"}]},{"title":"A Bite of Golang","date":"2018-04-20T06:54:03.000Z","path":"/blog/2018/04/20/a-bite-of-golang/","text":"0. 前言A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些小的经验，同时为了方便让读者了解到Go语言中的一些概念，文中包含了许多快速简洁的例子，读者后期可以去自行拓展。当然写这篇文章的灵感来源于GitHub上的 a bite of Python 1. 基础1.0、环境搭建1、下载安装包安装通过浏览器访问下面的地址 https://golang.org/dl/ 要是自己的网络不能翻墙的话，可以访问下面的Go语言中文网 https://studygolang.com/dl 下载指定的版本的安装包直接下一步就可以安装完成； 2、命令行安装Mac 利器 home brew 安装 go 1234brew update &amp;&amp; brew upgradebrew install gitbrew install mercurialbrew install go 安装完成之后 1vim ~/.bashrc 1234567891011#GOROOTexport GOROOT=/usr/local/Cellar/go/1.7.4/libexec#GOPATHexport GOPATH=$HOME/GoLangProject#GOPATH binexport PATH=$PATH:$GOPATH/bin#GOPATH root binexport PATH=$PATH:$GOROOT/bin 1source ~/.bashrc OK配合完成之后,输入go env验证一下是否配置成功 123456789101112131415~ sheng$ go envGOARCH=\"amd64\"GOBIN=\"\"GOEXE=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOOS=\"darwin\"GOPATH=\"/Users/verton/GoLangProject\"GORACE=\"\"GOROOT=\"/usr/local/Cellar/go/1.7.4/libexec\"GOTOOLDIR=\"/usr/local/Cellar/go/1.7.4/libexec/pkg/tool/darwin_amd64\"CC=\"clang\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/z2/h48yrw8131g824_bvtw6584r0000gn/T/go-build415367881=/tmp/go-build -gno-record-gcc-switches -fno-common\"CXX=\"clang++\"CGO_ENABLED=\"1\" 1.1、变量定义1、通过var关键字12var a intvar b string 在Go语言中在定义变量的时候，是变量在前类型在后，现在你暂时先不用考虑那么多为什么，就先知道Go是这样的定义形式就可以了；当然可以多个变量一起定义,同时可以一起赋初值 1234567var a,b,c boolvar m,n string = \"Hello\",\"World\"var ( aa = 1 bb = \"hello world\" cc = true) 当然也可以让编译器自动决定类型，比如 1var s,m,p,q = 1,\"hahah\",false,\"xixiix\" 2、使用 := 定义变量1s,m,p,q := 1,\"hahah\",false,\"xixiix\" 这样呢可以让代码写的更加简短一点，当然呢 := 只能在函数内使用，是不能在函数外使用的。（相关的函数的知识后面会做介绍） 1.2、内建变量类型1、bool 、string这两个类型就不做过多的介绍，因为基本每一门语言里面都有这两个类型，在Go语言里面也是一样的 2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr上面这些就是Go的整数类型，加u和不加u的区别就是有无符号的区别，Go语言中的整数类型还分为两个大类，一个是规定长度的，比如：int8、int16、int32…，还有一种就是不规定长度的，它是根据操作系统来，在32位系统就是32位，在64位系统就是64位的，Go语言中没有int、long 这些类型，你想要定义一个相对较长的定义int64就可以了，最后uintptr就是Go语言的指针，后面我会再来介绍它 3、byte、runebyte就不用过多介绍了，大家都知道字节类型，那rune是什么呢，这就是Go语言的“char”，因为char只有一个字节在使用中会有很多的坑，Go语言针对这点痛点做了一些优化 4、float32、float64、complex64、complex128前面两个不过多介绍，浮点数类型32位和64位的，后面两个是一个复数的类型，complex64实部和虚部都是32位的，complex128实部和虚部都是64位的 1.3、常量与枚举123456const a = 1const b,c = 2,3const ( d = 5 e,f = 6,7) 常量数值可以作为各种类型使用,比如以下代码 123var s,p = 3,4m := math.Sqrt(s*s + p*p)fmt.Println(m) 这段代码语法是编译不通过的，因为Sqrt的参数必须是一个浮点数类型；但是呢我们把是s、p定义成常量就可以编译通过了 123const s,p = 3,4m := math.Sqrt(s*s + p*p)fmt.Println(m) Go语言中的枚举类型就是通过const来实现，同时Go语言中还可以通过iota实现自增的功能 123456789func enums()&#123; const ( a = iota b c ) fmt.Println(a, b, c)&#125; 调用上面这个函数显而易见，会输出 10 1 2 1.4、条件语句1、if正常的条件判断我这边就不做过多的介绍，当然Go语言有它特别的地方，if的条件里可以赋值，比如： 举个读文件的例子，ioutil.ReadFile 这个方法有两个返回值，后面会详细的讲解，常规的写法是 1234567const filename = \"file.txt\"content,err := ioutil.ReadFile(filename)if err != nil &#123; fmt.Println(err)&#125;else &#123; fmt.Println(string(content))&#125; Go语言可以整合成下面的写法 123456const filename = \"file.txt\"if content,err := ioutil.ReadFile(filename); err != nil &#123; fmt.Println(err)&#125;else &#123; fmt.Println(string(content))&#125; 2、switch123456789101112131415161718func eval(a int, b int, op string) int &#123; var result int switch op &#123; case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported op\") &#125; return result&#125; 看上面的这段代码，你发现和别的语言不一样的地方是怎么没有break，是的，Go语言中switch会自动break，除非使用fallthrough 同时，Go语言的switch还有另外一种写法，结合一个最常见的Switch用法举个例子吧，比如通过考试分数判断是否合格 123456789101112131415func grade(score int) string &#123; switch &#123; case score &gt; 100 || score &lt; 0: panic(\"Wrong score\") case score &gt; 80: return \"A\" case score &gt; 70: return \"B\" case score &gt; 60: return \"C\" default: return \"D\" &#125;&#125; 上面的一个写法可以发现switch后面是可以没有表达式的 1.5、循环1、forfor关键字和其他语言有着共同的功能，同时还充当的Go语言中的 while 功能，Go语言中没有 while 关键字 123for scanner.Scan() &#123; fmt.Println(scanner.Text())&#125; 上面的循环代码省略了起始条件，省略了递增条件，就跟while的功能非常的类似 123for &#123; fmt.Println(\"hello world\")&#125; 上面其实就是一个死循环，因为Go语言中经常会用到，后面的并发编程 Goroutine 的时候还会给大家继续介绍。 1.6、函数1、普通函数普通的函数定义我这边不再过多阐述，跟变量定义类似，函数名在前，函数返回类型在后 2、多返回值这个是Go语言的不一样的地方，函数可以有多个返回值，比如 ioutil.ReadFile 这个函数就是有两个返回值，但是呢多返回值不要滥用，尽量贴合Go语言的风格，常规返回值和一个error，那我门这边可以将上面的加减乘除的例子做一下改造，因为panic之后程序就会终止了，我们可以将错误信息直接返回出来，让程序继续执行 12345678910111213141516func eval(a int, b int, op string) (int, error) &#123; switch op &#123; case \"+\": return a + b, nil case \"-\": return a - b, nil case \"*\": return a * b, nil case \"/\": return a / b, nil default: return 0, fmt.Errorf(\"unsupported op\") &#125;&#125; 3、函数可作为参数123func apply(op func(int, int) int, a, b int) int &#123; return op(a, b)&#125; Go语言定义这种函数在前，参数在后的复合函数非常的方便，只需要apply一个函数就可以了，当然在现实的过程中有时候也会了偷下懒，相关的op函数就直接写成一个匿名函数了 1234fmt.Println(\"sub(3, 4) is:\", apply( func(a int, b int) int &#123; return a - b &#125;, 3, 4)) 这样也是OK的 4、没有默认参数、没有可选参数Go语言中没有其他语言类似Lambda这种很花哨的用法，除了一个可变参数列表 1234567func sum(numbers ...int) int &#123; s := 0 for i := range numbers &#123; s += numbers[i] &#125; return s&#125; 上面就是一个参数求和函数 1.7、指针1、指针不能运算比如想对指针做加1运算，Go语言是不支持的；当然要是想在函数内部改变函数外面的变量的值，通过指针是如何实现的呢，如下图所示 2、Go语言只有值传递Go语言中想要改变变量的值，只能传一个指针进去，比如常见 a b 两个变量的值交换 123func swap(a, b int) &#123; *a, *b = *b, *a&#125; 当然呢，交换参数值是不建议上面的写法的 2. 内建容器2.0、数组1、定义1234var arr1 [5]intarr2 := [3]int&#123;1, 3, 5&#125;arr3 := [...]int&#123;2, 4, 6, 8, 10&#125;var grid [4][5]int 数组的定义和变量的定义类似，数组名在前类型在后；常规的遍历操作也是类似 123for i, v := range arr &#123; fmt.Println(i, v)&#125; i 是数组的下标，v是数组的值 2、数组是值类型和上面值传递的概念类似，通过传参在函数内部是改变不了数组的值的;当然要是想改变相关的数组的值，可以通过指针来改变的。接下来的Slice可以直接解决上述的问题。 2.1、Slice(切片)的概念1、Slice定义Slice是什么呢？其实呢就是数组的一个View（视图），先来段代码热个身 1234arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;fmt.Println(\"arr[2:6] =\", arr[2:6])fmt.Println(\"arr[:6] =\", arr[:6]) 结果输出： 12arr[2:6] = [2 3 4 5]arr[:6] = [0 1 2 3 4 5] 从上面的输出结果可以直接的看出，arr加一个下标区间都叫做Slice，Slice的区间是一个左闭右开的区间当然我们还需要知道一个概念，Slice是没有数据的，是对底层Array的一个View，如何理解这个概念呢？简单的用一个例子来理解它 1234567891011121314151617181920212223242526package mainimport \"fmt\"func updateSliceData(s []int) &#123; s[0] = 666&#125;func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; s1 := arr[2:] fmt.Println(\"s1 =\", s1) s2 := arr[:] fmt.Println(\"s2 =\", s2) fmt.Println(\"更新Slice数据 s1\") updateSliceData(s1) fmt.Println(s1) fmt.Println(arr) fmt.Println(\"更新Slice数据 s2\") updateSliceData(s2) fmt.Println(s2) fmt.Println(arr)&#125; 结果输出为： 12345678s1 = [2 3 4 5 6 7]s2 = [0 1 2 3 4 5 6 7]更新Slice数据 s1[666 3 4 5 6 7][0 1 666 3 4 5 6 7]更新Slice数据 s2[666 1 666 3 4 5 6 7][666 1 666 3 4 5 6 7] 2、ReSlice就是在一个Slice上进一步slice，比如 1234arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;ss := arr[:6]ss = ss[:5]ss = ss[2:] 结果输出： 12[0 1 2 3 4][2 3 4] 3、Slice拓展首先我们先看一个例子 123arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;s1 := arr[2:6]s2 := s1[3:5] 大家或许会有疑问，这个s2不会报错么，要是不报错结果又是多少呢？ 12[2 3 4 5][5 6] 答案是可以，上述就是s1、s2的值，是不是跟你想的有点不一样。那么这又是为什么呢？ 这就是为什么能把 6 这个值取出来的原因，因为slice是array的底层的一个view，是不是依然还是有点懵，具体又是如何实现的呢？ 4、Slice实现 从上图是不是大体明白为什么上面那个例子能把6取出来了；看到这里大家也能大体明白Slice内部的ptr、len、cap是什么意思，ptr指向slice的开头的元素，len是slice的长度，cap代表底层的array从ptr开始到结束的长度，Slice是可以向后扩展的，但是不能向前扩展，所以只要不超过cap的长度slice都是可以扩展的，但是常规的s[i]取值是不可以超过len的。用一个例子来简单的理解一下 123arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;s1 := arr[2:6]fmt.Printf(\"len(s1): %d ; cap(s1): %d \", len(s1), cap(s1)) 输出结果： 1len(s1): 4 ; cap(s1): 6 2.2、Slice(切片)的操作1、向Slice添加元素12345s3 := append(s2, 8)s4 := append(s3, 9)s5 := append(s4, 10)fmt.Println(\"s3, s4, s5 =\", s3, s4, s5)fmt.Println(\"arr =\", arr) 上面的这个例子打印出来结果又是多少呢？ 12s3, s4, s5 = [5 6 8] [5 6 8 9] [5 6 8 9 10]arr = [0 1 2 3 4 5 6 8] 上面的9 ，10为什么不见了呢？因为Go语言在append数据超过cap长度的时候会分配一个更长的数组，如果arr不再使用的话就会被垃圾回收掉。在append的过程中，由于是值传递的关系，len、cap都有可能会改变，所以呢必须要用一个新的slice来接收这个slice，通常会写成 1s = append(s, value1) 2、创建slice当然slice也可以直接通过var关键字创建 1var s []int 这样创建的slice的初始值就是nil，别的语言中的null的意思，当然也是可以赋初值的，比如： 1s1 := []int&#123;2, 4, 6, 8&#125; 就上面的Zero Value的Slice的情况，要是我这个时候对这个slice进行append操作会怎么样呢？这个slice的内部的len以及cap又是如何变化的呢？ 12345var s []intfor i := 0; i &lt; 100; i++ &#123; fmt.Printf(\"%v, len = %d, cap = %d\\n\", s, len(s), cap(s)) s = append(s, 2*i+1)&#125; 结果我就不输出了，因为相对太长，我把相应的结果总结一下，就是len就是一个步长为1由1增至100，cap呢？当系统发现不够存储的时候会分配一个现有长度两倍的空间。 当然在实际生产过程中，大多是使用的make关键字来创建slice的 12s2 := make([]int, 4)s3 := make([]int, 8, 16) 3、Copy Slice数据1func Copy(dst Writer, src Reader) (written int64, err error) 文档中可以看的很清晰，直接将第二个参数直接拷贝进第一个参数 1234s1 := []int&#123;2, 4, 6, 8&#125;s2 := make([]int, 16)copy(s2, s1)fmt.Println(s2) 结果输出 1[2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0] 4、Slice删除元素123s1 := []int&#123;2, 4, 6, 8&#125;s2 := make([]int, 16)copy(s2, s1) 比如我要删除 s2 中的第 3 个元素该如何操作呢？ 1s2 = append(s2[:2], s2[3:]...) 当然现实的使用中还会从slice中pop一个值出来，下面分别演示一下从s2头部pop和从s2尾部pop数据 12front := s2[0]s2 = s2[1:] 12tail := s2[len(s2)-1]s2 = s2[:len(s2)-1] 2.3、Map1、创建map12var m1 map[string]intm2 := make(map[string]int) 上述就是常见的创建map的方式，但是m1、m2还是有区别的，m1是nil，m2是一个空map;常规的遍历map也是用 range 的方式就可以， 123for k, v := range m &#123; fmt.Println(k, v)&#125; 当然细心的会发现，在遍历的过程中是不能保证顺序的，当然要是想顺序遍历，需要自己手动对key进行排序，可以将key存进slice，然后再通过slice遍历相关的key获取map的值。 2、获取map元素m[key] 一般就是这样获取map的值 123456789var map1 = map[string]string&#123; \"name\" : \"shengguocun\", \"gender\" : \"male\", \"city\" : \"hangzhou\",&#125;value1 := map1[\"age\"]fmt.Println(value1) 先来猜测一下，上述这段代码可以运行么？会不会报错？ 答案是不会，这就是Go语言和别的语言不一样的地方，上述的例子中 value1 的值是一个空字符串，map中当key不存在时，会获取value类型的初始值。 1234567gender, ok := map1[\"gender\"]if ok &#123; fmt.Println(\"Gender 的值为 : \", gender)&#125;else &#123; fmt.Println(\"Key 不存在\")&#125; 既然Go语言的出现就是为了解决别的语言的痛点，所以在使用过程中不再需要每次获取某个 key 的时候都要去 isset 判断一下，Go的获取map的值的时候第二个返回值就是别的语言 isset 的功能；存在返回 true ，不存在返回 false。 3、删除元素delete函数，就可以直接删除指定的key的值 这是Go语言的官方文档，不难理解比如要删除上面的 map1 的 city 的值 1delete(map1, \"city\") 直接调用就可以 4、map的key为什么要把key单独拿出来说呢？因为map底层使用的是hash表，所以map的key必须可以比较相等；换句话说就是除了 slice、map、function的内建类型都可以作为key。 2.4、字符和字符串处理1、rune介绍rune就是Go语言的字符串类型，其实可以理解为是 int32 的一个別名，下面我们通过例子来深入理解一下rune 1234567891011121314s1 := \"你好,杭州\"fmt.Println(s1)for _, ch := range []byte(s1) &#123; fmt.Printf(\"%X \", ch)&#125;fmt.Println()for i, ch := range s1 &#123; fmt.Printf(\"(%d %X) \", i, ch)&#125; 输出结果 123你好,杭州E4 BD A0 E5 A5 BD 2C E6 9D AD E5 B7 9E(0 4F60) (3 597D) (6 2C) (7 676D) (10 5DDE) 从上述的例子我们可以直接的看出来，其实就是将UTF-8编码解码，然后再转成Unicode之后将它存放进一个rune（int32）中 2、字符串处理UTF-8编码的rune长度统计 12count := utf8.RuneCountInString(s1)fmt.Println(\"Rune Count :\", count) 输出结果为： 1Rune Count : 5 字符串的输出操作 123456bytes := []byte(s1)for len(bytes) &gt; 0 &#123; ch, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf(\"%c \", ch)&#125; 用rune实现上述同样的功能 123for _, ch := range []rune(s1) &#123; fmt.Printf(\"%c \", ch)&#125; 3. 面向“对象”3.0、结构体和方法1、结构体的创建go语言仅支持封装，不支持继承和多态；这句话怎么理解呢？就是说在Go语言内部没有class，只有struct；也没有复杂的继承和多态，那继承和多态的任务又是通过什么实现的呢？Go是面向接口编程，可以通过接口来实现继承和多态的相关的任务，后面我会再进行介绍。下面先来介绍一下struct的创建： 1234type Node struct &#123; Value int Left, Right *Node&#125; 通过type、struct关键字创建结构体类型，当然在创建了结构体类型之后，就可以创建相关类型的变量 12345var root tree.Noderoot = tree.Node&#123;Value:1&#125;root.Value = 2root.Left = &amp;tree.Node&#123;Value:3&#125;root.Right = &amp;tree.Node&#123;&#125; 2、方法创建结构体的方法的创建和普通的函数创建没有太大的区别，只是在方法名前面添加一个接收者，就相当于其他语言的this 123func (node Node) Print() &#123; fmt.Print(node.Value, \" \")&#125; 上述就是一个值接收者打印出Node的Value的值的方法。当然要是需要改变Value的值的时候，就需要一个指针接收者。 123func (node *Node) SetValue(value int) &#123; node.Value = value&#125; 有一个疑问，要是对一个值为nil的Node进行 SetValue 操作会发生什么？ 12var pRoot *tree.NodepRoot.SetValue(1) 虽说nil指针可以调用方法，但是下面的Value是拿不到，自然就会报下面的错了 12345panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x20c3]goroutine 1 [running]:panic(0x8f100, 0xc42000a070) 实际使用过程中可以添加相关的判断在做处理。结合上面的知识我们不难写出一个树的遍历的方法的代码 123456789func (node *Node) Traverse() &#123; if node == nil &#123; return &#125; node.Print() node.Left.Traverse() node.Right.Traverse()&#125; 3.1、包和封装1、命名规范 名字一般使用 CamelCase（驼峰式） 首字母大写：Public 首字母小写：Private 2、包的概念 每个目录一个包，但是包名和目录名不一定要一样的，但是每个目录只能包含一个包； main包是一个相对特殊的，main包包含一个可执行入口； 为结构体定义的方法必须放在同一个包内 当然上面的例子已经在不经意间提前引入了package的概念 3.2、扩展已有类型在面向对象中，我们想要扩展一下别人的类，我们通常继承一下就好了，但是Go语言中没有继承的概念，我们该如何处理呢？ 1、定义别名（1.9新特性）在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型 基本语法就是： 1type identifier = Type 比如内建的byte类型，其实是uint8的类型别名，而rune其实是int32的类型别名。 12345678// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is// used, by convention, to distinguish byte values from 8-bit unsigned// integer values.type byte = uint8// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values.type rune = int32 通过别名的方式就可以拓展了，比如 12345678910111213type T1 struct&#123;&#125;type T3 = T1func (t1 T1) say()&#123;&#125;func (t3 *T3) greeting()&#123;&#125;func main() &#123; var t1 T1 // var t2 T2 var t3 T3 t1.say() t1.greeting() t3.say() t3.greeting()&#125; 当然要是T1也定义了 greeting 的方法，那么编译会报错的，因为有重复的方法定义。 2、使用组合比如我们想扩展上面的树的包，实现一个自己的中序遍历，该如何实现呢？通过代码来理解一下使用组合的概念 123456789101112131415type myNode struct &#123; node *tree.Node&#125;func (myNodeNode *myNode) Traverse() &#123; if myNodeNode == nil || myNodeNode.node == nil &#123; return &#125; left := myNode&#123;myNodeNode.node.Left&#125; right := myNode&#123;myNodeNode.node.Right&#125; left.ownFunc() myNodeNode.node.Print() right.ownFunc()&#125; 3.3、GOPATH以及目录结构 默认在 ～／go 目录下（unix或者Linux环境），%USERPROFILE%\\go 目录下（windows环境） 官方推荐：所有的项目和第三方库都放在同一个GOPATH下 当然也可以将每个项目放在不同的GOPATH下 如何查看自己的GOPATH呢？ 12~ sheng$ echo $GOPATH/Users/verton/GoLangProject 1、go get获取第三方库1go get url 这样是可以获取GitHub上面的三方的库，但是Golang.org上面要是不能翻墙是获取不了的，这里我给大家介绍一个新的工具 gopm 1sheng$ go get github.com/gpmgo/gopm 一行命令就可以装好了，这个时候再get三方的库就毫无压力了，因为这个国内有相关的镜像 1gopm get -g url 采用-g 参数，可以把依赖包下载到GOPATH目录中 2、目录结构 src git repo 1 git repo 2 pkg git repo 1 git repo 2 bin 执行文件 1 2 从上述的目录结构上我们可以看出来，src pkg 是对应的，src 是我们的代码的位置以及三方库的位置，pkg 是build的中间过程，可以暂时先不用关注，bin下面就是可执行文件。 4. 面向接口4.0、Duck Typing的概念很多语言都有duck typing的概念， 用一个简单的例子来描述一下这个概念 大黄鸭是鸭子么？这个答案是要看基于什么角度来看，从生物角度来看，那它当然不是鸭子，连基本的生命都没有；但是从duck typing的角度来看它就是一个鸭子，因为它外部长得像鸭子，通俗点概括一下duck typing的概念就是：描述事物的外部行为而非内部结构。 从严格意义上讲，go语言只能说是类似duck typing，go语言不是动态绑定的，go语言是编译时绑定的。 4.1、接口的定义和实现在Go语言中，接口interface其实和其他语言的接口意思也没什么区别。一个结构体必须实现了一个接口的所有方法，才能被一个接口对象接受，这一点和Java语言中的接口的要求是一样的。interface理解其为一种类型的规范或者约定。 1、接口的定义123type Retriever interface&#123; Get(url string) string&#125; 这样就定义了一个接口，它包含一个Get函数。 2、接口的实现现在我们就来实现一下这个接口。比如我们做一个拉取某个页面的操作 123456789101112131415161718192021222324package rickimport ( \"net/http\" \"net/http/httputil\")type Retriever struct &#123;&#125;func (r Retriever) Get(url string) string &#123; resp, err := http.Get(url) if err != nil &#123; panic(err) &#125; result, err := httputil.DumpResponse(resp, true) resp.Body.Close() if err != nil &#123; panic(err) &#125; return string(result)&#125; 123456789101112131415161718192021package mainimport ( \"shengguocun.com/retriever/rick\" \"fmt\")type Retriever interface&#123; Get(url string) string&#125;func download(r Retriever) string &#123; return r.Get(\"http://www.shengguocun.com\")&#125;func main() &#123; var r Retriever r = rick.Retriever&#123;&#125; fmt.Println(download(r))&#125; 上述rick.Retriever就实现了Retriever接口。 4.2、接口值的类型1、接口变量里面有什么继续使用上面的例子 1234var r Retrieverr = rick.Retriever&#123;&#125;fmt.Printf(\"\\n %T %v \\n\", r, r) 会输出什么呢？ 1rick.Retriever &#123;&#125; 这就是常规的值传递，没有什么特别的地方。要是 Retriever 这个struct很大，我们不希望通过传值的方法去拷贝，而是通过指针访问Get方法。 12345678910111213func (r *Retriever) Get(url string) string &#123; resp, err := http.Get(url) if err != nil &#123; panic(err) &#125; result, err := httputil.DumpResponse(resp, true) resp.Body.Close() if err != nil &#123; panic(err) &#125; return string(result)&#125; 1234var r Retrieverr = &amp;rick.Retriever&#123;&#125;fmt.Printf(\"\\n %T %v \\n\", r, r) 这时候的Type、Value又是什么？ 1*rick.Retriever &amp;&#123;&#125; 我们可以看到是一个指针，所以我们一般用到接口的指针，因为它的肚子里含有一个指针，通常我们会说“接口变量自带指针”，那我们现在用两个图来总结一下上面的概念 概括为：接口变量里面可以是实现者的类型和实现者的值，或者是接口类型里面可以是实现者的类型和实现者的指针，同时指向实现者。 2、查看接口变量说到这里要提到一个特殊的接口，空接口 interface{} ，对于空接口 interface{} 其实和泛型的概念很像，任何类型都实现了空接口。在方法需要返回多个类型的时候，返回值的类型我们一般定义为 interface{} 。 这时我们现在引入获取接口变量肚子里的类型的另外一种写法，叫 Type Assertion（断言）。比如 12var a interface&#123;&#125;fmt.Println(\"Are you ok?\", a.(string)) 然而上述的写法一旦断言失败，会报出panic错误，当然这样的程序就显得十分的不友好。我们需要在断言前进行一个判断。 123456value, ok := a.(string)if !ok &#123; fmt.Println(\"断言失败，这不是一个string类型\") return&#125;fmt.Println(\"值为：\", value) 另外我们可以结合switch进行类型判断 12345678var r interface&#123;&#125;r = balabalaFunction()switch v := r.(type) &#123; case bool: fmt.Println(\"type bool...\") case int: fmt.Println(\"type int...\")&#125; Tips:转换类型的时候如果是string可以不用断言，使用fmt.Sprint()函数可以达到想要的效果。 4.3、接口的组合1、定义什么叫接口的组合？当然这就是它的字面上的意思，接口可以组合其他的接口。这种方式等效于在接口中添加其他的接口的方法。在系统函数中就有很多这样的组合，比如：ReadWriter 12345// ReadWriter is the interface that groups the basic Read and Write methods.type ReadWriter interface &#123; Reader Writer&#125; 在常见的读写文件的时候，网络相关以及一些底层的东西经常会遇到 Reader 、Writer 2、实例演示为了更好的理解接口的组合的概念，下面用一个简单的例子来进一步了解 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 定义Reader接口type Reader interface &#123; read()&#125;// 定义Writer接口type Writer interface &#123; write()&#125;// 实现上述两个接口type myReaderWriter struct &#123;&#125;func (mrw *myReaderWriter) read() &#123; fmt.Println(\"myReaderWriter read func...\")&#125;func (mrw *myReaderWriter) write() &#123; fmt.Println(\"myReadWriter writer func...\")&#125;// 定义一个接口，组合上述两个接口type ReaderWriterV1 interface &#123; Reader Writer&#125;// 等价于type ReaderWriterV2 interface &#123; read() write()&#125;func main() &#123; mrw := &amp;myReaderWriter&#123;&#125; //mrw对象实现了read()方法和write()方法，因此可以赋值给ReaderWriterV1和ReaderWriterV2 var rwv1 ReaderWriterV1 = mrw rwv1.read() rwv1.write() var rwv2 ReaderWriterV2 = mrw rwv2.write() rwv2.read() //同时，ReaderWriterV1和ReaderWriterV2两个接口对象可以相互赋值 rwv1 = rwv2 rwv2 = rwv1&#125; 4.4、常用的系统接口1、Stringer这个就是常见的 toString 的功能， 12345678// Stringer is implemented by any value that has a String method,// which defines the ``native'' format for that value.// The String method is used to print values passed as an operand// to any format that accepts a string or to an unformatted printer// such as Print.type Stringer interface &#123; String() string&#125; Stringer接口定义在fmt包中，该接口包含String()函数。任何类型只要定义了String()函数，进行Print输出时，就可以得到定制输出。比如： 123456789101112131415161718192021222324package mainimport \"fmt\"type Person struct&#123; age int gender string name string&#125;func (p Person) String() string &#123; return fmt.Sprintf(\"age:%d, gender:%s, name:%s\", p.age, p.gender, p.name)&#125;func main() &#123; var i Person = Person&#123; age: 25, gender: \"male\", name: \"sheng.guocun\", &#125; fmt.Printf(\"%s\\n\", i) fmt.Println(i) fmt.Printf(\"%v\", i)&#125; 结果输出为： 123age:25, gender:male, name:sheng.guocunage:25, gender:male, name:sheng.guocunage:25, gender:male, name:sheng.guocun 2、Reader、WriterReader Writer 上面有提到过，就是常见的读写文件的时候经常会用到，就是对文件的一个抽象，但是不仅这些，比如常见的 123456789// NewScanner returns a new Scanner to read from r.// The split function defaults to ScanLines.func NewScanner(r io.Reader) *Scanner &#123; return &amp;Scanner&#123; r: r, split: ScanLines, maxTokenSize: MaxScanTokenSize, &#125;&#125; 这的参数也是一个Reader，还有很多的底层的代码都是基于 Reader Writer 的，这里就不一一举例了。 5. 函数式编程5.0、函数式编程Go语言作为一个通用型语言，它对函数式编程主要体现在闭包上面。 1、函数式编程 VS 函数指针 函数是一等公民：参数、变量、返回值都可以是函数，在别的语言中大多不是这样的，比如在C++里面只有函数指针，在Java里面我们只能调用，不能把函数传给别人。 高阶函数：参数可以是函数，1.6.3里面的apply函数就是一个高阶函数。 函数 –&gt; 闭包：首先用个例子来了解一下闭包的用法 12345678910111213141516171819package mainimport \"fmt\"func adder() func(int) int &#123; sum := 0 return func(v int) int &#123; sum += v return sum &#125;&#125;func main() &#123; a := adder() for i := 0; i &lt; 10; i ++ &#123; fmt.Printf(\"0 + 1 + 2 + ... + %d = %d\\n\", i, a(i)) &#125;&#125; 结果输出为 123456789100 + 1 + 2 + ... + 0 = 00 + 1 + 2 + ... + 1 = 10 + 1 + 2 + ... + 2 = 30 + 1 + 2 + ... + 3 = 60 + 1 + 2 + ... + 4 = 100 + 1 + 2 + ... + 5 = 150 + 1 + 2 + ... + 6 = 210 + 1 + 2 + ... + 7 = 280 + 1 + 2 + ... + 8 = 360 + 1 + 2 + ... + 9 = 45 上述的 v 就称为局部变量， sum 称为自由变量，func(v int) int { sum += v return sum } 称为函数体，整个就叫做一个闭包。用一张图来概括就是： 2、“正统”函数式编程 不可变性：不能有状态，只有常量和函数；当然这和平常的函数不一样，连变量都没有，甚至连选择语句、循环语句都没有。 函数只能有一个参数 要是上面的累加想做一个稍微正统函数怎么做呢？ 1234567891011121314151617type iAdder func(int) (int, iAdder)func adderV2(base int) iAdder &#123; return func(v int) (int, iAdder) &#123; return base + v, adderV2(base + v) &#125;&#125;func main() &#123; a := adderV2(0) for i := 0; i &lt; 10; i ++ &#123; var s int s, a = a(i) fmt.Printf(\"0 + 1 + 2 + ... + %d = %d\\n\", i, s) &#125;&#125; 当然正统的不一定是最好的，正统式的写法经常导致代码的可读性变得不是很好。 5.1、函数式编程实例演示1、斐波那契数列Go语言的官方案列中，对闭包的讲解通过一个常见的例子：斐波那契数列，为了更好的理解闭包的感念，那这里我们就将这个例子再来演示一遍 12345678func Fibonacci() func() int &#123; a, b := 0, 1 return func() int &#123; a, b = b, a+b return a &#125;&#125; 比如我们要打印这一串斐波那契数列，我们就需要不停的调用上面的斐波那契数列的生成器。 12345678f := Fibonacci()f() // 1f() // 1f() // 2f() // 3f() // 5f() // 8 2、为函数实现接口这个斐波那契数列的调用的生成器跟文件有点像，我们可以把它包装成一个 io.Reader 这样就跟打印一个文件一样生成这个斐波那契数列。 首先我们先定义我们的类型 func() int ，就取名Generate好了 1type Generate func() int 同时需要将 Fibonacci() 函数的类型改掉 12345678func Fibonacci() Generate &#123; a, b := 0, 1 return func() int &#123; a, b = b, a+b return a &#125;&#125; 是一个类型就可以实现接口，这就是Go语言灵活的地方，下一步我们实现这个Reader接口 1234567func (gen Generate) Read(p []byte) (n int, err error) &#123; nextNum := gen() numString := fmt.Sprintf(\"%d \\n\", nextNum) return strings.NewReader(numString).Read(p)&#125; 这里我们会发现函数也可以实现接口，这就是Go语言的不一样的地方，因为函数是一等公民，它既可以作为参数，也可以作为接收者。首先我们要先取到下一个元素 nextNum ,然后将下一个元素写进 p 。然后我们直接用一个写好的文件打印的函数 1234567func printFileContents(reader io.Reader) &#123; scanner := bufio.NewScanner(reader) for scanner.Scan() &#123; fmt.Println(scanner.Text()) &#125;&#125; 最后我们就可以直接调用了 12345func main() &#123; f := Fibonacci() printFileContents(f)&#125; 当然，上述的代码是存在瑕疵的，比如这个 printFileContents 函数会一直读下去，就变成一个死循环了，我们需要设置其终止条件。比如上面的 p 太小的话，只读了一半，当然这边就留给读者后期拓展了。 6. 错误处理和资源管理我们实际的代码不止 Hello World ,我们的代码是要运行在服务器上的，要和各种各样的用户进行交互，所以我们这里就要了解一下Go语言的资源管理和出错处理。 6.0、defer调用1、确保在函数结束时调用比如一个常见的代码 123456789package mainimport \"fmt\"func main() &#123; fmt.Println(1) fmt.Println(2)&#125; 我要是想要让1在2后面输出该如何做呢？你说调换一下顺序呗，道理我都懂，但是我们今天要介绍的不是这个，我们只需要在打印1之前加一个 defer 就可以了 123456789package mainimport \"fmt\"func main() &#123; defer fmt.Println(1) fmt.Println(2)&#125; 要是有多个defer呢？它的输出顺序又是什么样的呢？ 12345678910package mainimport \"fmt\"func main() &#123; defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3)&#125; 上面这段代码，输出的结果又是什么？ 123321 这里我们可以发现 defer 的调用实际是一个栈，先进后出。当然 defer 的最大的好处是什么呢？就是当程序中间有return返回甚至panic的时候，依然不影响 defer 后面的代码的执行。 123456789101112package mainimport \"fmt\"func main() &#123; defer fmt.Println(1) defer fmt.Println(2) fmt.Println(3) panic(\"whoops, something went wrong....\") fmt.Println(4)&#125; 上述的代码在panic之后，1 2 依然能够正常输出。 2、场景演示当然说了这么多，我们在代码中常见的使用defer的场景有哪些呢？比如我们创建文件，写文件这些，过去我们用别的语言经常会在处理文件的最后释放句柄，因为中间隔了很多的文件操作，经常可能会忘记释放句柄。那Go语言就针对这样的场景做了非常好的优化，通过defer关键字实现，下面我们就通过一个简单的写文件事例来演示一下： 12345678910111213141516171819202122package mainimport ( \"os\" \"bufio\" \"fmt\")func main() &#123; filename := \"demo.txt\" file, err := os.Create(filename) if err != nil &#123; panic(err) &#125; defer file.Close() writer := bufio.NewWriter(file) defer writer.Flush() fmt.Fprintln(writer, \"你好，杭州\")&#125; 一个完整的事例就演示到这边，比如常见的 Open／Close、Lock／Unlock这些成对出现的都可以使用 defer 6.1、错误处理概念因为在我们实际的程序中，有错直接panic中断程序执行，这时非常不友好的，通常我们会对其出错处理。比如上面的事例中 os.Create 函数返回的 err 不为 nil 的时候，我们需要做一个出错处理， 123456filename := \"demo.txt\"file, err := os.Create(filename)if err != nil &#123; fmt.Println(err.Error()) return&#125; 我们可以直接打印出相关的错误信息，然后直接返回。这就是常见的错误处理方式之一，当然在函数内部也可以将错误信息直接作为结果返回。 6.2、panic和recover1、panic 停止当前函数执行 panic和我们其他语言的throw exception很像 一直向上返回，执行每一层的defer 当然相对还是友好的，每层的defer还是会用到，一层一层的返回，返回到最后程序就会自动退出了 如果没有遇见recover，程序退出 2、recover 仅在defer调用中使用 获取panic的值 如果无法处理，可充新panic 主要的特性就可以用上述几句话概括，为了更好的理解上述的概念，下面用一个简短的代码来学以致用 12345678func tryDefer() &#123; for i := 0; i &lt; 100; i++ &#123; defer fmt.Println(i) if i == 10 &#123; panic(\"就打印到这吧\") &#125; &#125;&#125; 上面就是一个 panic 和 defer 的结合使用，他的输出结果会是什么样的呢？ 123456789101112131415161718109876543210panic: 就打印到这吧goroutine 1 [running]:main.tryDefer() /Users/verton/GoLangProject/src/shengguocun.com/web/web.go:11 +0x11dmain.main() /Users/verton/GoLangProject/src/shengguocun.com/web/web.go:18 +0x20 从上述输出结果我们可以看到panic的前两个特性，那结合recover又会是什么样的呢？ 12345678910// The recover built-in function allows a program to manage behavior of a// panicking goroutine. Executing a call to recover inside a deferred// function (but not any function called by it) stops the panicking sequence// by restoring normal execution and retrieves the error value passed to the// call of panic. If recover is called outside the deferred function it will// not stop a panicking sequence. In this case, or when the goroutine is not// panicking, or if the argument supplied to panic was nil, recover returns// nil. Thus the return value from recover reports whether the goroutine is// panicking.func recover() interface&#123;&#125; 123456789101112func tryRecover() &#123; defer func() &#123; r := recover() if err, ok := r.(error); ok &#123; fmt.Println(\"错误信息: \", err) &#125; else &#123; panic(r) &#125; &#125;() panic(errors.New(\"这是一个 error\"))&#125; 从上面我们可以看到 recover 是一个interface， 所以在判断的时候需要判断 r 是否是一个 error，结果自然会是输出 1错误信息: 这是一个 error 那我们再用一个实际一点的例子来测试一下，比如除数为0的例子 1234567891011121314func tryRecover() &#123; defer func() &#123; r := recover() if err, ok := r.(error); ok &#123; fmt.Println(\"错误信息: \", err) &#125; else &#123; panic(r) &#125; &#125;() b := 0 a := 5 / b fmt.Println(a)&#125; 结果输出 1错误信息: runtime error: integer divide by zero 上面的两个例子简单介绍了panic、recover的基本使用，下面通过一个稍微实际一点的例子来综合讲述一下一般的项目中是如何统一处理错误的。 6.3、服务器统一出错处理现在呢我们就通过一个Http服务来展开如何统一处理服务器出错这件事，结合一个实际读取目录内文件的例子来简单介绍一下 12345678910111213141516171819202122232425func main() &#123; http.HandleFunc(\"/list/\", func(writer http.ResponseWriter, request *http.Request) &#123; path := request.URL.Path[len(\"/list/\"):] file, err := os.Open(path) if err != nil &#123; panic(err) &#125; defer file.Close() all, err := ioutil.ReadAll(file) if err != nil &#123; panic(err) &#125; writer.Write(all) &#125;) err := http.ListenAndServe(\":2872\", nil) if err != nil &#123; panic(err) &#125;&#125; 因为在GOPATH下有一个 demo.txt 文件，浏览器输入一下地址 http://localhost:2872/list/demo.txt ,浏览器正确输出结果 万一我访问一个不存在的文件呢？会得到什么样的结果，比如我现在访问 http://localhost:2872/list/demo.txts GOPATH目录下没有demo.txts文件，自然你会想到会panic一个错误 123456789101112132018/05/04 17:08:54 http: panic serving [::1]:51946: open demo.txts: no such file or directorygoroutine 5 [running]:net/http.(*conn).serve.func1(0xc4200968c0) /usr/local/Cellar/go/1.10.2/libexec/src/net/http/server.go:1726 +0xd0panic(0x124fde0, 0xc420086fc0) /usr/local/Cellar/go/1.10.2/libexec/src/runtime/panic.go:502 +0x229main.main.func1(0x12d1420, 0xc42010e000, 0xc42010a000) /Users/verton/GoLangProject/src/shengguocun.com/web/web.go:52 +0x144net/http.HandlerFunc.ServeHTTP(0x12aff28, 0x12d1420, 0xc42010e000, 0xc42010a000) /usr/local/Cellar/go/1.10.2/libexec/src/net/http/server.go:1947 +0x44net/http.(*ServeMux).ServeHTTP(0x140b3e0, 0x12d1420, 0xc42010e000, 0xc42010a000) /usr/local/Cellar/go/1.10.2/libexec/src/net/http/server.go:2337 +0x130net/http.serverHandler.ServeHTTP(0xc420089110, 0x12d1420, 0xc42010e000, 0xc42010a000) 从上面的部分的报错信息来看， 相关的错误信息都是 /usr/local/Cellar/go/1.10.2/libexec/src/net/http/server.go 的 serve 函数报出的，具体是哪一步报出的我就不细说了，有兴趣的可以自己按照例子自己查阅相关的源码，说到这那错误统一处理又是如何处理呢？我们先把第一个panic替换成 1234567path := request.URL.Path[len(\"/list/\"):]file, err := os.Open(path)if err != nil &#123; http.Error(writer, err.Error(), http.StatusInternalServerError) return&#125; 我们再来访问上述地址 相比之前，提示稍微友好一点了，但是这对用户来讲还是不合适的，直接将程序内部错误信息输出给用户有些欠妥。我们可以包装成一个外部的Error，首先我们先定义一个函数appHandler, 返回一个error 1type appHandler func(writer http.ResponseWriter, request *http.Request) error 然后定义一个 errWrapper 函数, 返回一个handler 里面需要的函数 12345678910111213141516type appHandler func(writer http.ResponseWriter, request *http.Request) errorfunc errWrapper(handler appHandler) func(http.ResponseWriter, *http.Request) &#123; return func(writer http.ResponseWriter, request *http.Request) &#123; err := handler(writer, request) if err != nil &#123; switch &#123; case os.IsNotExist(err): http.Error(writer, http.StatusText(http.StatusNotFound), http.StatusNotFound) &#125; &#125; &#125;&#125; 然后将writer和request传进handler，通过switch判断err的类型，做一个统一的返回处理；这时我们需要将原来的业务逻辑的代码稍微做一下调整， 12345678910111213141516171819202122http.HandleFunc(\"/list/\", errWrapper(func(writer http.ResponseWriter, request *http.Request) error &#123; path := request.URL.Path[len(\"/list/\"):] file, err := os.Open(path) if err != nil &#123; return err &#125; defer file.Close() all, err := ioutil.ReadAll(file) if err != nil &#123; return err &#125; writer.Write(all) return nil &#125;))err := http.ListenAndServe(\":2872\", nil)if err != nil &#123; panic(err)&#125; http.HandleFunc 的第二个参数我们需要改为 errWrapper 同时将原来的函数作为参数传进去，当然这个函数为了代码的可读性应该单独抽离出来，相应的返回直接返回error就可以了，这时候我们再去访问之前的一个不存在的URL 这时候的错误就明显友好了很多，讲到这就是一个简单的统一错误处理的思路。 7. 测试和性能调优7.0、测试1、传统测试 VS 表格驱动测试测试的作用对于一个软件行业从业者而言都是毋庸置疑的，Go语言在测试这块它有自己独特的见解，下面我们先介绍一下这两种模式下的测试 传统测试 测试数据和测试逻辑混在一起 出错信息不明确 一旦一个数据出错测试全部结束 下面我们简单的举个例子： 123456public function testCase()&#123; assertEquals(2, add(1, 1)); assertEquals(1, add(1, 3)); assertEquals(0, add(1, -1));&#125; 很明显上面的几个特征它都占了，那下面我们来看一段Go语言的测试case 123456789101112tests := []struct&#123; a, b, c int32&#125;&#123; &#123;2, 1, 1&#125;, &#123;1, 1, 3&#125;, &#123;0, 1, -1&#125;,&#125;for _, test := range tests &#123; if act := add(test.a, test.b); act != test.c &#123; // 相应的错误处理... &#125;&#125; 上述就是一个典型的表格驱动测试 表格驱动测试 分离测试数据和测试逻辑 明确的出错信息 可以部分失败 Go语言的语法使得我们更容易使用表格驱动测试的测试模式 2、实例演示说了这么多，我们通常又是如何写测试用例呢？首先下面是一段加法的代码 123456package calculatorfunc Add(a, b int32) int32 &#123; return a + b&#125; 现在就写上面的函数的测试用例 12345678910111213141516171819202122package calculatorimport ( \"testing\")func TestAdd(t *testing.T) &#123; tests := []struct&#123; a, b, c int32 &#125;&#123; &#123;1, 1, 2&#125;, &#123;-1, 1, 0&#125;, &#125; for _, test := range tests &#123; if act := Add(test.a, test.b); act != test.c &#123; t.Errorf(\"%d + %d != %d 实际为 %d\", test.a, test.b, test.c, act) &#125; &#125;&#125; 用IDE的同学直接点击 Run Test 就可以了，当然也同样支持命令行运行,进入到指定的文件目录下面 12sheng$ go test ./ok shengguocun.com/functional/calculator 0.006s 运行相关的执行命令就可以了，要是有错误的case依然不影响相关的测试的执行，比如： 123456789101112131415161718192021222324package calculatorimport ( \"testing\" \"math\")func TestAdd(t *testing.T) &#123; tests := []struct&#123; a, b, c int32 &#125;&#123; &#123;1, 1, 2&#125;, &#123;-1, 1, 0&#125;, &#123;math.MaxInt32, 1, math.MaxInt32&#125;, &#125; for _, test := range tests &#123; if act := Add(test.a, test.b); act != test.c &#123; t.Errorf(\"%d + %d != %d 实际为 %d\", test.a, test.b, test.c, act) &#125; &#125;&#125; 测试用例的执行结果为 12345sheng$ go test ./--- FAIL: TestAdd (0.00s) add_test.go:21: 2147483647 + 1 != 2147483647 实际为 -2147483648FAILFAIL shengguocun.com/functional/calculator 0.006s 我们需要将不符合预期的case做出检查，看是否是代码逻辑有问题，还是case的问题，这就是一个完整的测试用例的编写的过程。 7.1、代码覆盖率和性能测试1、代码覆盖率用IDE的同学我们会发现点击 Run Test 按钮的时候还有一个 with coverage 的选项 123456=== RUN TestAdd--- PASS: TestAdd (0.00s)PASScoverage: 100.0% of statementsProcess finished with exit code 0 这就是一个测试用例的代码覆盖率的结果。 IDE这块有详细的覆盖率报告，可以看到左侧的绿色就是代码的覆盖的范围，右侧有详细的每个文件的覆盖率。当然除了IDE之外命令行也是同样支持的 1234sheng$ go test -coverprofile=a.outPASScoverage: 100.0% of statementsok shengguocun.com/functional/calculator 0.006s 直接查看这个 a.out 文件，似乎看得不是很明白，当然我们有一个工具叫 go tool cover 1sheng$ go tool cover -html=a.out 运行上面的命令，就会展现一个下面的静态页面 这就是一个详细的覆盖率报告 2、性能测试对于程序员而言，代码的性能是每个人都会去关注的，Go语言在性能测试这块依然有它的独特见解 Benchmark 12345678910111213141516func BenchmarkAdd(b *testing.B) &#123; aa := int32(math.MaxInt32 / 16) bb := int32(math.MaxInt32 / 16) cc := int32(math.MaxInt32 / 8) - 1 for i := 0; i &lt; b.N; i ++ &#123; act := Add(aa, bb) if act != cc &#123; b.Errorf(\"%d + %d != %d 实际为 %d\", aa, bb, cc, act) &#125; &#125;&#125; 上面就是一段性能测试代码，我们不需要关注这段代码具体要跑多少次，Go语言自身会帮你决定，IDE点击 Run Test 完，输出相关的结果 1234567goos: darwingoarch: amd64pkg: shengguocun.com/functional/calculator2000000000 0.35 ns/opPASSProcess finished with exit code 0 总共跑了多少次以及每次的平均耗时，都会给出结果。当然同样支持命令行的交互方式 1234567sheng$ go test -bench .goos: darwingoarch: amd64pkg: shengguocun.com/functional/calculatorBenchmarkAdd-4 2000000000 0.34 ns/opPASSok shengguocun.com/functional/calculator 0.721s 7.2、使用pprof进行性能调优上面我们刚提到了性能测试，下一步自然就是我们该如何优化代码的性能，这里我们需要介绍一下Go语言的性能分析工具 pprof ，就依然用上面的这个例子进行阐述它的基本用法，我们要是想了解一段代码具体它慢在哪里，首先呢我们先让它生成一个cpuprofile 1234567sheng$ go test -bench . -cpuprofile=cpu.outgoos: darwingoarch: amd64pkg: shengguocun.com/functional/calculatorBenchmarkAdd-4 2000000000 0.34 ns/opPASSok shengguocun.com/functional/calculator 0.916s 这时候我们发现现在多了一个 cpu.out 文件 12sheng$ lsa.out add.go add_test.go calculator.test cpu.out 查看之后你会发现是一个二进制文件，那我们该如何处理呢？Go语言的 pprof 就要登场了 12sheng$ less cpu.out\"cpu.out\" may be a binary file. See it anyway? 1234567sheng$ go tool pprof cpu.outMain binary filename not available.Type: cpuTime: May 9, 2018 at 5:40pm (CST)Duration: 907.82ms, Total samples = 600ms (66.09%)Entering interactive mode (type \"help\" for commands, \"o\" for options)(pprof) 这时候出现了一个交互式的命令行，我们可以通过输入 help 得到相关的使用说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172(pprof) help Commands: callgrind Outputs a graph in callgrind format comments Output all profile comments disasm Output assembly listings annotated with samples dot Outputs a graph in DOT format eog Visualize graph through eog evince Visualize graph through evince gif Outputs a graph image in GIF format gv Visualize graph through gv kcachegrind Visualize report in KCachegrind list Output annotated source for functions matching regexp pdf Outputs a graph in PDF format peek Output callers/callees of functions matching regexp png Outputs a graph image in PNG format proto Outputs the profile in compressed protobuf format ps Outputs a graph in PS format raw Outputs a text representation of the raw profile svg Outputs a graph in SVG format tags Outputs all tags in the profile text Outputs top entries in text form top Outputs top entries in text form topproto Outputs top entries in compressed protobuf format traces Outputs all profile samples in text form tree Outputs a text rendering of call graph web Visualize graph through web browser weblist Display annotated source in a web browser o/options List options and their current values quit/exit/^D Exit pprof Options: call_tree Create a context-sensitive call tree compact_labels Show minimal headers divide_by Ratio to divide all samples before visualization drop_negative Ignore negative differences edgefraction Hide edges below &lt;f&gt;*total focus Restricts to samples going through a node matching regexp hide Skips nodes matching regexp ignore Skips paths going through any nodes matching regexp mean Average sample value over first value (count) nodecount Max number of nodes to show nodefraction Hide nodes below &lt;f&gt;*total normalize Scales profile based on the base profile. output Output filename for file-based outputs positive_percentages Ignore negative samples when computing percentages prune_from Drops any functions below the matched frame. relative_percentages Show percentages relative to focused subgraph sample_index Sample value to report (0-based index or name) show Only show nodes matching regexp source_path Search path for source files tagfocus Restricts to samples with tags in range or matched by regexp taghide Skip tags matching this regexp tagignore Discard samples with tags in range or matched by regexp tagshow Only consider tags matching this regexp trim Honor nodefraction/edgefraction/nodecount defaults unit Measurement units to display Option groups (only set one per group): cumulative cum Sort entries based on cumulative weight flat Sort entries based on own weight granularity addresses Aggregate at the function level. addressnoinlines Aggregate at the function level, including functions' addresses in the output. files Aggregate at the file level. functions Aggregate at the function level. lines Aggregate at the source code line level. noinlines Aggregate at the function level. : Clear focus/ignore/hide/tagfocus/tagignore type \"help &lt;cmd|option&gt;\" for more information(pprof) 我们这里就介绍一个最简单的方式，敲入web回车,z这里做一个温馨提示 12(pprof) webFailed to execute dot. Is Graphviz installed? Error: exec: \"dot\": executable file not found in $PATH 出现上述报错的，是因为Graphviz没有安装，安装好了之后再敲入web会生成一个SVG文件,用浏览器打开它 一张图可以很明显的表现出哪边花的时间多哪边花的时间少，当然也可以从框框的大小来做判断，我们需要优化比较大的框框的部分。上述的代码因为太过于简单，大家可以试着用自己写的代码进行性能分析。 7.3、生成文档和事例代码在我们实际的开发过程中，文档的重要性不必多说，服务调用方、协同开发的小伙伴、QA都需要文档；其他的语言我们经常需要依赖其他的文档工具，比如：ApiDoc、doxmate、daux等等。首先我们先介绍一下 go doc 的常规的用法 1234sheng$ go docpackage calculator // import \"shengguocun.com/functional/calculator\"func Add(a, b int32) int32 12sheng$ go doc Addfunc Add(a, b int32) int32 除此之外呢，我们可以通过help来查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102sheng$ go help docusage: go doc [-u] [-c] [package|[package.]symbol[.methodOrField]]Doc prints the documentation comments associated with the item identified by itsarguments (a package, const, func, type, var, method, or struct field)followed by a one-line summary of each of the first-level items \"under\"that item (package-level declarations for a package, methods for a type,etc.).Doc accepts zero, one, or two arguments.Given no arguments, that is, when run as go docit prints the package documentation for the package in the current directory.If the package is a command (package main), the exported symbols of the packageare elided from the presentation unless the -cmd flag is provided.When run with one argument, the argument is treated as a Go-syntax-likerepresentation of the item to be documented. What the argument selects dependson what is installed in GOROOT and GOPATH, as well as the form of the argument,which is schematically one of these: go doc &lt;pkg&gt; go doc &lt;sym&gt;[.&lt;methodOrField&gt;] go doc [&lt;pkg&gt;.]&lt;sym&gt;[.&lt;methodOrField&gt;] go doc [&lt;pkg&gt;.][&lt;sym&gt;.]&lt;methodOrField&gt;The first item in this list matched by the argument is the one whose documentationis printed. (See the examples below.) However, if the argument starts with a capitalletter it is assumed to identify a symbol or method in the current directory.For packages, the order of scanning is determined lexically in breadth-first order.That is, the package presented is the one that matches the search and is nearestthe root and lexically first at its level of the hierarchy. The GOROOT tree isalways scanned in its entirety before GOPATH.If there is no package specified or matched, the package in the currentdirectory is selected, so \"go doc Foo\" shows the documentation for symbol Foo inthe current package.The package path must be either a qualified path or a proper suffix of apath. The go tool's usual package mechanism does not apply: package pathelements like . and ... are not implemented by go doc.When run with two arguments, the first must be a full package path (not just asuffix), and the second is a symbol, or symbol with method or struct field.This is similar to the syntax accepted by godoc: go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;methodOrField&gt;]In all forms, when matching symbols, lower-case letters in the argument matcheither case but upper-case letters match exactly. This means that there may bemultiple matches of a lower-case argument in a package if different symbols havedifferent cases. If this occurs, documentation for all matches is printed.Examples: go doc Show documentation for current package. go doc Foo Show documentation for Foo in the current package. (Foo starts with a capital letter so it cannot match a package path.) go doc encoding/json Show documentation for the encoding/json package. go doc json Shorthand for encoding/json. go doc json.Number (or go doc json.number) Show documentation and method summary for json.Number. go doc json.Number.Int64 (or go doc json.number.int64) Show documentation for json.Number's Int64 method. go doc cmd/doc Show package docs for the doc command. go doc -cmd cmd/doc Show package docs and exported symbols within the doc command. go doc template.new Show documentation for html/template's New function. (html/template is lexically before text/template) go doc text/template.new # One argument Show documentation for text/template's New function. go doc text/template new # Two arguments Show documentation for text/template's New function. At least in the current tree, these invocations all print the documentation for json.Decoder's Decode method: go doc json.Decoder.Decode go doc json.decoder.decode go doc json.decode cd go/src/encoding/json; go doc decodeFlags: -c Respect case when matching symbols. -cmd Treat a command (package main) like a regular package. Otherwise package main's exported symbols are hidden when showing the package's top-level documentation. -u Show documentation for unexported as well as exported symbols, methods, and fields. 再比如我们可以查看系统的文档 12345678910111213sheng$ go doc json.Decoder.Decodefunc (dec *Decoder) Decode(v interface&#123;&#125;) error Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. See the documentation for Unmarshal for details about the conversion of JSON into a Go value.sheng$ go doc fmt.Printffunc Printf(format string, a ...interface&#123;&#125;) (n int, err error) Printf formats according to a format specifier and writes to standard output. It returns the number of bytes written and any write error encountered. 当然我们最常用的命令是 godoc ，我们help看一下它的基本用法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849sheng$ godoc -helpusage: godoc package [name ...] godoc -http=:6060 -analysis string comma-separated list of analyses to perform (supported: type, pointer). See http://golang.org/lib/godoc/analysis/help.html -ex show examples in command line mode -goroot string Go root directory (default \"/usr/local/Cellar/go/1.10.2/libexec\") -html print HTML in command-line mode -http string HTTP service address (e.g., ':6060') -httptest.serve string if non-empty, httptest.NewServer serves on this address and blocks -index enable search index -index_files string glob pattern specifying index files; if not empty, the index is read from these files in sorted order -index_interval duration interval of indexing; 0 for default (5m), negative to only index once at startup -index_throttle float index throttle value; 0.0 = no time allocated, 1.0 = full throttle (default 0.75) -links link identifiers to their declarations (default true) -maxresults int maximum number of full text search results shown (default 10000) -notes string regular expression matching note markers to show (default \"BUG\") -play enable playground in web interface -q arguments are considered search queries -server string webserver address for command line searches -src print (exported) source in command-line mode -tabwidth int tab width (default 4) -templates string load templates/JS/CSS from disk in this directory -timestamps show timestamps with directory listings -url string print HTML for named URL -v verbose mode -write_index write index to a file; the file name must be specified with -index_files -zip string zip file providing the file system to serve; disabled if empty 我们看到有个http的用法，现在我们试一下 1sheng$ godoc -http :6060 打开浏览器，输入 http://localhost:6060 完整的Web版的Go语言的文档就可以使用了。当然不单单包含系统函数，同时还包含我们自己写的函数的文档，现在我们就演示一下 12345// 加法函数func Add(a, b int32) int32 &#123; return a + b&#125; 我们在函数前面加上了注释，这是我们重新启动 godoc -http :6060 我们会发现 相关的注释已经加上了。Go语言除此之外还提供了写示例代码的方法 12345678func ExampleAdd() &#123; c := Add(1, 3) fmt.Println(c) // Output: // 1&#125; 直接添加一个 ExampleAdd 函数，还是像之前一样写代码，最后我们要写一个 Output 的注释，那你现在是否有疑问，下面的 1 是什么意思？这里说下，这是我随便写的，这时候 Run Test 这段代码 123456789=== RUN ExampleAdd--- FAIL: ExampleAdd (0.00s)got:4want:1FAILProcess finished with exit code 1 我们再把正确的输出贴到上面的输出中，重启godoc 这时候完整的示例代码就已经生成到文档中了。 8. Goroutine8.0、Goroutine介绍协程 Coroutine轻量级”线程”上面的两个特征到底是什么意思呢？下面我们通过具体的事例详细的讲述一下， 1234567891011121314package mainimport \"fmt\"func main() &#123; for i := 0; i &lt; 10; i ++ &#123; func(i int)&#123; for &#123; fmt.Println(\"Goroutine :\" , i) &#125; &#125;(i) &#125;&#125; 上面这段代码有问题么? 这就是一个从 0 到 10 的调用，但是匿名函数内部没有中止条件，所以会进入一个死循环。要是我们在匿名函数前加上 go 关键字，就不是刚才的意思了，就变成并发执行这个函数。主程序继续向下跑，同时并发开了一个函数，就相当于开了一个线程，当然我们后面会继续介绍，这个叫 协程 1234567891011121314package mainimport \"fmt\"func main() &#123; for i := 0; i &lt; 10; i ++ &#123; go func(i int)&#123; for &#123; fmt.Println(\"Goroutine :\" , i) &#125; &#125;(i) &#125;&#125; 我们再执行这段代码，发现什么都没有输出，这又是为什么呢？因为这个 main 和 fmt.Println 是并发执行的，我们还来不及print结果， main 就执行完成退出了。Go语言一旦main函数退出了，所有的Goroutine就被杀掉了。当然要是想看到输出结果，main函数可以在最后sleep一下 123456789101112131415161718package mainimport ( \"fmt\" \"time\")func main() &#123; for i := 0; i &lt; 10; i ++ &#123; go func(i int)&#123; for &#123; fmt.Println(\"Goroutine :\" , i) &#125; &#125;(i) &#125; time.Sleep(time.Millisecond)&#125; 这时候就有相关的结果输出了。那我们将现在的10改成1000，又会怎样呢？当然还是可以正常输出的，熟悉操作系统的都知道正常的线程几十个上百个是没啥问题的，1000个还是有点难度的，其它语言通常使用异步IO的方式。在Go语言中我们不用管10个、100个、1000个代码还是一样的写法。 非抢占式多任务处理，由协程主动交出控制权非抢占式多任务 这又是什么意思呢？下面我们用一个例子来解释一下 1234567891011121314151617181920package mainimport ( \"time\" \"fmt\")func main() &#123; var a [10]int for i := 0; i &lt; 10; i ++ &#123; go func(i int)&#123; for &#123; a[i] ++ &#125; &#125;(i) &#125; time.Sleep(time.Millisecond) fmt.Println(a)&#125; 在运行之前，可以想一下会输出什么呢? 什么也没有输出，进入了死循环。 上图是我的活动监视器的截图，因为是4核的机器，几乎全部占满了。退不出的原因是因为Goroutine a[i] 交不出控制权，没有yield出去，同时main函数也是一个goroutine，因为没人交出控制权，所以下面的sleep永远也不会执行。那我该如何交出控制权呢？我们可以做一个IO操作可以交出控制权，当然也可以手动交出控制权 12345678910111213141516171819202122package mainimport ( \"time\" \"fmt\" \"runtime\")func main() &#123; var a [10]int for i := 0; i &lt; 10; i ++ &#123; go func(i int)&#123; for &#123; a[i] ++ runtime.Gosched() &#125; &#125;(i) &#125; time.Sleep(time.Millisecond) fmt.Println(a)&#125; 只需要加上 runtime.Gosched() ，这样大家都主动让出控制权，这时候代码可以正常输出了 123[321 986 890 880 831 881 919 904 861 904]Process finished with exit code 0 如果我们把goroutine的参数 i 去掉会怎样呢？直接的看语法上没有什么问题，就变成了一个闭包，使用外部的变量 i ， 12345678910111213141516171819202122package mainimport ( \"time\" \"fmt\" \"runtime\")func main() &#123; var a [10]int for i := 0; i &lt; 10; i ++ &#123; go func()&#123; for &#123; a[i] ++ runtime.Gosched() &#125; &#125;() &#125; time.Sleep(time.Millisecond) fmt.Println(a)&#125; 运行之后会出现什么问题呢？ 123456789panic: runtime error: index out of rangegoroutine 6 [running]:main.main.func1(0xc42001a0f0, 0xc42001c060) /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:15 +0x45created by main.main /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:13 +0x95Process finished with exit code 2 这里我们通过Go语言的 go run -race xxx.go ，执行分析一下 123456789101112131415sheng$ go run -race route.go==================WARNING: DATA RACERead at 0x00c420092008 by goroutine 6: main.main.func1() /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:15 +0x54Previous write at 0x00c420092008 by main goroutine: main.main() /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:12 +0x11bGoroutine 6 (running) created at: main.main() /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:13 +0xf1================== 这个地址 0x00c420092008 是谁呢，很显然就是 i ，原因是因为在最后跳出来的时候 i 会变成10，里面的 a[i] ++ 就会是a[10] ，所以出错的原因就在这。 123456789101112131415sheng$ go run -race route.go==================WARNING: DATA RACERead at 0x00c420092008 by goroutine 6: main.main.func1() /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:15 +0x54Previous write at 0x00c420092008 by main goroutine: main.main() /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:12 +0x11bGoroutine 6 (running) created at: main.main() /Users/verton/GoLangProject/src/shengguocun.com/goroutine/route.go:13 +0xf1================== 上面还剩一个的两个Goroutine读写的问题需要我们后面介绍的Channel来解决。 8.1、Go语言调度器多个协程可能在一个或多个线程上运行首先我们先看一张普通函数和协程的对比图 普通函数main函数和work函数都运行在一个线程里面，main函数在等work函数执行完才能执行其他的操作。可以看到普通函数 main 函数和 work 函数是单向的，但是发现协程的 main 和 work 是双向通道的，控制权可以在work也可以在main，不需要像普通函数那样等work函数执行完才交出控制权。协程中main和work可能执行在一个线程中，有可能执行在多个线程中。 上图就是Go语言的协程， 首先下面会有一个调度器，负责调度协程，有些是一个goroutine放在一个线程里面，有的是两个，有的是多个，这些我们都不需要关注。 goroutine定义 任何函数只需要加上go就能送给调度器运行 不需要在定义时区分是否是异步函数 调度器在合适的点进行切换 使用-race来检测数据访问冲突 goroutine可能的切换点 I/O 、select channel 等待锁 函数调用（有时） runtime.Gosched() 上述仅是参考，不能保证切换，不能保证在其他的地方不切换 9. Channel9.0、Channel介绍Channel 我们可以开很多个goroutine，goroutine和goroutine之间的双向通道就是channel。首先我们先来介绍一下channel的用法 1ch := make(chan int) 和其他类型类似，都是需要先创建声明 123456789101112131415161718192021package mainimport ( \"fmt\" \"time\")func main() &#123; ch := make(chan int) go func() &#123; for &#123; num := &lt;- ch fmt.Println(num) &#125; &#125;() ch &lt;- 1 ch &lt;- 2 time.Sleep(time.Millisecond)&#125; 这就是一个简单的channel示例，同时channel是一等公民，可以作为参数也可以作为返回值，那我们就用一个例子来简单的演示一下 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"time\")func work(channels chan int, num int) &#123; for ch := range channels &#123; fmt.Println(\"Work ID :\", num) fmt.Println(ch) &#125;&#125;func createWork(num int) chan&lt;- int &#123; ch := make(chan int) go work(ch, num) return ch&#125;func main() &#123; var channels [10]chan&lt;- int for i := 0; i &lt; 10; i ++ &#123; channels[i] = createWork(i) &#125; for i := 0; i &lt; 10; i ++ &#123; channels[i] &lt;- 'M' + i &#125; time.Sleep(time.Millisecond)&#125; 输出结果为 1234567891011121314151617181920Work ID : 380Work ID : 077Work ID : 178Work ID : 6Work ID : 983Work ID : 4Work ID : 5828681Work ID : 885Work ID : 279Work ID : 784 结果为什么是乱序的呢？因为 fmt.Println 有I/O操作；上述例子，可以看到channel既可以作参数，也可以作为返回值。 Buffer Channel12ch := make(chan int)ch &lt;- 1 我们要是光发送，没有接收是不行的，程序会报错,比如上述代码运行之后 12345fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send]:main.main() /Users/verton/GoLangProject/src/shengguocun.com/channel/channel.go:42 +0x50 我们可以设置一个缓冲区 12ch := make(chan int, 5)ch &lt;- 1 缓冲区大小设置为5，只要发送不超过5个都不会报错，下面我们来演示一下buffer channel的使用 12345678910111213141516func main() &#123; channels := make(chan int, 5) go func() &#123; for ch := range channels &#123; fmt.Println(ch) &#125; &#125;() channels &lt;- 1 channels &lt;- 2 channels &lt;- 3 channels &lt;- 4 channels &lt;- 5 time.Sleep(time.Millisecond)&#125; 结果输出正常 123456712345Process finished with exit code 0 比如我们确定数据结束了，可以在最后进行close；同时只能是发送方close的 1234567891011121314151617func main() &#123; channels := make(chan int, 5) go func() &#123; for ch := range channels &#123; fmt.Println(ch) &#125; &#125;() channels &lt;- 1 channels &lt;- 2 channels &lt;- 3 channels &lt;- 4 channels &lt;- 5 close(channels) time.Sleep(time.Millisecond)&#125; 直观地从输出结果来看，加不加close这两者是没有区别的。 9.1、使用Channel等待任务结束前面的例子中我们等待任务结束是通过sleep来处理，因为打印的数据较少，1 毫秒足够；但是这种方式等待任务结束显然不是很优雅。对于任务结束首先我们需要确定的通知外面我们打印结束了，那我们又如何通知呢？在Go语言中我们不要通过共享内存来通信，而是要通过通信来共享内存。直接用Channel就可以，下面我们来改造上面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( \"fmt\")type worker struct &#123; in chan int done chan bool&#125;func work(in chan int, done chan bool, num int) &#123; for ch := range in &#123; fmt.Println(\"Work ID :\", num) fmt.Println(ch) done&lt;- true &#125;&#125;func createWork(num int) worker &#123; ch := worker&#123; in: make(chan int), done: make(chan bool), &#125; go work(ch.in, ch.done, num) return ch&#125;func main() &#123; var workers [10]worker for i := 0; i &lt; 10; i ++ &#123; workers[i] = createWork(i) &#125; for i := 0; i &lt; 10; i ++ &#123; workers[i].in &lt;- 'M' + i &lt;-workers[i].done &#125;&#125; 打印输出结果 1234567891011121314151617181920Work ID : 077Work ID : 178Work ID : 279Work ID : 380Work ID : 481Work ID : 582Work ID : 683Work ID : 784Work ID : 885Work ID : 986 虽然sleep部分的代码已经删除了，但是发现是顺序打印的，这显然不是我想要的结果。Go语言对等待多任务完成提供了一个库 WaitGroup，下面我们就用它继续重构上述的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( \"fmt\" \"sync\")type worker struct &#123; in chan int done func()&#125;func work(worker worker, num int) &#123; for ch := range worker.in &#123; fmt.Println(\"Work ID :\", num) fmt.Println(ch) worker.done() &#125;&#125;func createWork(num int, wg *sync.WaitGroup) worker &#123; worker := worker&#123; in: make(chan int), done: func() &#123; wg.Done() // 每个任务做完了就调用Done &#125;, &#125; go work(worker, num) return worker&#125;func main() &#123; var wg sync.WaitGroup var workers [10]worker for i := 0; i &lt; 10; i ++ &#123; workers[i] = createWork(i, &amp;wg) &#125; wg.Add(10) // Add 总共有多少个任务 for i := 0; i &lt; 10; i ++ &#123; workers[i].in &lt;- 'M' + i &#125; wg.Wait() // 等待所有的任务做完&#125; 结果输出 12345678910111213141516171819202122Work ID : 481Work ID : 582Work ID : 178Work ID : 279Work ID : 6Work ID : 380Work ID : 0Work ID : 9868377Work ID : 784Work ID : 885Process finished with exit code 0 这样相应的结果才是我们想要的。 面试题实战1协程交替执行,使其能顺序输出1-20的自然数 这个问题就不做演示了，留给读者自行发挥。 9.2、用select进行调度1、select使用首先我们先来介绍一下select常规的应用场景，比如 1var ch1, ch2 chan int 我们有两个channel，我们想从 ch1、ch2 里面收数据， 123var ch1, ch2 chan intdata1 := &lt;- ch1data2 := &lt;- ch2 谁快我就要谁，这就是我们的select 12345678910111213141516171819package mainimport ( \"fmt\")func main() &#123; var ch1, ch2 chan int select &#123; case data := &lt;- ch1: fmt.Println(\"CH1 的数据：\", data) case data := &lt;-ch2: fmt.Println(\"CH2 的数据：\", data) default: fmt.Println(\"没收到 CH1、CH2 的数据\") &#125;&#125; 这就相当于做了一个非阻塞式的获取。下面我们就结合一个channel生成器来做一个例子演示 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"fmt\" \"time\" \"math/rand\")func genChan() chan int &#123; out := make(chan int) go func() &#123; i := 0 for &#123; time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) out &lt;- i i ++ &#125; &#125;() return out&#125;func main() &#123; var ch1, ch2 = genChan(), genChan() for &#123; select &#123; case data := &lt;- ch1: fmt.Println(\"CH1 的数据：\", data) case data := &lt;-ch2: fmt.Println(\"CH2 的数据：\", data) &#125; &#125;&#125; 输出结果（部分） 1234567891011121314151617181920212223242526272829303132CH1 的数据： 0CH2 的数据： 0CH1 的数据： 1CH2 的数据： 1CH1 的数据： 2CH2 的数据： 2CH1 的数据： 3CH2 的数据： 3CH1 的数据： 4CH2 的数据： 4CH1 的数据： 5CH2 的数据： 5CH2 的数据： 6CH1 的数据： 6CH1 的数据： 7CH1 的数据： 8CH2 的数据： 7CH1 的数据： 9CH2 的数据： 8CH1 的数据： 10CH2 的数据： 9CH1 的数据： 11CH1 的数据： 12CH1 的数据： 13CH2 的数据： 10CH2 的数据： 11CH1 的数据： 14CH2 的数据： 12CH2 的数据： 13CH1 的数据： 15Process finished with exit code 130 (interrupted by signal 2: SIGINT) 这就是select的一个应用场景，从输出结果可以看到，CH1、CH2的输出结果不一样，谁先出数据就先选择谁；两个同时出就随机的选择一个。 2、定时器的使用比如上面的这段代码我想要在10秒之后程序就终止，我该如何处理呢？我们这里需要介绍一下Go语言的 time.After 123456789// After waits for the duration to elapse and then sends the current time// on the returned channel.// It is equivalent to NewTimer(d).C.// The underlying Timer is not recovered by the garbage collector// until the timer fires. If efficiency is a concern, use NewTimer// instead and call Timer.Stop if the timer is no longer needed.func After(d Duration) &lt;-chan Time &#123; return NewTimer(d).C&#125; 从源码来看，他的返回值类型是一个 &lt;-chan Time ,那就方便很多了 12345678910111213141516171819202122232425262728293031323334353637package mainimport ( \"fmt\" \"time\")func genChan() chan int &#123; out := make(chan int) go func() &#123; i := 0 for &#123; time.Sleep(time.Second) out &lt;- i i ++ &#125; &#125;() return out&#125;func main() &#123; var ch1, ch2 = genChan(), genChan() tm := time.After(10 * time.Second) // 加上10秒的定时 for &#123; select &#123; case data := &lt;- ch1: fmt.Println(\"CH1 的数据：\", data) case data := &lt;-ch2: fmt.Println(\"CH2 的数据：\", data) case &lt;-tm: return // 收到指令程序直接return &#125; &#125;&#125; 运行到10秒，代码自动退出。 9.3、传统同步机制Go语言除了CSP模型外，还是有传统同步机制的，比如互斥量 Mutex ，现在我们就用它举个例子：用互斥量实现 atomic 1234567891011121314151617181920212223242526272829303132333435package mainimport ( \"sync\" \"time\" \"fmt\")type atomicInt struct &#123; value int lock sync.Mutex&#125;func increment(a *atomicInt) &#123; a.lock.Lock() defer a.lock.Unlock() a.value ++&#125;func get(a *atomicInt) int &#123; a.lock.Lock() defer a.lock.Unlock() return a.value&#125;func main() &#123; var a atomicInt increment(&amp;a) go func() &#123; increment(&amp;a) &#125;() time.Sleep(time.Second) fmt.Println(get(&amp;a))&#125; 结果输出 1232Process finished with exit code 0 代码写完，可以用上面介绍的race来检查一下，是否有冲突，是否安全；当然这里还是不建议自己来造这些轮子的，直接使用系统的就可以了。系统提供了 atomic.AddInt32() 等等这些原子操作。 10. Http及其他标准库10.0、Http标准库介绍Go语言有很多的标准库，http库是最重要的之一，它对Http的封装也是非常完善的，之前我们有演示过服务端的一些基础使用，下面我们介绍一些客户端相关的使用 1、使用http客户端发送请求12345678910111213141516171819202122package mainimport ( \"net/http\" \"net/http/httputil\" \"fmt\")func main() &#123; response, err := http.Get(\"https://www.shengguocun.com\") if err != nil&#123; panic(err) &#125; defer response.Body.Close() ss, err := httputil.DumpResponse(response, true) if err != nil &#123; panic(err) &#125; fmt.Printf(\"%s \\n\", ss)&#125; 这里就把完整的头信息以及html的部分打印出来了。比如在我们现实的情境中，我们会根据UA做一些反作弊的策略，以及是否需要重定向到 M 端等等。这里的 http.Client 就能实现。 2、使用http.Client控制请求头请求头信息直接通过 request.Header.Add 添加就可以了 123456789101112131415161718192021222324package mainimport ( \"net/http\" \"net/http/httputil\" \"fmt\")func main() &#123; request, err := http.NewRequest(http.MethodGet,\"https://www.shengguocun.com\", nil) request.Header.Add(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\") response, err := http.DefaultClient.Do(request) if err != nil&#123; panic(err) &#125; defer response.Body.Close() ss, err := httputil.DumpResponse(response, true) if err != nil &#123; panic(err) &#125; fmt.Printf(\"%s \\n\", ss)&#125; 上面我们都用的是 DefaultClient ，我们也可以自己创建 client， 首先我们先看一下 Client 内部都有些什么 查看源码我们发现有一个 CheckRedirect ，我们发现这是一个检查重定向的函数。那我们就用它做一下演示 123456789101112131415161718192021222324252627282930package mainimport ( \"net/http\" \"net/http/httputil\" \"fmt\")func main() &#123; request, err := http.NewRequest(http.MethodGet,\"https://jim-sheng.github.io\", nil) request.Header.Add(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\") client := http.Client&#123; CheckRedirect: func(req *http.Request, via []*http.Request) error &#123; fmt.Println(\"重定向地址：\", req) return nil &#125;, &#125; response, err := client.Do(request) if err != nil&#123; panic(err) &#125; defer response.Body.Close() ss, err := httputil.DumpResponse(response, true) if err != nil &#123; panic(err) &#125; fmt.Printf(\"%s \\n\", ss)&#125; 输出结果（部分） 1234重定向地址： &amp;&#123;GET https://www.shengguocun.com/ 0 0 map[User-Agent:[Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36] Referer:[https://jim-sheng.github.io]] &lt;nil&gt; &lt;nil&gt; 0 [] false map[] map[] &lt;nil&gt; map[] &lt;nil&gt; &lt;nil&gt; 0xc42012c090 &lt;nil&gt;&#125;HTTP/2.0 200 OKAccept-Ranges: bytesAccess-Control-Allow-Origin: * 我们可以看到具体的重定向的地址 https://www.shengguocun.com/ ，其它的 1234// Transport specifies the mechanism by which individual// HTTP requests are made.// If nil, DefaultTransport is used.Transport RoundTripper 主要用于代理 12345678910// Jar specifies the cookie jar.//// The Jar is used to insert relevant cookies into every// outbound Request and is updated with the cookie values// of every inbound Response. The Jar is consulted for every// redirect that the Client follows.//// If Jar is nil, cookies are only sent if they are explicitly// set on the Request.Jar CookieJar 主要用于模拟登录用的 123456789101112131415161718// Timeout specifies a time limit for requests made by this// Client. The timeout includes connection time, any// redirects, and reading the response body. The timer remains// running after Get, Head, Post, or Do return and will// interrupt reading of the Response.Body.//// A Timeout of zero means no timeout.//// The Client cancels requests to the underlying Transport// using the Request.Cancel mechanism. Requests passed// to Client.Do may still set Request.Cancel; both will// cancel the request.//// For compatibility, the Client will also use the deprecated// CancelRequest method on Transport if found. New// RoundTripper implementations should use Request.Cancel// instead of implementing CancelRequest.Timeout time.Duration 主要设置超时的 3、http服务器性能分析还是使用之前的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( \"net/http\" \"os\" \"io/ioutil\" _ \"net/http/pprof\")type appHandler func(writer http.ResponseWriter, request *http.Request) errorfunc errWrapper(handler appHandler) func(http.ResponseWriter, *http.Request) &#123; return func(writer http.ResponseWriter, request *http.Request) &#123; err := handler(writer, request) if err != nil &#123; switch &#123; case os.IsNotExist(err): http.Error(writer, http.StatusText(http.StatusNotFound), http.StatusNotFound) &#125; &#125; &#125;&#125;func main() &#123; http.HandleFunc(\"/list/\", errWrapper(func(writer http.ResponseWriter, request *http.Request) error &#123; path := request.URL.Path[len(\"/list/\"):] file, err := os.Open(path) if err != nil &#123; return err &#125; defer file.Close() all, err := ioutil.ReadAll(file) if err != nil &#123; return err &#125; writer.Write(all) return nil &#125;)) err := http.ListenAndServe(\":2872\", nil) if err != nil &#123; panic(err) &#125;&#125; 还是一样的代码，只不过import多了一个 import _ &quot;net/http/pprof&quot; , 为什么会多一个下划线呢？因为代码没有使用到，会报错，加一个下划线就可以了。重启代码，我们就可以访问 http://localhost:2872/debug/pprof/ 了 里面的 stacktrace 都可以查看到 我们可以查看 pprof 的源码，继续查看它的其他的使用方式 123// Or to look at a 30-second CPU profile://// go tool pprof http://localhost:6060/debug/pprof/profile 比如这一段，我们可以查看30秒的CPU的使用情况。可以终端敲下该命令（替换成自己的监听的端口），获取出结果后敲下 web 命令就可以看下具体的代码哪些地方需要优化。其他的使用使用方式就不一一罗列了，有兴趣可以继续查阅。 10.1、其他库其它的标准库就不过多罗列了， https://studygolang.com/pkgdoc 上面的中文版的文档已经非常详细了 。 11. 总结Go语言给我们展现了不一样的世界观，没有类、继承、多态、重载，没有构造函数，没有断言，没有try/catch等等；上面是在学习Go语言的过程中，记录下来的笔记；也可能有部分地方存在偏颇，还望指点～～～ 欢迎关注个人微信公众号","tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://www.shengguocun.com/tags/Go语言/"},{"name":"入门","slug":"入门","permalink":"https://www.shengguocun.com/tags/入门/"}]},{"title":"GDB抓虫之旅","date":"2018-03-15T05:59:24.000Z","path":"/blog/2018/03/15/taste-gdb/","text":"前言1234567891011问: gdb是什么？答: 强大的UNIX下命令行调试工具。问: gdb能干什么？答: 让你随心所欲的驾驭你的程序；Start、Stop、Examine、Change。问: 我们为什么要学习gdb？答: 欲善其事，必先利其器；利用gdb进一步的定位程序异常。问: 本次分享的宗旨?答: gdb的介绍和使用入门，为大家抓虫多提供一个选择。 抓虫从0开始前期准备 1.包含有调试信息的可执行文件 2.编译时加-g选项即可，不建议开优化选项 GDB的启动1234gdb &lt;program&gt;gdb &lt;program&gt; coregdb &lt;program&gt; &lt;PID&gt;(gdb) file &lt;program&gt; 抓虫流程 实战1 : GDB基础命令的使用1.1、示例程序(example_1.cpp) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int foo(int m, int n)&#123; return 1;&#125;int foo(int n)&#123; int result=0; for (int i=0;i&lt;=n;i++) &#123; result+=n; &#125; return result;&#125;int main()&#123; string s1=\"dafdf\"; char * s2;// s1=s2; int sum =0; for (int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; cout&lt;&lt;\"result[1-100]=\"&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;\"result[1-250]=\"&lt;&lt;foo(250)&lt;&lt;endl; return 0;&#125; 1.2、调试准备编译命令：g++ -g -Wall -o example_1 example_1.cpp 1.3、启动gdb 12345678$ gdb example_1GNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\"...Using host libthread_db library \"/lib64/tls/libthread_db.so.1\". 1.4、辅助性命令 12345678910111213141516(gdb) cd ..Working directory /home/work/testers/sgc.(gdb) shell lsautotest client Makefile spanti spantispam_if.h study(gdb) cd study/Working directory /home/work/testers/sgc/study.(gdb) pwdWorking directory /home/work/testers/sgc/study.(gdb) help runStart debugged program. You may specify arguments to give it.Args may include \"*\", or \"[...]\"; they are expanded using \"sh\".Input and output redirection with \"&gt;\", \"&lt;\", or \"&gt;&gt;\" are also allowed.With no arguments, uses arguments last specified (with \"run\" or \"set args\").To cancel previous arguments and run with no arguments,use \"set args\" without arguments. 1.5、设置断点命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445//查看源代码信息(gdb) l17 result+=n;18 &#125;19 return result;2021 &#125;2223 int main()24 &#123;2526 string s1=\"dafdf\";(gdb) l 11 #include &lt;iostream&gt;2 #include &lt;string&gt;345 using namespace std;6 int foo(int m, int n)7 &#123;89 return 1;10(gdb) l example_1.cpp:1611 &#125;12 int foo(int n)13 &#123;14 int result=0;15 for (int i=0;i&lt;=n;i++)16 &#123;17 result+=n;18 &#125;19 return result;20(gdb) l foo(int)89 return 1;1011 &#125;12 int foo(int n)13 &#123;14 int result=0;15 for (int i=0;i&lt;=n;i++)16 &#123;17 result+=n; 123456789//设置断点(gdb) b 17Breakpoint 1 at 0x400c07: file example_1.cpp, line 17.(gdb) b mainBreakpoint 2 at 0x400c27: file example_1.cpp, line 26.(gdb) info brNum Type Disp Enb Address What1 breakpoint keep y 0x0000000000400c07 in foo(int) at example_1.cpp:172 breakpoint keep y 0x0000000000400c27 in main at example_1.cpp:26 1.6、执行控制命令 12345678910111213(gdb) rStarting program: /home/work/testers/sgc/study/example_1Breakpoint 2, main () at example_1.cpp:2626 string s1=\"dafdf\";(gdb) cContinuing.result[1-100]=5050Breakpoint 1, foo (n=250) at example_1.cpp:1717 result+=n;(gdb) n15 for (int i=0;i&lt;=n;i++) 1.7、程序信息查看命令 123456789101112131415161718192021222324252627282930313233//查看变量信息(gdb) p result$1 = 250(gdb) p s1$2 = 1431655765 (gdb) disp result1: result = 250(gdb) cContinuing.Breakpoint 1, foo (n=250) at example_1.cpp:1717 result+=n;1: result = 250(gdb) info localsi = 1result = 250//查看栈信息(gdb) bt#0 foo (n=250) at example_1.cpp:17#1 0x0000000000400cc1 in main () at example_1.cpp:38(gdb) info fStack level 0, frame at 0x7fbffff8a0: rip = 0x400c07 in foo(int) (example_1.cpp:17); saved rip 0x400cc1 called by frame at 0x7fbffff910 source language c++. Arglist at 0x7fbffff890, args: n=250 Locals at 0x7fbffff890, Previous frame's sp is 0x7fbffff8a0 Saved registers: rbp at 0x7fbffff890, rip at 0x7fbffff898(gdb) f 0#0 foo (n=250) at example_1.cpp:1717 result+=n; 1.8、修改环境命令 1234567891011121314(gdb) set var i=97(gdb) p i$5 = 97(gdb) print i=98$6 = 98(gdb) ignore 1 300Will ignore next 300 crossings of breakpoint 1.(gdb) finishRun till exit from #0 foo (n=250) at example_1.cpp:170x0000000000400cc1 in main () at example_1.cpp:3838 cout&lt;&lt;\"result[1-250]=\"&lt;&lt;foo(250)&lt;&lt;endl;Value returned is $8 = 38500(gdb) quitThe program is running. Exit anyway? (y or n) y 不要放过core文件 问 ：Core文件是什么？答 ：a disk file containing an image of the process’s memory at the time of termination 问 ：Core的作用？答 ：&nbsp;&nbsp;&nbsp;&nbsp;1、让你在调试时，不用花费大量等待程序出错；&nbsp;&nbsp;&nbsp;&nbsp;2、让你避免了单步调试的烦恼&nbsp;&nbsp;&nbsp;&nbsp;3、让你定位错误所在 启动方式1$ gdb &lt;program&gt; core 查看程序信息的常用命令1、查看栈信息：bt, f n, up/down，info frame2、查看变量信息：info args|locals 实战2 : core文件调试2.1、示例程序(crash2.c) 123456789101112#include &lt;string.h&gt;void Strcpy(char *to , char *from)&#123; strcpy(to , from);&#125;int main()&#123; char *s = NULL; Strcpy(s, \"abcdefg\"); return 0;&#125; 2.2、查看信息 123456789101112131415161718192021222324252627282930$ gdb ./crash2 core.19562GNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\"...Using host libthread_db library \"/lib64/tls/libthread_db.so.1\".Core was generated by `./crash2'.Program terminated with signal 11, Segmentation fault.Reading symbols from /lib64/tls/libc.so.6...done.Loaded symbols for /lib64/tls/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...done.Loaded symbols for /lib64/ld-linux-x86-64.so.2#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6(gdb) bt#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6#1 0x00000000004004c5 in Strcpy (to=0x0, from=0x4005dc \"abcdefg\") at crash2.c:5#2 0x00000000004004e5 in main () at crash2.c:10(gdb) f 0#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6(gdb) up#1 0x00000000004004c5 in Strcpy (to=0x0, from=0x4005dc \"abcdefg\") at crash2.c:55 strcpy(to , from);(gdb) info argsto = 0x0from = 0x4005dc \"abcdefg\"//至此，已经清楚的发现了问题所在，to指针为空 进阶之多线程程序调试多线程调试常用命令123456$ info &lt;...&gt; // 强大的查看命令，如info threads$ attach/detach &lt;pid&gt; // 挂载到进程$ thread &lt;thread_no&gt; // 切换到线程$ thread apply &lt;thread_no_list&gt; &lt;cmd&gt; // 对于list中的thread，执行cmd$ break &lt;linenum&gt; thread &lt;threadno&gt; if ... 实战3 : 多线程程序调试3.1、正常的示例程序(good_thread.c) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#define MAX 10pthread_t thread[2];pthread_mutex_t mut;int number=0, i;void *thread1()&#123; printf (\"thread1 : I'm thread 1\\n\"); for (i = 0; i &lt; MAX; i++) &#123; printf(\"thread1 : number = %d\\n\",number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(2); &#125; printf(\"thread1 :主函数在等我完成任务吗？\\n\"); pthread_exit(NULL);&#125;void *thread2()&#123; printf(\"thread2 : I'm thread 2\\n\"); for (i = 0; i &lt; MAX; i++) &#123; printf(\"thread2 : number = %d\\n\",number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(3); &#125; printf(\"thread2 :主函数在等我完成任务吗？\\n\"); pthread_exit(NULL);&#125;void thread_create(void)&#123; int temp; memset(&amp;thread, 0, sizeof(thread)); //comment1 /*创建线程*/ if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0) //comment2 printf(\"线程1创建失败!\\n\"); else printf(\"线程1被创建\\n\"); if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0) //comment3 printf(\"线程2创建失败\"); else printf(\"线程2被创建\\n\");&#125;void thread_wait(void)&#123; /*等待线程结束*/ if(thread[0] !=0) &#123; //comment4 pthread_join(thread[0],NULL); printf(\"线程1已经结束\\n\"); &#125; if(thread[1] !=0) &#123; //comment5 pthread_join(thread[1],NULL); printf(\"线程2已经结束\\n\"); &#125;&#125;int main()&#123; /*用默认属性初始化互斥锁*/ pthread_mutex_init(&amp;mut,NULL); printf(\"我是主函数哦，我正在创建线程，呵呵\\n\"); thread_create(); printf(\"我是主函数哦，我正在等待线程完成任务阿，呵呵\\n\"); thread_wait(); return 0;&#125; 3.2、演示过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(gdb)21 printf (\"thread1 : I'm thread 1\\n\");2223 for (i = 0; i &lt; MAX; i++)2425 &#123;2627 printf(\"thread1 : number = %d\\n\",number);2829 pthread_mutex_lock(&amp;mut);(gdb) b 27Breakpoint 1 at 0x40079e: file good_thread.c, line 27.(gdb)51 for (i = 0; i &lt; MAX; i++)5253 &#123;5455 printf(\"thread2 : number = %d\\n\",number);5657 pthread_mutex_lock(&amp;mut);5859 number++;(gdb) b 57Breakpoint 2 at 0x400838: file good_thread.c, line 57.(gdb) rStarting program: /home/work/testers/sgc/study/goodthread[Thread debugging using libthread_db enabled][New Thread 182894112416 (LWP 22783)]ÎÒÊÇÖ÷º¯ÊýÅ¶£¬ÎÒÕýÔÚ´´½¨Ïß³Ì£¬ºÇºÇ[New Thread 1084229984 (LWP 22786)]Ïß³Ì1±»´´½¨thread1 : I'm thread 1[Switching to Thread 1084229984 (LWP 22786)]Breakpoint 1, thread1 () at good_thread.c:2727 printf(\"thread1 : number = %d\\n\",number);(gdb) bt#0 thread1 () at good_thread.c:27#1 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0#2 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6#3 0x0000000000000000 in ?? ()(gdb) info threads[New Thread 1094719840 (LWP 22787)] 3 Thread 1094719840 (LWP 22787) 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6* 2 Thread 1084229984 (LWP 22786) thread1 () at good_thread.c:27 1 Thread 182894112416 (LWP 22783) 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6(gdb) thread 1[Switching to thread 1 (Thread 182894112416 (LWP 22783))]#0 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6(gdb) bt#0 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6#1 0x000000302b805d86 in do_clone () from /lib64/tls/libpthread.so.0#2 0x000000302b806846 in pthread_create@@GLIBC_2.2.5 () from /lib64/tls/libpthread.so.0#3 0x00000000004008fd in thread_create () at good_thread.c:91#4 0x00000000004009a9 in main () at good_thread.c:135 3.3、死锁示例程序（multi_thread.c） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define THREAD_NUM 20pthread_mutex_t AccountA_mutex;pthread_mutex_t AccountB_mutex;struct Account &#123; char account_name[1]; int balance;&#125;;struct Account accountA = &#123;'A', 100000&#125;;struct Account accountB = &#123;'B', 200000&#125;;void * accountAB (void* amount_ptr) &#123; int amount = *((int*)amount_ptr); pthread_mutex_lock(&amp;AccountA_mutex); if (accountA.balance &lt; amount) &#123; printf(\"There is not enough memory in Account A!\\n\"); pthread_mutex_unlock(&amp;AccountA_mutex); pthread_exit((void *)1); &#125; accountA.balance -=amount; sleep(2); pthread_mutex_lock(&amp;AccountB_mutex); accountB.balance +=amount; pthread_mutex_unlock(&amp;AccountA_mutex); pthread_mutex_unlock(&amp;AccountB_mutex);&#125;void * accountBA (void* amount_ptr) &#123; int amount = *((int*)amount_ptr); pthread_mutex_lock(&amp;AccountB_mutex); if (accountB.balance &lt; amount) &#123; printf(\"There is not enough memory in Account B!\\n\"); pthread_mutex_unlock(&amp;AccountB_mutex); pthread_exit((void *)1); &#125; accountB.balance -=amount; pthread_mutex_lock(&amp;AccountA_mutex); accountA.balance +=amount; pthread_mutex_unlock(&amp;AccountB_mutex); pthread_mutex_unlock(&amp;AccountA_mutex);&#125;int main(int argc, char* argv[]) &#123; int threadid[THREAD_NUM]; pthread_t pthread[THREAD_NUM]; void* thResState; int res, flag; int transfer_amount[THREAD_NUM] = &#123;100, 200, 300, 400,100,200,300,400,500,600,700,800,900,800,700,600,500,400,300,200&#125;; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM); for(flag=0; flag&lt;THREAD_NUM; flag++)&#123; if(flag%2 == 0)&#123; if (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountAB, \\ (void*)&amp;transfer_amount[flag]) &lt; 0)&#123; printf(\"Thread %d creation failed\\n\", flag); exit (1); &#125; &#125; else&#123; if (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountBA, \\ (void*)&amp;transfer_amount[flag]) &lt; 0) &#123; printf(\"Thread %d creation failed\\n\", flag); exit (1); &#125; &#125; &#125; for(flag=0; flag&lt;THREAD_NUM; flag++)&#123; res = pthread_join(pthread[flag], &amp;thResState); if (res != 0)&#123; perror(\"Thread join failed\"); exit(-1); &#125; printf(\"thread success id %u state code %d\\n\",threadid[flag],thResState); &#125; printf(\"Transitions are in progress..\"); printf(\"\\nAll the money is transferred !!\\n\");&#125; 3.4、错误定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240$ gcc -g -o multi_thread multi_thread.c –lpthread$ ./multi_thread$ ps -eLF |grep multiwork 21675 19997 21675 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21676 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21677 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21678 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21679 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21680 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21681 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21682 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21683 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21684 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21685 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21686 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21687 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21688 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21689 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21690 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21691 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21692 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21693 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21694 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21695 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_thread$ gdbGNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\".(gdb) attach 21680Attaching to process 21680Reading symbols from /home/work/testers/sgc/study/multi_thread...done.Using host libthread_db library \"/lib64/tls/libthread_db.so.1\".Reading symbols from /lib64/tls/libpthread.so.0...done.[Thread debugging using libthread_db enabled][New Thread 182894112416 (LWP 21675)][New Thread 1283537248 (LWP 21695)][New Thread 1273047392 (LWP 21694)][New Thread 1262557536 (LWP 21693)][New Thread 1252067680 (LWP 21692)][New Thread 1241577824 (LWP 21691)][New Thread 1231087968 (LWP 21690)][New Thread 1220598112 (LWP 21689)][New Thread 1210108256 (LWP 21688)][New Thread 1199618400 (LWP 21687)][New Thread 1189128544 (LWP 21686)][New Thread 1178638688 (LWP 21685)][New Thread 1168148832 (LWP 21684)][New Thread 1157658976 (LWP 21683)][New Thread 1147169120 (LWP 21682)][New Thread 1136679264 (LWP 21681)][New Thread 1126189408 (LWP 21680)][New Thread 1115699552 (LWP 21679)][New Thread 1105209696 (LWP 21678)][New Thread 1094719840 (LWP 21677)][New Thread 1084229984 (LWP 21676)]Loaded symbols for /lib64/tls/libpthread.so.0Reading symbols from /lib64/tls/libc.so.6...done.Loaded symbols for /lib64/tls/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...done.Loaded symbols for /lib64/ld-linux-x86-64.so.20x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0(gdb) bt#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000432041e0 in ?? ()#2 0x00000000432049f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()(gdb) info threads 21 Thread 1084229984 (LWP 21676) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 20 Thread 1094719840 (LWP 21677) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 19 Thread 1105209696 (LWP 21678) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 18 Thread 1115699552 (LWP 21679) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 17 Thread 1126189408 (LWP 21680) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 16 Thread 1136679264 (LWP 21681) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 15 Thread 1147169120 (LWP 21682) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 14 Thread 1157658976 (LWP 21683) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 13 Thread 1168148832 (LWP 21684) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 12 Thread 1178638688 (LWP 21685) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 11 Thread 1189128544 (LWP 21686) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 10 Thread 1199618400 (LWP 21687) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 9 Thread 1210108256 (LWP 21688) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 8 Thread 1220598112 (LWP 21689) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 7 Thread 1231087968 (LWP 21690) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 6 Thread 1241577824 (LWP 21691) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 5 Thread 1252067680 (LWP 21692) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 4 Thread 1262557536 (LWP 21693) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 3 Thread 1273047392 (LWP 21694) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 2 Thread 1283537248 (LWP 21695) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 1 Thread 182894112416 (LWP 21675) 0x000000302b806ffb in pthread_join () from /lib64/tls/libpthread.so.0(gdb) thread apply all btThread 21 (Thread 1084229984 (LWP 21676)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000000000000 in ?? ()Thread 20 (Thread 1094719840 (LWP 21677)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000414011e0 in ?? ()#2 0x00000000414019f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 19 (Thread 1105209696 (LWP 21678)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000041e021e0 in ?? ()#2 0x0000000041e029f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 18 (Thread 1115699552 (LWP 21679)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000428031e0 in ?? ()#2 0x00000000428039f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 17 (Thread 1126189408 (LWP 21680)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000432041e0 in ?? ()#2 0x00000000432049f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 16 (Thread 1136679264 (LWP 21681)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000043c051e0 in ?? ()#2 0x0000000043c059f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 15 (Thread 1147169120 (LWP 21682)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000446061e0 in ?? ()#2 0x00000000446069f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Thread 14 (Thread 1157658976 (LWP 21683)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000450071e0 in ?? ()#2 0x00000000450079f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 13 (Thread 1168148832 (LWP 21684)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000045a081e0 in ?? ()#2 0x0000000045a089f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 12 (Thread 1178638688 (LWP 21685)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000464091e0 in ?? ()#2 0x00000000464099f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 11 (Thread 1189128544 (LWP 21686)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000046e0a1e0 in ?? ()#2 0x0000000046e0a9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 10 (Thread 1199618400 (LWP 21687)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004780b1e0 in ?? ()#2 0x000000004780b9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 9 (Thread 1210108256 (LWP 21688)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004820c1e0 in ?? ()#2 0x000000004820c9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 8 (Thread 1220598112 (LWP 21689)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000048c0d1e0 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---#2 0x0000000048c0d9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 7 (Thread 1231087968 (LWP 21690)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004960e1e0 in ?? ()#2 0x000000004960e9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 6 (Thread 1241577824 (LWP 21691)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004a00f1e0 in ?? ()#2 0x000000004a00f9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 5 (Thread 1252067680 (LWP 21692)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004aa101e0 in ?? ()#2 0x000000004aa109f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 4 (Thread 1262557536 (LWP 21693)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004b4111e0 in ?? ()#2 0x000000004b4119f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 3 (Thread 1273047392 (LWP 21694)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004be121e0 in ?? ()#2 0x000000004be129f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 2 (Thread 1283537248 (LWP 21695)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004c8131e0 in ?? ()#2 0x000000004c8139f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Thread 1 (Thread 182894112416 (LWP 21675)):#0 0x000000302b806ffb in pthread_join () from /lib64/tls/libpthread.so.0#1 0x0000000000400b69 in main (argc=1, argv=0x7fbffffa08) at multi_thread.c:76 总结GDB是一个好用的抓虫工具，随意控制进程，随便查看内存和环境；上述只是新手学习过程中的一些记录，欢迎深入探讨。","tags":[{"name":"GDB","slug":"GDB","permalink":"https://www.shengguocun.com/tags/GDB/"}]},{"title":"Hello World","date":"2018-01-12T06:29:51.000Z","path":"/blog/2018/01/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]