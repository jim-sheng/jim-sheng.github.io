[{"title":"GDB抓虫之旅","date":"2018-03-15T05:59:24.000Z","path":"/blog/2018/03/15/taste-gdb/","text":"前言1234567891011问: gdb是什么？答: 强大的UNIX下命令行调试工具。问: gdb能干什么？答: 让你随心所欲的驾驭你的程序；Start、Stop、Examine、Change。问: 我们为什么要学习gdb？答: 欲善其事，必先利其器；利用gdb进一步的定位程序异常。问: 本次分享的宗旨?答: gdb的介绍和使用入门，为大家抓虫多提供一个选择。 抓虫从0开始前期准备 1.包含有调试信息的可执行文件 2.编译时加-g选项即可，不建议开优化选项 GDB的启动1234gdb &lt;program&gt;gdb &lt;program&gt; coregdb &lt;program&gt; &lt;PID&gt;(gdb) file &lt;program&gt; 抓虫流程 实战1 : GDB基础命令的使用1.1、示例程序(example_1.cpp) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int foo(int m, int n)&#123; return 1;&#125;int foo(int n)&#123; int result=0; for (int i=0;i&lt;=n;i++) &#123; result+=n; &#125; return result;&#125;int main()&#123; string s1=\"dafdf\"; char * s2;// s1=s2; int sum =0; for (int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; cout&lt;&lt;\"result[1-100]=\"&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;\"result[1-250]=\"&lt;&lt;foo(250)&lt;&lt;endl; return 0;&#125; 1.2、调试准备编译命令：g++ -g -Wall -o example_1 example_1.cpp 1.3、启动gdb 12345678$ gdb example_1GNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\"...Using host libthread_db library \"/lib64/tls/libthread_db.so.1\". 1.4、辅助性命令 12345678910111213141516(gdb) cd ..Working directory /home/work/testers/sgc.(gdb) shell lsautotest client Makefile spanti spantispam_if.h study(gdb) cd study/Working directory /home/work/testers/sgc/study.(gdb) pwdWorking directory /home/work/testers/sgc/study.(gdb) help runStart debugged program. You may specify arguments to give it.Args may include \"*\", or \"[...]\"; they are expanded using \"sh\".Input and output redirection with \"&gt;\", \"&lt;\", or \"&gt;&gt;\" are also allowed.With no arguments, uses arguments last specified (with \"run\" or \"set args\").To cancel previous arguments and run with no arguments,use \"set args\" without arguments. 1.5、设置断点命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445//查看源代码信息(gdb) l17 result+=n;18 &#125;19 return result;2021 &#125;2223 int main()24 &#123;2526 string s1=\"dafdf\";(gdb) l 11 #include &lt;iostream&gt;2 #include &lt;string&gt;345 using namespace std;6 int foo(int m, int n)7 &#123;89 return 1;10(gdb) l example_1.cpp:1611 &#125;12 int foo(int n)13 &#123;14 int result=0;15 for (int i=0;i&lt;=n;i++)16 &#123;17 result+=n;18 &#125;19 return result;20(gdb) l foo(int)89 return 1;1011 &#125;12 int foo(int n)13 &#123;14 int result=0;15 for (int i=0;i&lt;=n;i++)16 &#123;17 result+=n; 123456789//设置断点(gdb) b 17Breakpoint 1 at 0x400c07: file example_1.cpp, line 17.(gdb) b mainBreakpoint 2 at 0x400c27: file example_1.cpp, line 26.(gdb) info brNum Type Disp Enb Address What1 breakpoint keep y 0x0000000000400c07 in foo(int) at example_1.cpp:172 breakpoint keep y 0x0000000000400c27 in main at example_1.cpp:26 1.6、执行控制命令 12345678910111213(gdb) rStarting program: /home/work/testers/sgc/study/example_1Breakpoint 2, main () at example_1.cpp:2626 string s1=\"dafdf\";(gdb) cContinuing.result[1-100]=5050Breakpoint 1, foo (n=250) at example_1.cpp:1717 result+=n;(gdb) n15 for (int i=0;i&lt;=n;i++) 1.7、程序信息查看命令 123456789101112131415161718192021222324252627282930313233//查看变量信息(gdb) p result$1 = 250(gdb) p s1$2 = 1431655765 (gdb) disp result1: result = 250(gdb) cContinuing.Breakpoint 1, foo (n=250) at example_1.cpp:1717 result+=n;1: result = 250(gdb) info localsi = 1result = 250//查看栈信息(gdb) bt#0 foo (n=250) at example_1.cpp:17#1 0x0000000000400cc1 in main () at example_1.cpp:38(gdb) info fStack level 0, frame at 0x7fbffff8a0: rip = 0x400c07 in foo(int) (example_1.cpp:17); saved rip 0x400cc1 called by frame at 0x7fbffff910 source language c++. Arglist at 0x7fbffff890, args: n=250 Locals at 0x7fbffff890, Previous frame's sp is 0x7fbffff8a0 Saved registers: rbp at 0x7fbffff890, rip at 0x7fbffff898(gdb) f 0#0 foo (n=250) at example_1.cpp:1717 result+=n; 1.8、修改环境命令 1234567891011121314(gdb) set var i=97(gdb) p i$5 = 97(gdb) print i=98$6 = 98(gdb) ignore 1 300Will ignore next 300 crossings of breakpoint 1.(gdb) finishRun till exit from #0 foo (n=250) at example_1.cpp:170x0000000000400cc1 in main () at example_1.cpp:3838 cout&lt;&lt;\"result[1-250]=\"&lt;&lt;foo(250)&lt;&lt;endl;Value returned is $8 = 38500(gdb) quitThe program is running. Exit anyway? (y or n) y 不要放过core文件 问 ：Core文件是什么？答 ：a disk file containing an image of the process’s memory at the time of termination 问 ：Core的作用？答 ：&nbsp;&nbsp;&nbsp;&nbsp;1、让你在调试时，不用花费大量等待程序出错；&nbsp;&nbsp;&nbsp;&nbsp;2、让你避免了单步调试的烦恼&nbsp;&nbsp;&nbsp;&nbsp;3、让你定位错误所在 启动方式1$ gdb &lt;program&gt; core 查看程序信息的常用命令1、查看栈信息：bt, f n, up/down，info frame2、查看变量信息：info args|locals 实战2 : core文件调试2.1、示例程序(crash2.c) 123456789101112#include &lt;string.h&gt;void Strcpy(char *to , char *from)&#123; strcpy(to , from);&#125;int main()&#123; char *s = NULL; Strcpy(s, \"abcdefg\"); return 0;&#125; 2.2、查看信息 123456789101112131415161718192021222324252627282930$ gdb ./crash2 core.19562GNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\"...Using host libthread_db library \"/lib64/tls/libthread_db.so.1\".Core was generated by `./crash2'.Program terminated with signal 11, Segmentation fault.Reading symbols from /lib64/tls/libc.so.6...done.Loaded symbols for /lib64/tls/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...done.Loaded symbols for /lib64/ld-linux-x86-64.so.2#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6(gdb) bt#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6#1 0x00000000004004c5 in Strcpy (to=0x0, from=0x4005dc \"abcdefg\") at crash2.c:5#2 0x00000000004004e5 in main () at crash2.c:10(gdb) f 0#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6(gdb) up#1 0x00000000004004c5 in Strcpy (to=0x0, from=0x4005dc \"abcdefg\") at crash2.c:55 strcpy(to , from);(gdb) info argsto = 0x0from = 0x4005dc \"abcdefg\"//至此，已经清楚的发现了问题所在，to指针为空 进阶之多线程程序调试多线程调试常用命令123456$ info &lt;...&gt; // 强大的查看命令，如info threads$ attach/detach &lt;pid&gt; // 挂载到进程$ thread &lt;thread_no&gt; // 切换到线程$ thread apply &lt;thread_no_list&gt; &lt;cmd&gt; // 对于list中的thread，执行cmd$ break &lt;linenum&gt; thread &lt;threadno&gt; if ... 实战3 : 多线程程序调试3.1、正常的示例程序(good_thread.c) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#define MAX 10pthread_t thread[2];pthread_mutex_t mut;int number=0, i;void *thread1()&#123; printf (\"thread1 : I'm thread 1\\n\"); for (i = 0; i &lt; MAX; i++) &#123; printf(\"thread1 : number = %d\\n\",number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(2); &#125; printf(\"thread1 :主函数在等我完成任务吗？\\n\"); pthread_exit(NULL);&#125;void *thread2()&#123; printf(\"thread2 : I'm thread 2\\n\"); for (i = 0; i &lt; MAX; i++) &#123; printf(\"thread2 : number = %d\\n\",number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(3); &#125; printf(\"thread2 :主函数在等我完成任务吗？\\n\"); pthread_exit(NULL);&#125;void thread_create(void)&#123; int temp; memset(&amp;thread, 0, sizeof(thread)); //comment1 /*创建线程*/ if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0) //comment2 printf(\"线程1创建失败!\\n\"); else printf(\"线程1被创建\\n\"); if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0) //comment3 printf(\"线程2创建失败\"); else printf(\"线程2被创建\\n\");&#125;void thread_wait(void)&#123; /*等待线程结束*/ if(thread[0] !=0) &#123; //comment4 pthread_join(thread[0],NULL); printf(\"线程1已经结束\\n\"); &#125; if(thread[1] !=0) &#123; //comment5 pthread_join(thread[1],NULL); printf(\"线程2已经结束\\n\"); &#125;&#125;int main()&#123; /*用默认属性初始化互斥锁*/ pthread_mutex_init(&amp;mut,NULL); printf(\"我是主函数哦，我正在创建线程，呵呵\\n\"); thread_create(); printf(\"我是主函数哦，我正在等待线程完成任务阿，呵呵\\n\"); thread_wait(); return 0;&#125; 3.2、演示过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(gdb)21 printf (\"thread1 : I'm thread 1\\n\");2223 for (i = 0; i &lt; MAX; i++)2425 &#123;2627 printf(\"thread1 : number = %d\\n\",number);2829 pthread_mutex_lock(&amp;mut);(gdb) b 27Breakpoint 1 at 0x40079e: file good_thread.c, line 27.(gdb)51 for (i = 0; i &lt; MAX; i++)5253 &#123;5455 printf(\"thread2 : number = %d\\n\",number);5657 pthread_mutex_lock(&amp;mut);5859 number++;(gdb) b 57Breakpoint 2 at 0x400838: file good_thread.c, line 57.(gdb) rStarting program: /home/work/testers/sgc/study/goodthread[Thread debugging using libthread_db enabled][New Thread 182894112416 (LWP 22783)]ÎÒÊÇÖ÷º¯ÊýÅ¶£¬ÎÒÕýÔÚ´´½¨Ïß³Ì£¬ºÇºÇ[New Thread 1084229984 (LWP 22786)]Ïß³Ì1±»´´½¨thread1 : I'm thread 1[Switching to Thread 1084229984 (LWP 22786)]Breakpoint 1, thread1 () at good_thread.c:2727 printf(\"thread1 : number = %d\\n\",number);(gdb) bt#0 thread1 () at good_thread.c:27#1 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0#2 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6#3 0x0000000000000000 in ?? ()(gdb) info threads[New Thread 1094719840 (LWP 22787)] 3 Thread 1094719840 (LWP 22787) 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6* 2 Thread 1084229984 (LWP 22786) thread1 () at good_thread.c:27 1 Thread 182894112416 (LWP 22783) 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6(gdb) thread 1[Switching to thread 1 (Thread 182894112416 (LWP 22783))]#0 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6(gdb) bt#0 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6#1 0x000000302b805d86 in do_clone () from /lib64/tls/libpthread.so.0#2 0x000000302b806846 in pthread_create@@GLIBC_2.2.5 () from /lib64/tls/libpthread.so.0#3 0x00000000004008fd in thread_create () at good_thread.c:91#4 0x00000000004009a9 in main () at good_thread.c:135 3.3、死锁示例程序（multi_thread.c） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define THREAD_NUM 20pthread_mutex_t AccountA_mutex;pthread_mutex_t AccountB_mutex;struct Account &#123; char account_name[1]; int balance;&#125;;struct Account accountA = &#123;'A', 100000&#125;;struct Account accountB = &#123;'B', 200000&#125;;void * accountAB (void* amount_ptr) &#123; int amount = *((int*)amount_ptr); pthread_mutex_lock(&amp;AccountA_mutex); if (accountA.balance &lt; amount) &#123; printf(\"There is not enough memory in Account A!\\n\"); pthread_mutex_unlock(&amp;AccountA_mutex); pthread_exit((void *)1); &#125; accountA.balance -=amount; sleep(2); pthread_mutex_lock(&amp;AccountB_mutex); accountB.balance +=amount; pthread_mutex_unlock(&amp;AccountA_mutex); pthread_mutex_unlock(&amp;AccountB_mutex);&#125;void * accountBA (void* amount_ptr) &#123; int amount = *((int*)amount_ptr); pthread_mutex_lock(&amp;AccountB_mutex); if (accountB.balance &lt; amount) &#123; printf(\"There is not enough memory in Account B!\\n\"); pthread_mutex_unlock(&amp;AccountB_mutex); pthread_exit((void *)1); &#125; accountB.balance -=amount; pthread_mutex_lock(&amp;AccountA_mutex); accountA.balance +=amount; pthread_mutex_unlock(&amp;AccountB_mutex); pthread_mutex_unlock(&amp;AccountA_mutex);&#125;int main(int argc, char* argv[]) &#123; int threadid[THREAD_NUM]; pthread_t pthread[THREAD_NUM]; void* thResState; int res, flag; int transfer_amount[THREAD_NUM] = &#123;100, 200, 300, 400,100,200,300,400,500,600,700,800,900,800,700,600,500,400,300,200&#125;; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM); for(flag=0; flag&lt;THREAD_NUM; flag++)&#123; if(flag%2 == 0)&#123; if (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountAB, \\ (void*)&amp;transfer_amount[flag]) &lt; 0)&#123; printf(\"Thread %d creation failed\\n\", flag); exit (1); &#125; &#125; else&#123; if (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountBA, \\ (void*)&amp;transfer_amount[flag]) &lt; 0) &#123; printf(\"Thread %d creation failed\\n\", flag); exit (1); &#125; &#125; &#125; for(flag=0; flag&lt;THREAD_NUM; flag++)&#123; res = pthread_join(pthread[flag], &amp;thResState); if (res != 0)&#123; perror(\"Thread join failed\"); exit(-1); &#125; printf(\"thread success id %u state code %d\\n\",threadid[flag],thResState); &#125; printf(\"Transitions are in progress..\"); printf(\"\\nAll the money is transferred !!\\n\");&#125; 3.4、错误定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240$ gcc -g -o multi_thread multi_thread.c –lpthread$ ./multi_thread$ ps -eLF |grep multiwork 21675 19997 21675 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21676 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21677 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21678 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21679 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21680 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21681 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21682 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21683 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21684 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21685 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21686 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21687 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21688 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21689 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21690 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21691 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21692 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21693 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21694 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21695 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_thread$ gdbGNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\".(gdb) attach 21680Attaching to process 21680Reading symbols from /home/work/testers/sgc/study/multi_thread...done.Using host libthread_db library \"/lib64/tls/libthread_db.so.1\".Reading symbols from /lib64/tls/libpthread.so.0...done.[Thread debugging using libthread_db enabled][New Thread 182894112416 (LWP 21675)][New Thread 1283537248 (LWP 21695)][New Thread 1273047392 (LWP 21694)][New Thread 1262557536 (LWP 21693)][New Thread 1252067680 (LWP 21692)][New Thread 1241577824 (LWP 21691)][New Thread 1231087968 (LWP 21690)][New Thread 1220598112 (LWP 21689)][New Thread 1210108256 (LWP 21688)][New Thread 1199618400 (LWP 21687)][New Thread 1189128544 (LWP 21686)][New Thread 1178638688 (LWP 21685)][New Thread 1168148832 (LWP 21684)][New Thread 1157658976 (LWP 21683)][New Thread 1147169120 (LWP 21682)][New Thread 1136679264 (LWP 21681)][New Thread 1126189408 (LWP 21680)][New Thread 1115699552 (LWP 21679)][New Thread 1105209696 (LWP 21678)][New Thread 1094719840 (LWP 21677)][New Thread 1084229984 (LWP 21676)]Loaded symbols for /lib64/tls/libpthread.so.0Reading symbols from /lib64/tls/libc.so.6...done.Loaded symbols for /lib64/tls/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...done.Loaded symbols for /lib64/ld-linux-x86-64.so.20x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0(gdb) bt#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000432041e0 in ?? ()#2 0x00000000432049f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()(gdb) info threads 21 Thread 1084229984 (LWP 21676) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 20 Thread 1094719840 (LWP 21677) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 19 Thread 1105209696 (LWP 21678) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 18 Thread 1115699552 (LWP 21679) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 17 Thread 1126189408 (LWP 21680) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 16 Thread 1136679264 (LWP 21681) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 15 Thread 1147169120 (LWP 21682) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 14 Thread 1157658976 (LWP 21683) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 13 Thread 1168148832 (LWP 21684) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 12 Thread 1178638688 (LWP 21685) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 11 Thread 1189128544 (LWP 21686) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 10 Thread 1199618400 (LWP 21687) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 9 Thread 1210108256 (LWP 21688) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 8 Thread 1220598112 (LWP 21689) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 7 Thread 1231087968 (LWP 21690) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 6 Thread 1241577824 (LWP 21691) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 5 Thread 1252067680 (LWP 21692) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 4 Thread 1262557536 (LWP 21693) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 3 Thread 1273047392 (LWP 21694) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 2 Thread 1283537248 (LWP 21695) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 1 Thread 182894112416 (LWP 21675) 0x000000302b806ffb in pthread_join () from /lib64/tls/libpthread.so.0(gdb) thread apply all btThread 21 (Thread 1084229984 (LWP 21676)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000000000000 in ?? ()Thread 20 (Thread 1094719840 (LWP 21677)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000414011e0 in ?? ()#2 0x00000000414019f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 19 (Thread 1105209696 (LWP 21678)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000041e021e0 in ?? ()#2 0x0000000041e029f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 18 (Thread 1115699552 (LWP 21679)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000428031e0 in ?? ()#2 0x00000000428039f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 17 (Thread 1126189408 (LWP 21680)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000432041e0 in ?? ()#2 0x00000000432049f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 16 (Thread 1136679264 (LWP 21681)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000043c051e0 in ?? ()#2 0x0000000043c059f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 15 (Thread 1147169120 (LWP 21682)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000446061e0 in ?? ()#2 0x00000000446069f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Thread 14 (Thread 1157658976 (LWP 21683)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000450071e0 in ?? ()#2 0x00000000450079f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 13 (Thread 1168148832 (LWP 21684)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000045a081e0 in ?? ()#2 0x0000000045a089f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 12 (Thread 1178638688 (LWP 21685)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000464091e0 in ?? ()#2 0x00000000464099f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 11 (Thread 1189128544 (LWP 21686)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000046e0a1e0 in ?? ()#2 0x0000000046e0a9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 10 (Thread 1199618400 (LWP 21687)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004780b1e0 in ?? ()#2 0x000000004780b9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 9 (Thread 1210108256 (LWP 21688)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004820c1e0 in ?? ()#2 0x000000004820c9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 8 (Thread 1220598112 (LWP 21689)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000048c0d1e0 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---#2 0x0000000048c0d9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 7 (Thread 1231087968 (LWP 21690)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004960e1e0 in ?? ()#2 0x000000004960e9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 6 (Thread 1241577824 (LWP 21691)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004a00f1e0 in ?? ()#2 0x000000004a00f9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 5 (Thread 1252067680 (LWP 21692)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004aa101e0 in ?? ()#2 0x000000004aa109f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 4 (Thread 1262557536 (LWP 21693)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004b4111e0 in ?? ()#2 0x000000004b4119f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 3 (Thread 1273047392 (LWP 21694)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004be121e0 in ?? ()#2 0x000000004be129f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 2 (Thread 1283537248 (LWP 21695)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004c8131e0 in ?? ()#2 0x000000004c8139f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Thread 1 (Thread 182894112416 (LWP 21675)):#0 0x000000302b806ffb in pthread_join () from /lib64/tls/libpthread.so.0#1 0x0000000000400b69 in main (argc=1, argv=0x7fbffffa08) at multi_thread.c:76 总结GDB是一个好用的抓虫工具，随意控制进程，随便查看内存和环境；上述只是新手学习过程中的一些记录，欢迎深入探讨。","tags":[{"name":"GDB","slug":"GDB","permalink":"https://www.shengguocun.com/tags/GDB/"}]},{"title":"Hello World","date":"2018-02-08T14:44:23.000Z","path":"/blog/2018/02/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]