[{"title":"A Bite of Golang","date":"2018-04-20T06:54:03.000Z","path":"/blog/2018/04/20/a-bite-of-golang/","text":"0. 前言A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些小的经验，同时为了方便让读者了解到Go语言中的一些概念，文中包含了许多快速简洁的例子，读者后期可以去自行拓展。当然写这篇文章的灵感来源于GitHub上的 a bite of Python 1. 基础1.0、环境搭建1、下载安装包安装通过浏览器访问下面的地址 https://golang.org/dl/ 要是自己的网络不能翻墙的话，可以访问下面的Go语言中文网 https://studygolang.com/dl 下载指定的版本的安装包直接下一步就可以安装完成； 2、命令行安装Mac 利器 home brew 安装 go 1234brew update &amp;&amp; brew upgradebrew install gitbrew install mercurialbrew install go 安装完成之后 1vim ~/.bashrc 1234567891011#GOROOTexport GOROOT=/usr/local/Cellar/go/1.7.4/libexec#GOPATHexport GOPATH=$HOME/GoLangProject#GOPATH binexport PATH=$PATH:$GOPATH/bin#GOPATH root binexport PATH=$PATH:$GOROOT/bin 1source ~/.bashrc OK配合完成之后,输入go env验证一下是否配置成功 123456789101112131415~ sheng$ go envGOARCH=\"amd64\"GOBIN=\"\"GOEXE=\"\"GOHOSTARCH=\"amd64\"GOHOSTOS=\"darwin\"GOOS=\"darwin\"GOPATH=\"/Users/verton/GoLangProject\"GORACE=\"\"GOROOT=\"/usr/local/Cellar/go/1.7.4/libexec\"GOTOOLDIR=\"/usr/local/Cellar/go/1.7.4/libexec/pkg/tool/darwin_amd64\"CC=\"clang\"GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/z2/h48yrw8131g824_bvtw6584r0000gn/T/go-build415367881=/tmp/go-build -gno-record-gcc-switches -fno-common\"CXX=\"clang++\"CGO_ENABLED=\"1\" 1.1、变量定义1、通过var关键字12var a intvar b string 在Go语言中在定义变量的时候，是变量在前类型在后，现在你暂时先不用考虑那么多为什么，就先知道Go是这样的定义形式就可以了；当然可以多个变量一起定义,同时可以一起赋初值 1234567var a,b,c boolvar m,n string = \"Hello\",\"World\"var ( aa = 1 bb = \"hello world\" cc = true) 当然也可以让编译器自动决定类型，比如 1var s,m,p,q = 1,\"hahah\",false,\"xixiix\" 2、使用 := 定义变量1s,m,p,q := 1,\"hahah\",false,\"xixiix\" 这样呢可以让代码写的更加简短一点，当然呢 := 只能在函数内使用，是不能在函数外使用的。（相关的函数的知识后面会做介绍） 1.2、内建变量类型1、bool 、string这两个类型就不做过多的介绍，因为基本每一门语言里面都有这两个类型，在Go语言里面也是一样的 2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr上面这些就是Go的整数类型，加u和不加u的区别就是有无符号的区别，Go语言中的整数类型还分为两个大类，一个是规定长度的，比如：int8、int16、int32…，还有一种就是不规定长度的，它是根据操作系统来，在32位系统就是32位，在64位系统就是64位的，Go语言中没有int、long 这些类型，你想要定义一个相对较长的定义int64就可以了，最后uintptr就是Go语言的指针，后面我会再来介绍它 3、byte、runebyte就不用过多介绍了，大家都知道字节类型，那rune是什么呢，这就是Go语言的“char”，因为char只有一个字节在使用中会有很多的坑，Go语言针对这点痛点做了一些优化 4、float32、float64、complex64、complex128前面两个不过多介绍，浮点数类型32位和64位的，后面两个是一个复数的类型，complex64实部和虚部都是32位的，complex128实部和虚部都是64位的 1.3、常量与枚举123456const a = 1const b,c = 2,3const ( d = 5 e,f = 6,7) 常量数值可以作为各种类型使用,比如以下代码 123var s,p = 3,4m := math.Sqrt(s*s + p*p)fmt.Println(m) 这段代码语法是编译不通过的，因为Sqrt的参数必须是一个浮点数类型；但是呢我们把是s、p定义成常量就可以编译通过了 123const s,p = 3,4m := math.Sqrt(s*s + p*p)fmt.Println(m) Go语言中的枚举类型就是通过const来实现，同时Go语言中还可以通过iota实现自增的功能 123456789func enums()&#123; const ( a = iota b c ) fmt.Println(a, b, c)&#125; 调用上面这个函数显而易见，会输出 10 1 2 1.4、条件语句1、if正常的条件判断我这边就不做过多的介绍，当然Go语言有它特别的地方，if的条件里可以赋值，比如： 举个读文件的例子，ioutil.ReadFile 这个方法有两个返回值，后面会详细的讲解，常规的写法是 1234567const filename = \"file.txt\"content,err := ioutil.ReadFile(filename)if err != nil &#123; fmt.Println(err)&#125;else &#123; fmt.Println(string(content))&#125; Go语言可以整合成下面的写法 123456const filename = \"file.txt\"if content,err := ioutil.ReadFile(filename); err != nil &#123; fmt.Println(err)&#125;else &#123; fmt.Println(string(content))&#125; 2、switch123456789101112131415161718func eval(a int, b int, op string) int &#123; var result int switch op &#123; case \"+\": result = a + b case \"-\": result = a - b case \"*\": result = a * b case \"/\": result = a / b default: panic(\"unsupported op\") &#125; return result&#125; 看上面的这段代码，你发现和别的语言不一样的地方是怎么没有break，是的，Go语言中switch会自动break，除非使用fallthrough 同时，Go语言的switch还有另外一种写法，结合一个最常见的Switch用法举个例子吧，比如通过考试分数判断是否合格 123456789101112131415func grade(score int) string &#123; switch &#123; case score &gt; 100 || score &lt; 0: panic(\"Wrong score\") case score &gt; 80: return \"A\" case score &gt; 70: return \"B\" case score &gt; 60: return \"C\" default: return \"D\" &#125;&#125; 上面的一个写法可以发现switch后面是可以没有表达式的 1.5、循环1、forfor关键字和其他语言有着共同的功能，同时还充当的Go语言中的 while 功能，Go语言中没有 while 关键字 123for scanner.Scan() &#123; fmt.Println(scanner.Text())&#125; 上面的循环代码省略了起始条件，省略了递增条件，就跟while的功能非常的类似 123for &#123; fmt.Println(\"hello world\")&#125; 上面其实就是一个死循环，因为Go语言中经常会用到，后面的并发编程 Goroutine 的时候还会给大家继续介绍。 1.6、函数1、普通函数普通的函数定义我这边不再过多阐述，跟变量定义类似，函数名在前，函数返回类型在后 2、多返回值这个是Go语言的不一样的地方，函数可以有多个返回值，比如 ioutil.ReadFile 这个函数就是有两个返回值，但是呢多返回值不要滥用，尽量贴合Go语言的风格，常规返回值和一个error，那我门这边可以将上面的加减乘除的例子做一下改造，因为panic之后程序就会终止了，我们可以将错误信息直接返回出来，让程序继续执行 12345678910111213141516func eval(a int, b int, op string) (int, error) &#123; switch op &#123; case \"+\": return a + b, nil case \"-\": return a - b, nil case \"*\": return a * b, nil case \"/\": return a / b, nil default: return 0, fmt.Errorf(\"unsupported op\") &#125;&#125; 3、函数可作为参数123func apply(op func(int, int) int, a, b int) int &#123; return op(a, b)&#125; Go语言定义这种函数在前，参数在后的复合函数非常的方便，只需要apply一个函数就可以了，当然在现实的过程中有时候也会了偷下懒，相关的op函数就直接写成一个匿名函数了 1234fmt.Println(\"sub(3, 4) is:\", apply( func(a int, b int) int &#123; return a - b &#125;, 3, 4)) 这样也是OK的 4、没有默认参数、没有可选参数Go语言中没有其他语言类似Lambda这种很花哨的用法，除了一个可变参数列表 1234567func sum(numbers ...int) int &#123; s := 0 for i := range numbers &#123; s += numbers[i] &#125; return s&#125; 上面就是一个参数求和函数 1.7、指针1、指针不能运算比如想对指针做加1运算，Go语言是不支持的；当然要是想在函数内部改变函数外面的变量的值，通过指针是如何实现的呢，如下图所示 2、Go语言只有值传递Go语言中想要改变变量的值，只能传一个指针进去，比如常见 a b 两个变量的值交换 123func swap(a, b int) &#123; *a, *b = *b, *a&#125; 当然呢，交换参数值是不建议上面的写法的 2. 内建容器2.0、数组1、定义1234var arr1 [5]intarr2 := [3]int&#123;1, 3, 5&#125;arr3 := [...]int&#123;2, 4, 6, 8, 10&#125;var grid [4][5]int 数组的定义和变量的定义类似，数组名在前类型在后；常规的遍历操作也是类似 123for i, v := range arr &#123; fmt.Println(i, v)&#125; i 是数组的下标，v是数组的值 2、数组是值类型和上面值传递的概念类似，通过传参在函数内部是改变不了数组的值的;当然要是想改变相关的数组的值，可以通过指针来改变的。接下来的Slice可以直接解决上述的问题。 2.1、Slice(切片)的概念1、Slice定义Slice是什么呢？其实呢就是数组的一个View（视图），先来段代码热个身 1234arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;fmt.Println(\"arr[2:6] =\", arr[2:6])fmt.Println(\"arr[:6] =\", arr[:6]) 结果输出： 12arr[2:6] = [2 3 4 5]arr[:6] = [0 1 2 3 4 5] 从上面的输出结果可以直接的看出，arr加一个下标区间都叫做Slice，Slice的区间是一个左闭右开的区间当然我们还需要知道一个概念，Slice是没有数据的，是对底层Array的一个View，如何理解这个概念呢？简单的用一个例子来理解它 1234567891011121314151617181920212223242526package mainimport \"fmt\"func updateSliceData(s []int) &#123; s[0] = 666&#125;func main() &#123; arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125; s1 := arr[2:] fmt.Println(\"s1 =\", s1) s2 := arr[:] fmt.Println(\"s2 =\", s2) fmt.Println(\"更新Slice数据 s1\") updateSliceData(s1) fmt.Println(s1) fmt.Println(arr) fmt.Println(\"更新Slice数据 s2\") updateSliceData(s2) fmt.Println(s2) fmt.Println(arr)&#125; 结果输出为： 12345678s1 = [2 3 4 5 6 7]s2 = [0 1 2 3 4 5 6 7]更新Slice数据 s1[666 3 4 5 6 7][0 1 666 3 4 5 6 7]更新Slice数据 s2[666 1 666 3 4 5 6 7][666 1 666 3 4 5 6 7] 2、ReSlice就是在一个Slice上进一步slice，比如 1234arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;ss := arr[:6]ss = ss[:5]ss = ss[2:] 结果输出： 12[0 1 2 3 4][2 3 4] 3、Slice拓展首先我们先看一个例子 123arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;s1 := arr[2:6]s2 := s1[3:5] 大家或许会有疑问，这个s2不会报错么，要是不报错结果又是多少呢？ 12[2 3 4 5][5 6] 答案是可以，上述就是s1、s2的值，是不是跟你想的有点不一样。那么这又是为什么呢？ 这就是为什么能把 6 这个值取出来的原因，因为slice是array的底层的一个view，是不是依然还是有点懵，具体又是如何实现的呢？ 4、Slice实现 从上图是不是大体明白为什么上面那个例子能把6取出来了；看到这里大家也能大体明白Slice内部的ptr、len、cap是什么意思，ptr指向slice的开头的元素，len是slice的长度，cap代表底层的array从ptr开始到结束的长度，Slice是可以向后扩展的，但是不能向前扩展，所以只要不超过cap的长度slice都是可以扩展的，但是常规的s[i]取值是不可以超过len的。用一个例子来简单的理解一下 123arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;s1 := arr[2:6]fmt.Printf(\"len(s1): %d ; cap(s1): %d \", len(s1), cap(s1)) 输出结果： 1len(s1): 4 ; cap(s1): 6 2.2、Slice(切片)的操作1、向Slice添加元素12345s3 := append(s2, 8)s4 := append(s3, 9)s5 := append(s4, 10)fmt.Println(\"s3, s4, s5 =\", s3, s4, s5)fmt.Println(\"arr =\", arr) 上面的这个例子打印出来结果又是多少呢？ 12s3, s4, s5 = [5 6 8] [5 6 8 9] [5 6 8 9 10]arr = [0 1 2 3 4 5 6 8] 上面的9 ，10为什么不见了呢？因为Go语言在append数据超过cap长度的时候会分配一个更长的数组，如果arr不再使用的话就会被垃圾回收掉。在append的过程中，由于是值传递的关系，len、cap都有可能会改变，所以呢必须要用一个新的slice来接收这个slice，通常会写成 1s = append(s, value1) 2、创建slice当然slice也可以直接通过var关键字创建 1var s []int 这样创建的slice的初始值就是nil，别的语言中的null的意思，当然也是可以赋初值的，比如： 1s1 := []int&#123;2, 4, 6, 8&#125; 就上面的Zero Value的Slice的情况，要是我这个时候对这个slice进行append操作会怎么样呢？这个slice的内部的len以及cap又是如何变化的呢？ 12345var s []intfor i := 0; i &lt; 100; i++ &#123; fmt.Printf(\"%v, len = %d, cap = %d\\n\", s, len(s), cap(s)) s = append(s, 2*i+1)&#125; 结果我就不输出了，因为相对太长，我把相应的结果总结一下，就是len就是一个步长为1由1增至100，cap呢？当系统发现不够存储的时候会分配一个现有长度两倍的空间。 当然在实际生产过程中，大多是使用的make关键字来创建slice的 12s2 := make([]int, 4)s3 := make([]int, 8, 16) 3、Copy Slice数据1func Copy(dst Writer, src Reader) (written int64, err error) 文档中可以看的很清晰，直接将第二个参数直接拷贝进第一个参数 1234s1 := []int&#123;2, 4, 6, 8&#125;s2 := make([]int, 16)copy(s2, s1)fmt.Println(s2) 结果输出 1[2 4 6 8 0 0 0 0 0 0 0 0 0 0 0 0] 4、Slice删除元素123s1 := []int&#123;2, 4, 6, 8&#125;s2 := make([]int, 16)copy(s2, s1) 比如我要删除 s2 中的第 3 个元素该如何操作呢？ 1s2 = append(s2[:2], s2[3:]...) 当然现实的使用中还会从slice中pop一个值出来，下面分别演示一下从s2头部pop和从s2尾部pop数据 12front := s2[0]s2 = s2[1:] 12tail := s2[len(s2)-1]s2 = s2[:len(s2)-1] 2.3、Map1、创建map12var m1 map[string]intm2 := make(map[string]int) 上述就是常见的创建map的方式，但是m1、m2还是有区别的，m1是nil，m2是一个空map;常规的遍历map也是用 range 的方式就可以， 123for k, v := range m &#123; fmt.Println(k, v)&#125; 当然细心的会发现，在遍历的过程中是不能保证顺序的，当然要是想顺序遍历，需要自己手动对key进行排序，可以将key存进slice，然后再通过slice遍历相关的key获取map的值。 2、获取map元素m[key] 一般就是这样获取map的值 123456789var map1 = map[string]string&#123; \"name\" : \"shengguocun\", \"gender\" : \"male\", \"city\" : \"hangzhou\",&#125;value1 := map1[\"age\"]fmt.Println(value1) 先来猜测一下，上述这段代码可以运行么？会不会报错？ 答案是不会，这就是Go语言和别的语言不一样的地方，上述的例子中 value1 的值是一个空字符串，map中当key不存在时，会获取value类型的初始值。 1234567gender, ok := map1[\"gender\"]if ok &#123; fmt.Println(\"Gender 的值为 : \", gender)&#125;else &#123; fmt.Println(\"Key 不存在\")&#125; 既然Go语言的出现就是为了解决别的语言的痛点，所以在使用过程中不再需要每次获取某个 key 的时候都要去 isset 判断一下，Go的获取map的值的时候第二个返回值就是别的语言 isset 的功能；存在返回 true ，不存在返回 false。 3、删除元素delete函数，就可以直接删除指定的key的值 这是Go语言的官方文档，不难理解比如要删除上面的 map1 的 city 的值 1delete(map1, \"city\") 直接调用就可以 4、map的key为什么要把key单独拿出来说呢？因为map底层使用的是hash表，所以map的key必须可以比较相等；换句话说就是除了 slice、map、function的内建类型都可以作为key。 2.4、字符和字符串处理1、rune介绍rune就是Go语言的字符串类型，其实可以理解为是 int32 的一个別名，下面我们通过例子来深入理解一下rune 1234567891011121314s1 := \"你好,杭州\"fmt.Println(s1)for _, ch := range []byte(s1) &#123; fmt.Printf(\"%X \", ch)&#125;fmt.Println()for i, ch := range s1 &#123; fmt.Printf(\"(%d %X) \", i, ch)&#125; 输出结果 123你好,杭州E4 BD A0 E5 A5 BD 2C E6 9D AD E5 B7 9E(0 4F60) (3 597D) (6 2C) (7 676D) (10 5DDE) 从上述的例子我们可以直接的看出来，其实就是将UTF-8编码解码，然后再转成Unicode之后将它存放进一个rune（int32）中 2、字符串处理UTF-8编码的rune长度统计 12count := utf8.RuneCountInString(s1)fmt.Println(\"Rune Count :\", count) 输出结果为： 1Rune Count : 5 字符串的输出操作 123456bytes := []byte(s1)for len(bytes) &gt; 0 &#123; ch, size := utf8.DecodeRune(bytes) bytes = bytes[size:] fmt.Printf(\"%c \", ch)&#125; 用rune实现上述同样的功能 123for _, ch := range []rune(s1) &#123; fmt.Printf(\"%c \", ch)&#125; 3. 面向“对象”3.0、结构体和方法1、结构体的创建go语言仅支持封装，不支持继承和多态；这句话怎么理解呢？就是说在Go语言内部没有class，只有struct；也没有复杂的继承和多态，那继承和多态的任务又是通过什么实现的呢？Go是面向接口编程，可以通过接口来实现继承和多态的相关的任务，后面我会再进行介绍。下面先来介绍一下struct的创建： 1234type Node struct &#123; Value int Left, Right *Node&#125; 通过type、struct关键字创建结构体类型，当然在创建了结构体类型之后，就可以创建相关类型的变量 12345var root tree.Noderoot = tree.Node&#123;Value:1&#125;root.Value = 2root.Left = &amp;tree.Node&#123;Value:3&#125;root.Right = &amp;tree.Node&#123;&#125; 2、方法创建结构体的方法的创建和普通的函数创建没有太大的区别，只是在方法名前面添加一个接收者，就相当于其他语言的this 123func (node Node) Print() &#123; fmt.Print(node.Value, \" \")&#125; 上述就是一个值接收者打印出Node的Value的值的方法。当然要是需要改变Value的值的时候，就需要一个指针接收者。 123func (node *Node) SetValue(value int) &#123; node.Value = value&#125; 有一个疑问，要是对一个值为nil的Node进行 SetValue 操作会发生什么？ 12var pRoot *tree.NodepRoot.SetValue(1) 虽说nil指针可以调用方法，但是下面的Value是拿不到，自然就会报下面的错了 12345panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x20c3]goroutine 1 [running]:panic(0x8f100, 0xc42000a070) 实际使用过程中可以添加相关的判断在做处理。结合上面的知识我们不难写出一个树的遍历的方法的代码 123456789func (node *Node) Traverse() &#123; if node == nil &#123; return &#125; node.Print() node.Left.Traverse() node.Right.Traverse()&#125; 3.1、包和封装1、命名规范 名字一般使用 CamelCase（驼峰式） 首字母大写：Public 首字母小写：Private 2、包的概念 每个目录一个包，但是包名和目录名不一定要一样的，但是每个目录只能包含一个包； main包是一个相对特殊的，main包包含一个可执行入口； 为结构体定义的方法必须放在同一个包内 当然上面的例子已经在不经意间提前引入了package的概念 3.2、扩展已有类型在面向对象中，我们想要扩展一下别人的类，我们通常继承一下就好了，但是Go语言中没有继承的概念，我们该如何处理呢？ 1、定义别名（1.9新特性）在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型 基本语法就是： 1type identifier = Type 比如内建的byte类型，其实是uint8的类型别名，而rune其实是int32的类型别名。 12345678// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is// used, by convention, to distinguish byte values from 8-bit unsigned// integer values.type byte = uint8// rune is an alias for int32 and is equivalent to int32 in all ways. It is// used, by convention, to distinguish character values from integer values.type rune = int32 通过别名的方式就可以拓展了，比如 12345678910111213type T1 struct&#123;&#125;type T3 = T1func (t1 T1) say()&#123;&#125;func (t3 *T3) greeting()&#123;&#125;func main() &#123; var t1 T1 // var t2 T2 var t3 T3 t1.say() t1.greeting() t3.say() t3.greeting()&#125; 当然要是T1也定义了 greeting 的方法，那么编译会报错的，因为有重复的方法定义。 2、使用组合比如我们想扩展上面的树的包，实现一个自己的中序遍历，该如何实现呢？通过代码来理解一下使用组合的概念 123456789101112131415type myNode struct &#123; node *tree.Node&#125;func (myNodeNode *myNode) Traverse() &#123; if myNodeNode == nil || myNodeNode.node == nil &#123; return &#125; left := myNode&#123;myNodeNode.node.Left&#125; right := myNode&#123;myNodeNode.node.Right&#125; left.ownFunc() myNodeNode.node.Print() right.ownFunc()&#125; 3.3、GOPATH以及目录结构 默认在 ～／go 目录下（unix或者Linux环境），%USERPROFILE%\\go 目录下（windows环境） 官方推荐：所有的项目和第三方库都放在同一个GOPATH下 当然也可以将每个项目放在不同的GOPATH下 如何查看自己的GOPATH呢？ 12~ sheng$ echo $GOPATH/Users/verton/GoLangProject 1、go get获取第三方库1go get url 这样是可以获取GitHub上面的三方的库，但是Golang.org上面要是不能翻墙是获取不了的，这里我给大家介绍一个新的工具 gopm 1sheng$ go get github.com/gpmgo/gopm 一行命令就可以装好了，这个时候再get三方的库就毫无压力了，因为这个国内有相关的镜像 1gopm get -g url 采用-g 参数，可以把依赖包下载到GOPATH目录中 2、目录结构 src git repo 1 git repo 2 pkg git repo 1 git repo 2 bin 执行文件 1 2 从上述的目录结构上我们可以看出来，src pkg 是对应的，src 是我们的代码的位置以及三方库的位置，pkg 是build的中间过程，可以暂时先不用关注，bin下面就是可执行文件。 4. 面向接口4.0、Duck Typing的概念很多语言都有duck typing的概念， 用一个简单的例子来描述一下这个概念 大黄鸭是鸭子么？这个答案是要看基于什么角度来看，从生物角度来看，那它当然不是鸭子，连基本的生命都没有；但是从duck typing的角度来看它就是一个鸭子，因为它外部长得像鸭子，通俗点概括一下duck typing的概念就是：描述事物的外部行为而非内部结构。 从严格意义上讲，go语言只能说是类似duck typing，go语言不是动态绑定的，go语言是编译时绑定的。 4.1、接口的定义和实现在Go语言中，接口interface其实和其他语言的接口意思也没什么区别。一个结构体必须实现了一个接口的所有方法，才能被一个接口对象接受，这一点和Java语言中的接口的要求是一样的。interface理解其为一种类型的规范或者约定。 1、接口的定义123type Retriever interface&#123; Get(url string) string&#125; 这样就定义了一个接口，它包含一个Get函数。 2、接口的实现现在我们就来实现一下这个接口。比如我们做一个拉取某个页面的操作 123456789101112131415161718192021222324package rickimport ( \"net/http\" \"net/http/httputil\")type Retriever struct &#123;&#125;func (r Retriever) Get(url string) string &#123; resp, err := http.Get(url) if err != nil &#123; panic(err) &#125; result, err := httputil.DumpResponse(resp, true) resp.Body.Close() if err != nil &#123; panic(err) &#125; return string(result)&#125; 123456789101112131415161718192021package mainimport ( \"shengguocun.com/retriever/rick\" \"fmt\")type Retriever interface&#123; Get(url string) string&#125;func download(r Retriever) string &#123; return r.Get(\"http://www.shengguocun.com\")&#125;func main() &#123; var r Retriever r = rick.Retriever&#123;&#125; fmt.Println(download(r))&#125; 上述rick.Retriever就实现了Retriever接口。 4.2、接口值的类型1、接口变量里面有什么继续使用上面的例子 1234var r Retrieverr = rick.Retriever&#123;&#125;fmt.Printf(\"\\n %T %v \\n\", r, r) 会输出什么呢？ 1rick.Retriever &#123;&#125; 这就是常规的值传递，没有什么特别的地方。要是 Retriever 这个struct很大，我们不希望通过传值的方法去拷贝，而是通过指针访问Get方法。 12345678910111213func (r *Retriever) Get(url string) string &#123; resp, err := http.Get(url) if err != nil &#123; panic(err) &#125; result, err := httputil.DumpResponse(resp, true) resp.Body.Close() if err != nil &#123; panic(err) &#125; return string(result)&#125; 1234var r Retrieverr = &amp;rick.Retriever&#123;&#125;fmt.Printf(\"\\n %T %v \\n\", r, r) 这时候的Type、Value又是什么？ 1*rick.Retriever &amp;&#123;&#125; 我们可以看到是一个指针，所以我们一般用到接口的指针，因为它的肚子里含有一个指针，通常我们会说“接口变量自带指针”，那我们现在用两个图来总结一下上面的概念 概括为：接口变量里面可以是实现者的类型和实现者的值，或者是接口类型里面可以是实现者的类型和实现者的指针，同时指向实现者。 2、查看接口变量说到这里要提到一个特殊的接口，空接口 interface{} ，对于空接口 interface{} 其实和泛型的概念很像，任何类型都实现了空接口。在方法需要返回多个类型的时候，返回值的类型我们一般定义为 interface{} 。 这时我们现在引入获取接口变量肚子里的类型的另外一种写法，叫 Type Assertion（断言）。比如 12var a interface&#123;&#125;fmt.Println(\"Are you ok?\", a.(string)) 然而上述的写法一旦断言失败，会报出panic错误，当然这样的程序就显得十分的不友好。我们需要在断言前进行一个判断。 123456value, ok := a.(string)if !ok &#123; fmt.Println(\"断言失败，这不是一个string类型\") return&#125;fmt.Println(\"值为：\", value) 另外我们可以结合switch进行类型判断 12345678var r interface&#123;&#125;r = balabalaFunction()switch v := r.(type) &#123; case bool: fmt.Println(\"type bool...\") case int: fmt.Println(\"type int...\")&#125; Tips:转换类型的时候如果是string可以不用断言，使用fmt.Sprint()函数可以达到想要的效果。 4.3、接口的组合1、定义什么叫接口的组合？当然这就是它的字面上的意思，接口可以组合其他的接口。这种方式等效于在接口中添加其他的接口的方法。在系统函数中就有很多这样的组合，比如：ReadWriter 12345// ReadWriter is the interface that groups the basic Read and Write methods.type ReadWriter interface &#123; Reader Writer&#125; 在常见的读写文件的时候，网络相关以及一些底层的东西经常会遇到 Reader 、Writer 2、实例演示为了更好的理解接口的组合的概念，下面用一个简单的例子来进一步了解 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 定义Reader接口type Reader interface &#123; read()&#125;// 定义Writer接口type Writer interface &#123; write()&#125;// 实现上述两个接口type myReaderWriter struct &#123;&#125;func (mrw *myReaderWriter) read() &#123; fmt.Println(\"myReaderWriter read func...\")&#125;func (mrw *myReaderWriter) write() &#123; fmt.Println(\"myReadWriter writer func...\")&#125;// 定义一个接口，组合上述两个接口type ReaderWriterV1 interface &#123; Reader Writer&#125;// 等价于type ReaderWriterV2 interface &#123; read() write()&#125;func main() &#123; mrw := &amp;myReaderWriter&#123;&#125; //mrw对象实现了read()方法和write()方法，因此可以赋值给ReaderWriterV1和ReaderWriterV2 var rwv1 ReaderWriterV1 = mrw rwv1.read() rwv1.write() var rwv2 ReaderWriterV2 = mrw rwv2.write() rwv2.read() //同时，ReaderWriterV1和ReaderWriterV2两个接口对象可以相互赋值 rwv1 = rwv2 rwv2 = rwv1&#125; 4.4、常用的系统接口1、Stringer这个就是常见的 toString 的功能， 12345678// Stringer is implemented by any value that has a String method,// which defines the ``native'' format for that value.// The String method is used to print values passed as an operand// to any format that accepts a string or to an unformatted printer// such as Print.type Stringer interface &#123; String() string&#125; Stringer接口定义在fmt包中，该接口包含String()函数。任何类型只要定义了String()函数，进行Print输出时，就可以得到定制输出。比如： 123456789101112131415161718192021222324package mainimport \"fmt\"type Person struct&#123; age int gender string name string&#125;func (p Person) String() string &#123; return fmt.Sprintf(\"age:%d, gender:%s, name:%s\", p.age, p.gender, p.name)&#125;func main() &#123; var i Person = Person&#123; age: 25, gender: \"male\", name: \"sheng.guocun\", &#125; fmt.Printf(\"%s\\n\", i) fmt.Println(i) fmt.Printf(\"%v\", i)&#125; 结果输出为： 123age:25, gender:male, name:sheng.guocunage:25, gender:male, name:sheng.guocunage:25, gender:male, name:sheng.guocun 2、Reader、WriterReader Writer 上面有提到过，就是常见的读写文件的时候经常会用到，就是对文件的一个抽象，但是不仅这些，比如常见的 123456789// NewScanner returns a new Scanner to read from r.// The split function defaults to ScanLines.func NewScanner(r io.Reader) *Scanner &#123; return &amp;Scanner&#123; r: r, split: ScanLines, maxTokenSize: MaxScanTokenSize, &#125;&#125; 这的参数也是一个Reader，还有很多的底层的代码都是基于 Reader Writer 的，这里就不一一举例了。 5. 函数式编程5.0、函数式编程Go语言作为一个通用型语言，它对函数式编程主要体现在闭包上面。 1、函数式编程 VS 函数指针 函数是一等公民：参数、变量、返回值都可以是函数，在别的语言中大多不是这样的，比如在C++里面只有函数指针，在Java里面我们只能调用，不能把函数传给别人。 高阶函数：参数可以是函数，1.6.3里面的apply函数就是一个高阶函数。 函数 –&gt; 闭包：首先用个例子来了解一下闭包的用法 12345678910111213141516171819package mainimport \"fmt\"func adder() func(int) int &#123; sum := 0 return func(v int) int &#123; sum += v return sum &#125;&#125;func main() &#123; a := adder() for i := 0; i &lt; 10; i ++ &#123; fmt.Printf(\"0 + 1 + 2 + ... + %d = %d\\n\", i, a(i)) &#125;&#125; 结果输出为 123456789100 + 1 + 2 + ... + 0 = 00 + 1 + 2 + ... + 1 = 10 + 1 + 2 + ... + 2 = 30 + 1 + 2 + ... + 3 = 60 + 1 + 2 + ... + 4 = 100 + 1 + 2 + ... + 5 = 150 + 1 + 2 + ... + 6 = 210 + 1 + 2 + ... + 7 = 280 + 1 + 2 + ... + 8 = 360 + 1 + 2 + ... + 9 = 45 上述的 v 就称为局部变量， sum 称为自由变量，func(v int) int { sum += v return sum } 称为函数体，整个就叫做一个闭包。用一张图来概括就是： 2、“正统”函数式编程 不可变性：不能有状态，只有常量和函数；当然这和平常的函数不一样，连变量都没有，甚至连选择语句、循环语句都没有。 函数只能有一个参数 要是上面的累加想做一个稍微正统函数怎么做呢？ 1234567891011121314151617type iAdder func(int) (int, iAdder)func adderV2(base int) iAdder &#123; return func(v int) (int, iAdder) &#123; return base + v, adderV2(base + v) &#125;&#125;func main() &#123; a := adderV2(0) for i := 0; i &lt; 10; i ++ &#123; var s int s, a = a(i) fmt.Printf(\"0 + 1 + 2 + ... + %d = %d\\n\", i, s) &#125;&#125; 当然正统的不一定是最好的，正统式的写法经常导致代码的可读性变得不是很好。 5.1、函数式编程实例一5.2、函数式编程实例二6. 错误处理和资源管理6.0、defer调用6.1、错误处理概念6.2、服务器统一出错处理16.3、panic和recover7. 测试和性能调优7.0、测试7.1、代码覆盖率和性能测试7.2、使用pprof进行性能调优7.3、生成文档和事例代码8. Goroutine8.0、Goroutine介绍8.1、Go语言调度器9. Channel9.0、Channel介绍9.1、使用Channel等待任务结束9.2、使用Channel进行树遍历9.3、用select进行调度9.4、传统同步机制10. Http及其他标准库10.0、Http标准库介绍10.1、其他库介绍11. 总结","tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://www.shengguocun.com/tags/Go语言/"},{"name":"入门","slug":"入门","permalink":"https://www.shengguocun.com/tags/入门/"}]},{"title":"GDB抓虫之旅","date":"2018-03-15T05:59:24.000Z","path":"/blog/2018/03/15/taste-gdb/","text":"前言1234567891011问: gdb是什么？答: 强大的UNIX下命令行调试工具。问: gdb能干什么？答: 让你随心所欲的驾驭你的程序；Start、Stop、Examine、Change。问: 我们为什么要学习gdb？答: 欲善其事，必先利其器；利用gdb进一步的定位程序异常。问: 本次分享的宗旨?答: gdb的介绍和使用入门，为大家抓虫多提供一个选择。 抓虫从0开始前期准备 1.包含有调试信息的可执行文件 2.编译时加-g选项即可，不建议开优化选项 GDB的启动1234gdb &lt;program&gt;gdb &lt;program&gt; coregdb &lt;program&gt; &lt;PID&gt;(gdb) file &lt;program&gt; 抓虫流程 实战1 : GDB基础命令的使用1.1、示例程序(example_1.cpp) 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int foo(int m, int n)&#123; return 1;&#125;int foo(int n)&#123; int result=0; for (int i=0;i&lt;=n;i++) &#123; result+=n; &#125; return result;&#125;int main()&#123; string s1=\"dafdf\"; char * s2;// s1=s2; int sum =0; for (int i=1;i&lt;=100;i++) &#123; sum+=i; &#125; cout&lt;&lt;\"result[1-100]=\"&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;\"result[1-250]=\"&lt;&lt;foo(250)&lt;&lt;endl; return 0;&#125; 1.2、调试准备编译命令：g++ -g -Wall -o example_1 example_1.cpp 1.3、启动gdb 12345678$ gdb example_1GNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\"...Using host libthread_db library \"/lib64/tls/libthread_db.so.1\". 1.4、辅助性命令 12345678910111213141516(gdb) cd ..Working directory /home/work/testers/sgc.(gdb) shell lsautotest client Makefile spanti spantispam_if.h study(gdb) cd study/Working directory /home/work/testers/sgc/study.(gdb) pwdWorking directory /home/work/testers/sgc/study.(gdb) help runStart debugged program. You may specify arguments to give it.Args may include \"*\", or \"[...]\"; they are expanded using \"sh\".Input and output redirection with \"&gt;\", \"&lt;\", or \"&gt;&gt;\" are also allowed.With no arguments, uses arguments last specified (with \"run\" or \"set args\").To cancel previous arguments and run with no arguments,use \"set args\" without arguments. 1.5、设置断点命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445//查看源代码信息(gdb) l17 result+=n;18 &#125;19 return result;2021 &#125;2223 int main()24 &#123;2526 string s1=\"dafdf\";(gdb) l 11 #include &lt;iostream&gt;2 #include &lt;string&gt;345 using namespace std;6 int foo(int m, int n)7 &#123;89 return 1;10(gdb) l example_1.cpp:1611 &#125;12 int foo(int n)13 &#123;14 int result=0;15 for (int i=0;i&lt;=n;i++)16 &#123;17 result+=n;18 &#125;19 return result;20(gdb) l foo(int)89 return 1;1011 &#125;12 int foo(int n)13 &#123;14 int result=0;15 for (int i=0;i&lt;=n;i++)16 &#123;17 result+=n; 123456789//设置断点(gdb) b 17Breakpoint 1 at 0x400c07: file example_1.cpp, line 17.(gdb) b mainBreakpoint 2 at 0x400c27: file example_1.cpp, line 26.(gdb) info brNum Type Disp Enb Address What1 breakpoint keep y 0x0000000000400c07 in foo(int) at example_1.cpp:172 breakpoint keep y 0x0000000000400c27 in main at example_1.cpp:26 1.6、执行控制命令 12345678910111213(gdb) rStarting program: /home/work/testers/sgc/study/example_1Breakpoint 2, main () at example_1.cpp:2626 string s1=\"dafdf\";(gdb) cContinuing.result[1-100]=5050Breakpoint 1, foo (n=250) at example_1.cpp:1717 result+=n;(gdb) n15 for (int i=0;i&lt;=n;i++) 1.7、程序信息查看命令 123456789101112131415161718192021222324252627282930313233//查看变量信息(gdb) p result$1 = 250(gdb) p s1$2 = 1431655765 (gdb) disp result1: result = 250(gdb) cContinuing.Breakpoint 1, foo (n=250) at example_1.cpp:1717 result+=n;1: result = 250(gdb) info localsi = 1result = 250//查看栈信息(gdb) bt#0 foo (n=250) at example_1.cpp:17#1 0x0000000000400cc1 in main () at example_1.cpp:38(gdb) info fStack level 0, frame at 0x7fbffff8a0: rip = 0x400c07 in foo(int) (example_1.cpp:17); saved rip 0x400cc1 called by frame at 0x7fbffff910 source language c++. Arglist at 0x7fbffff890, args: n=250 Locals at 0x7fbffff890, Previous frame's sp is 0x7fbffff8a0 Saved registers: rbp at 0x7fbffff890, rip at 0x7fbffff898(gdb) f 0#0 foo (n=250) at example_1.cpp:1717 result+=n; 1.8、修改环境命令 1234567891011121314(gdb) set var i=97(gdb) p i$5 = 97(gdb) print i=98$6 = 98(gdb) ignore 1 300Will ignore next 300 crossings of breakpoint 1.(gdb) finishRun till exit from #0 foo (n=250) at example_1.cpp:170x0000000000400cc1 in main () at example_1.cpp:3838 cout&lt;&lt;\"result[1-250]=\"&lt;&lt;foo(250)&lt;&lt;endl;Value returned is $8 = 38500(gdb) quitThe program is running. Exit anyway? (y or n) y 不要放过core文件 问 ：Core文件是什么？答 ：a disk file containing an image of the process’s memory at the time of termination 问 ：Core的作用？答 ：&nbsp;&nbsp;&nbsp;&nbsp;1、让你在调试时，不用花费大量等待程序出错；&nbsp;&nbsp;&nbsp;&nbsp;2、让你避免了单步调试的烦恼&nbsp;&nbsp;&nbsp;&nbsp;3、让你定位错误所在 启动方式1$ gdb &lt;program&gt; core 查看程序信息的常用命令1、查看栈信息：bt, f n, up/down，info frame2、查看变量信息：info args|locals 实战2 : core文件调试2.1、示例程序(crash2.c) 123456789101112#include &lt;string.h&gt;void Strcpy(char *to , char *from)&#123; strcpy(to , from);&#125;int main()&#123; char *s = NULL; Strcpy(s, \"abcdefg\"); return 0;&#125; 2.2、查看信息 123456789101112131415161718192021222324252627282930$ gdb ./crash2 core.19562GNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\"...Using host libthread_db library \"/lib64/tls/libthread_db.so.1\".Core was generated by `./crash2'.Program terminated with signal 11, Segmentation fault.Reading symbols from /lib64/tls/libc.so.6...done.Loaded symbols for /lib64/tls/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...done.Loaded symbols for /lib64/ld-linux-x86-64.so.2#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6(gdb) bt#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6#1 0x00000000004004c5 in Strcpy (to=0x0, from=0x4005dc \"abcdefg\") at crash2.c:5#2 0x00000000004004e5 in main () at crash2.c:10(gdb) f 0#0 0x000000302af6f9a4 in strcpy () from /lib64/tls/libc.so.6(gdb) up#1 0x00000000004004c5 in Strcpy (to=0x0, from=0x4005dc \"abcdefg\") at crash2.c:55 strcpy(to , from);(gdb) info argsto = 0x0from = 0x4005dc \"abcdefg\"//至此，已经清楚的发现了问题所在，to指针为空 进阶之多线程程序调试多线程调试常用命令123456$ info &lt;...&gt; // 强大的查看命令，如info threads$ attach/detach &lt;pid&gt; // 挂载到进程$ thread &lt;thread_no&gt; // 切换到线程$ thread apply &lt;thread_no_list&gt; &lt;cmd&gt; // 对于list中的thread，执行cmd$ break &lt;linenum&gt; thread &lt;threadno&gt; if ... 实战3 : 多线程程序调试3.1、正常的示例程序(good_thread.c) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#define MAX 10pthread_t thread[2];pthread_mutex_t mut;int number=0, i;void *thread1()&#123; printf (\"thread1 : I'm thread 1\\n\"); for (i = 0; i &lt; MAX; i++) &#123; printf(\"thread1 : number = %d\\n\",number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(2); &#125; printf(\"thread1 :主函数在等我完成任务吗？\\n\"); pthread_exit(NULL);&#125;void *thread2()&#123; printf(\"thread2 : I'm thread 2\\n\"); for (i = 0; i &lt; MAX; i++) &#123; printf(\"thread2 : number = %d\\n\",number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(3); &#125; printf(\"thread2 :主函数在等我完成任务吗？\\n\"); pthread_exit(NULL);&#125;void thread_create(void)&#123; int temp; memset(&amp;thread, 0, sizeof(thread)); //comment1 /*创建线程*/ if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0) //comment2 printf(\"线程1创建失败!\\n\"); else printf(\"线程1被创建\\n\"); if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0) //comment3 printf(\"线程2创建失败\"); else printf(\"线程2被创建\\n\");&#125;void thread_wait(void)&#123; /*等待线程结束*/ if(thread[0] !=0) &#123; //comment4 pthread_join(thread[0],NULL); printf(\"线程1已经结束\\n\"); &#125; if(thread[1] !=0) &#123; //comment5 pthread_join(thread[1],NULL); printf(\"线程2已经结束\\n\"); &#125;&#125;int main()&#123; /*用默认属性初始化互斥锁*/ pthread_mutex_init(&amp;mut,NULL); printf(\"我是主函数哦，我正在创建线程，呵呵\\n\"); thread_create(); printf(\"我是主函数哦，我正在等待线程完成任务阿，呵呵\\n\"); thread_wait(); return 0;&#125; 3.2、演示过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(gdb)21 printf (\"thread1 : I'm thread 1\\n\");2223 for (i = 0; i &lt; MAX; i++)2425 &#123;2627 printf(\"thread1 : number = %d\\n\",number);2829 pthread_mutex_lock(&amp;mut);(gdb) b 27Breakpoint 1 at 0x40079e: file good_thread.c, line 27.(gdb)51 for (i = 0; i &lt; MAX; i++)5253 &#123;5455 printf(\"thread2 : number = %d\\n\",number);5657 pthread_mutex_lock(&amp;mut);5859 number++;(gdb) b 57Breakpoint 2 at 0x400838: file good_thread.c, line 57.(gdb) rStarting program: /home/work/testers/sgc/study/goodthread[Thread debugging using libthread_db enabled][New Thread 182894112416 (LWP 22783)]ÎÒÊÇÖ÷º¯ÊýÅ¶£¬ÎÒÕýÔÚ´´½¨Ïß³Ì£¬ºÇºÇ[New Thread 1084229984 (LWP 22786)]Ïß³Ì1±»´´½¨thread1 : I'm thread 1[Switching to Thread 1084229984 (LWP 22786)]Breakpoint 1, thread1 () at good_thread.c:2727 printf(\"thread1 : number = %d\\n\",number);(gdb) bt#0 thread1 () at good_thread.c:27#1 0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0#2 0x000000302afc6003 in clone () from /lib64/tls/libc.so.6#3 0x0000000000000000 in ?? ()(gdb) info threads[New Thread 1094719840 (LWP 22787)] 3 Thread 1094719840 (LWP 22787) 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6* 2 Thread 1084229984 (LWP 22786) thread1 () at good_thread.c:27 1 Thread 182894112416 (LWP 22783) 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6(gdb) thread 1[Switching to thread 1 (Thread 182894112416 (LWP 22783))]#0 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6(gdb) bt#0 0x000000302afc5fc4 in clone () from /lib64/tls/libc.so.6#1 0x000000302b805d86 in do_clone () from /lib64/tls/libpthread.so.0#2 0x000000302b806846 in pthread_create@@GLIBC_2.2.5 () from /lib64/tls/libpthread.so.0#3 0x00000000004008fd in thread_create () at good_thread.c:91#4 0x00000000004009a9 in main () at good_thread.c:135 3.3、死锁示例程序（multi_thread.c） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define THREAD_NUM 20pthread_mutex_t AccountA_mutex;pthread_mutex_t AccountB_mutex;struct Account &#123; char account_name[1]; int balance;&#125;;struct Account accountA = &#123;'A', 100000&#125;;struct Account accountB = &#123;'B', 200000&#125;;void * accountAB (void* amount_ptr) &#123; int amount = *((int*)amount_ptr); pthread_mutex_lock(&amp;AccountA_mutex); if (accountA.balance &lt; amount) &#123; printf(\"There is not enough memory in Account A!\\n\"); pthread_mutex_unlock(&amp;AccountA_mutex); pthread_exit((void *)1); &#125; accountA.balance -=amount; sleep(2); pthread_mutex_lock(&amp;AccountB_mutex); accountB.balance +=amount; pthread_mutex_unlock(&amp;AccountA_mutex); pthread_mutex_unlock(&amp;AccountB_mutex);&#125;void * accountBA (void* amount_ptr) &#123; int amount = *((int*)amount_ptr); pthread_mutex_lock(&amp;AccountB_mutex); if (accountB.balance &lt; amount) &#123; printf(\"There is not enough memory in Account B!\\n\"); pthread_mutex_unlock(&amp;AccountB_mutex); pthread_exit((void *)1); &#125; accountB.balance -=amount; pthread_mutex_lock(&amp;AccountA_mutex); accountA.balance +=amount; pthread_mutex_unlock(&amp;AccountB_mutex); pthread_mutex_unlock(&amp;AccountA_mutex);&#125;int main(int argc, char* argv[]) &#123; int threadid[THREAD_NUM]; pthread_t pthread[THREAD_NUM]; void* thResState; int res, flag; int transfer_amount[THREAD_NUM] = &#123;100, 200, 300, 400,100,200,300,400,500,600,700,800,900,800,700,600,500,400,300,200&#125;; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setscope(&amp;attr, PTHREAD_SCOPE_SYSTEM); for(flag=0; flag&lt;THREAD_NUM; flag++)&#123; if(flag%2 == 0)&#123; if (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountAB, \\ (void*)&amp;transfer_amount[flag]) &lt; 0)&#123; printf(\"Thread %d creation failed\\n\", flag); exit (1); &#125; &#125; else&#123; if (threadid[flag] = pthread_create(&amp;pthread[flag], &amp;attr , accountBA, \\ (void*)&amp;transfer_amount[flag]) &lt; 0) &#123; printf(\"Thread %d creation failed\\n\", flag); exit (1); &#125; &#125; &#125; for(flag=0; flag&lt;THREAD_NUM; flag++)&#123; res = pthread_join(pthread[flag], &amp;thResState); if (res != 0)&#123; perror(\"Thread join failed\"); exit(-1); &#125; printf(\"thread success id %u state code %d\\n\",threadid[flag],thResState); &#125; printf(\"Transitions are in progress..\"); printf(\"\\nAll the money is transferred !!\\n\");&#125; 3.4、错误定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240$ gcc -g -o multi_thread multi_thread.c –lpthread$ ./multi_thread$ ps -eLF |grep multiwork 21675 19997 21675 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21676 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21677 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21678 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21679 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21680 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21681 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21682 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21683 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21684 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21685 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21686 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21687 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21688 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21689 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21690 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21691 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21692 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21693 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21694 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_threadwork 21675 19997 21695 0 21 52124 464 0 00:25 pts/8 00:00:00 ./multi_thread$ gdbGNU gdb Red Hat Linux (6.3.0.0-1.96rh)Copyright 2004 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type \"show copying\" to see the conditions.There is absolutely no warranty for GDB. Type \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\".(gdb) attach 21680Attaching to process 21680Reading symbols from /home/work/testers/sgc/study/multi_thread...done.Using host libthread_db library \"/lib64/tls/libthread_db.so.1\".Reading symbols from /lib64/tls/libpthread.so.0...done.[Thread debugging using libthread_db enabled][New Thread 182894112416 (LWP 21675)][New Thread 1283537248 (LWP 21695)][New Thread 1273047392 (LWP 21694)][New Thread 1262557536 (LWP 21693)][New Thread 1252067680 (LWP 21692)][New Thread 1241577824 (LWP 21691)][New Thread 1231087968 (LWP 21690)][New Thread 1220598112 (LWP 21689)][New Thread 1210108256 (LWP 21688)][New Thread 1199618400 (LWP 21687)][New Thread 1189128544 (LWP 21686)][New Thread 1178638688 (LWP 21685)][New Thread 1168148832 (LWP 21684)][New Thread 1157658976 (LWP 21683)][New Thread 1147169120 (LWP 21682)][New Thread 1136679264 (LWP 21681)][New Thread 1126189408 (LWP 21680)][New Thread 1115699552 (LWP 21679)][New Thread 1105209696 (LWP 21678)][New Thread 1094719840 (LWP 21677)][New Thread 1084229984 (LWP 21676)]Loaded symbols for /lib64/tls/libpthread.so.0Reading symbols from /lib64/tls/libc.so.6...done.Loaded symbols for /lib64/tls/libc.so.6Reading symbols from /lib64/ld-linux-x86-64.so.2...done.Loaded symbols for /lib64/ld-linux-x86-64.so.20x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0(gdb) bt#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000432041e0 in ?? ()#2 0x00000000432049f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()(gdb) info threads 21 Thread 1084229984 (LWP 21676) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 20 Thread 1094719840 (LWP 21677) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 19 Thread 1105209696 (LWP 21678) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 18 Thread 1115699552 (LWP 21679) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 17 Thread 1126189408 (LWP 21680) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 16 Thread 1136679264 (LWP 21681) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 15 Thread 1147169120 (LWP 21682) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 14 Thread 1157658976 (LWP 21683) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 13 Thread 1168148832 (LWP 21684) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 12 Thread 1178638688 (LWP 21685) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 11 Thread 1189128544 (LWP 21686) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 10 Thread 1199618400 (LWP 21687) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 9 Thread 1210108256 (LWP 21688) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 8 Thread 1220598112 (LWP 21689) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 7 Thread 1231087968 (LWP 21690) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 6 Thread 1241577824 (LWP 21691) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 5 Thread 1252067680 (LWP 21692) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 4 Thread 1262557536 (LWP 21693) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 3 Thread 1273047392 (LWP 21694) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 2 Thread 1283537248 (LWP 21695) 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0 1 Thread 182894112416 (LWP 21675) 0x000000302b806ffb in pthread_join () from /lib64/tls/libpthread.so.0(gdb) thread apply all btThread 21 (Thread 1084229984 (LWP 21676)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000000000000 in ?? ()Thread 20 (Thread 1094719840 (LWP 21677)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000414011e0 in ?? ()#2 0x00000000414019f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 19 (Thread 1105209696 (LWP 21678)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000041e021e0 in ?? ()#2 0x0000000041e029f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 18 (Thread 1115699552 (LWP 21679)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000428031e0 in ?? ()#2 0x00000000428039f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 17 (Thread 1126189408 (LWP 21680)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000432041e0 in ?? ()#2 0x00000000432049f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 16 (Thread 1136679264 (LWP 21681)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000043c051e0 in ?? ()#2 0x0000000043c059f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 15 (Thread 1147169120 (LWP 21682)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000446061e0 in ?? ()#2 0x00000000446069f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Thread 14 (Thread 1157658976 (LWP 21683)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000450071e0 in ?? ()#2 0x00000000450079f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 13 (Thread 1168148832 (LWP 21684)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000045a081e0 in ?? ()#2 0x0000000045a089f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 12 (Thread 1178638688 (LWP 21685)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x00000000464091e0 in ?? ()#2 0x00000000464099f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 11 (Thread 1189128544 (LWP 21686)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000046e0a1e0 in ?? ()#2 0x0000000046e0a9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 10 (Thread 1199618400 (LWP 21687)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004780b1e0 in ?? ()#2 0x000000004780b9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 9 (Thread 1210108256 (LWP 21688)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004820c1e0 in ?? ()#2 0x000000004820c9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 8 (Thread 1220598112 (LWP 21689)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x0000000048c0d1e0 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---#2 0x0000000048c0d9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 7 (Thread 1231087968 (LWP 21690)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004960e1e0 in ?? ()#2 0x000000004960e9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 6 (Thread 1241577824 (LWP 21691)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004a00f1e0 in ?? ()#2 0x000000004a00f9f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 5 (Thread 1252067680 (LWP 21692)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004aa101e0 in ?? ()#2 0x000000004aa109f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 4 (Thread 1262557536 (LWP 21693)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004b4111e0 in ?? ()#2 0x000000004b4119f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 3 (Thread 1273047392 (LWP 21694)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004be121e0 in ?? ()#2 0x000000004be129f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()Thread 2 (Thread 1283537248 (LWP 21695)):#0 0x000000302b80adfb in __lll_mutex_lock_wait () from /lib64/tls/libpthread.so.0#1 0x000000004c8131e0 in ?? ()#2 0x000000004c8139f0 in ?? ()#3 0x000000302b807bd4 in pthread_mutex_lock () from /lib64/tls/libpthread.so.0#4 0x0000000000000000 in ?? ()---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---Thread 1 (Thread 182894112416 (LWP 21675)):#0 0x000000302b806ffb in pthread_join () from /lib64/tls/libpthread.so.0#1 0x0000000000400b69 in main (argc=1, argv=0x7fbffffa08) at multi_thread.c:76 总结GDB是一个好用的抓虫工具，随意控制进程，随便查看内存和环境；上述只是新手学习过程中的一些记录，欢迎深入探讨。","tags":[{"name":"GDB","slug":"GDB","permalink":"https://www.shengguocun.com/tags/GDB/"}]},{"title":"Hello World","date":"2018-02-08T14:44:23.000Z","path":"/blog/2018/02/08/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]