<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录生活的每一滴"><title>A Bite of Golang | 盛国存</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">A Bite of Golang</h1><a id="logo" href="/.">盛国存</a><p class="description">个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">A Bite of Golang</h1><div class="post-meta"><a href="/blog/2018/04/20/a-bite-of-golang/#comments" class="comment-count"></a><p><span class="date">Apr 20, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>A bite of GoLang（浅尝GoLang），本文只是Go语言的冰山一角，本文包含作者学习Go语言期间积累的一些小的经验，同时为了方便让读者了解到Go语言中的一些概念，文中包含了许多快速简洁的例子，读者后期可以去自行拓展。当然写这篇文章的灵感来源于GitHub上的 a bite of Python</p>
<h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1. 基础"></a>1. 基础</h2><h3 id="1-0、环境搭建"><a href="#1-0、环境搭建" class="headerlink" title="1.0、环境搭建"></a>1.0、环境搭建</h3><h4 id="1、下载安装包安装"><a href="#1、下载安装包安装" class="headerlink" title="1、下载安装包安装"></a>1、下载安装包安装</h4><p>通过浏览器访问下面的地址 <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a> 要是自己的网络不能翻墙的话，可以访问下面的Go语言中文网 <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a> 下载指定的版本的安装包直接下一步就可以安装完成；</p>
<h4 id="2、命令行安装"><a href="#2、命令行安装" class="headerlink" title="2、命令行安装"></a>2、命令行安装</h4><p>Mac 利器 home brew 安装 go</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade</span><br><span class="line">brew install git</span><br><span class="line">brew install mercurial</span><br><span class="line">brew install go</span><br></pre></td></tr></table></figure>
<p>安装完成之后</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~<span class="string">/.bashrc</span></span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#GOROOT</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOROOT</span>=/usr/local/Cellar/go/1.7.4/libexec</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOPATH</span>=<span class="variable">$HOME</span>/GoLangProject</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH bin</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOPATH/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#GOPATH root bin</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOROOT/bin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>OK配合完成之后,输入go env验证一下是否配置成功</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">~ sheng$ go env</span><br><span class="line">GOARCH=<span class="string">"amd64"</span></span><br><span class="line">GOBIN=<span class="string">""</span></span><br><span class="line">GOEXE=<span class="string">""</span></span><br><span class="line">GOHOSTARCH=<span class="string">"amd64"</span></span><br><span class="line">GOHOSTOS=<span class="string">"darwin"</span></span><br><span class="line">GOOS=<span class="string">"darwin"</span></span><br><span class="line">GOPATH=<span class="string">"/Users/verton/GoLangProject"</span></span><br><span class="line">GORACE=<span class="string">""</span></span><br><span class="line">GOROOT=<span class="string">"/usr/local/Cellar/go/1.7.4/libexec"</span></span><br><span class="line">GOTOOLDIR=<span class="string">"/usr/local/Cellar/go/1.7.4/libexec/pkg/tool/darwin_amd64"</span></span><br><span class="line">CC=<span class="string">"clang"</span></span><br><span class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/z2/h48yrw8131g824_bvtw6584r0000gn/T/go-build415367881=/tmp/go-build -gno-record-gcc-switches -fno-common"</span></span><br><span class="line">CXX=<span class="string">"clang++"</span></span><br><span class="line">CGO_ENABLED=<span class="string">"1"</span></span><br></pre></td></tr></table></figure>
<h3 id="1-1、变量定义"><a href="#1-1、变量定义" class="headerlink" title="1.1、变量定义"></a>1.1、变量定义</h3><h4 id="1、通过var关键字"><a href="#1、通过var关键字" class="headerlink" title="1、通过var关键字"></a>1、通过var关键字</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> int</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> string</span><br></pre></td></tr></table></figure>
<p>在Go语言中在定义变量的时候，是变量在前类型在后，现在你暂时先不用考虑那么多为什么，就先知道Go是这样的定义形式就可以了；当然可以多个变量一起定义,同时可以一起赋初值</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c bool</span><br><span class="line"><span class="selector-tag">var</span> m,n string = <span class="string">"Hello"</span>,<span class="string">"World"</span></span><br><span class="line"><span class="selector-tag">var</span> (</span><br><span class="line">    aa = <span class="number">1</span></span><br><span class="line">    bb = <span class="string">"hello world"</span></span><br><span class="line">    cc = true</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当然也可以让编译器自动决定类型，比如</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s,m,<span class="selector-tag">p</span>,<span class="selector-tag">q</span> = <span class="number">1</span>,<span class="string">"hahah"</span>,false,<span class="string">"xixiix"</span></span><br></pre></td></tr></table></figure>
<h4 id="2、使用-定义变量"><a href="#2、使用-定义变量" class="headerlink" title="2、使用 := 定义变量"></a>2、使用 := 定义变量</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s,m,<span class="selector-tag">p</span>,<span class="selector-tag">q</span> := <span class="number">1</span>,<span class="string">"hahah"</span>,false,<span class="string">"xixiix"</span></span><br></pre></td></tr></table></figure>
<p>这样呢可以让代码写的更加简短一点，当然呢 := 只能在函数内使用，是不能在函数外使用的。（相关的函数的知识后面会做介绍）</p>
<h3 id="1-2、内建变量类型"><a href="#1-2、内建变量类型" class="headerlink" title="1.2、内建变量类型"></a>1.2、内建变量类型</h3><h4 id="1、bool-、string"><a href="#1、bool-、string" class="headerlink" title="1、bool 、string"></a>1、bool 、string</h4><p>这两个类型就不做过多的介绍，因为基本每一门语言里面都有这两个类型，在Go语言里面也是一样的</p>
<h4 id="2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr"><a href="#2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr" class="headerlink" title="2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr"></a>2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr</h4><p>上面这些就是Go的整数类型，加u和不加u的区别就是有无符号的区别，Go语言中的整数类型还分为两个大类，一个是规定长度的，比如：int8、int16、int32…，还有一种就是不规定长度的，它是根据操作系统来，在32位系统就是32位，在64位系统就是64位的，Go语言中没有int、long 这些类型，你想要定义一个相对较长的定义int64就可以了，最后uintptr就是Go语言的指针，后面我会再来介绍它</p>
<h4 id="3、byte、rune"><a href="#3、byte、rune" class="headerlink" title="3、byte、rune"></a>3、byte、rune</h4><p>byte就不用过多介绍了，大家都知道字节类型，那rune是什么呢，这就是Go语言的“char”，因为char只有一个字节在使用中会有很多的坑，Go语言针对这点痛点做了一些优化</p>
<h4 id="4、float32、float64、complex64、complex128"><a href="#4、float32、float64、complex64、complex128" class="headerlink" title="4、float32、float64、complex64、complex128"></a>4、float32、float64、complex64、complex128</h4><p>前面两个不过多介绍，浮点数类型32位和64位的，后面两个是一个复数的类型，complex64实部和虚部都是32位的，complex128实部和虚部都是64位的</p>
<h3 id="1-3、常量与枚举"><a href="#1-3、常量与枚举" class="headerlink" title="1.3、常量与枚举"></a>1.3、常量与枚举</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a = <span class="number">1</span></span><br><span class="line">const b,c = <span class="number">2</span>,<span class="number">3</span></span><br><span class="line">const (</span><br><span class="line">    d = <span class="number">5</span></span><br><span class="line">    e,f = <span class="number">6</span>,<span class="number">7</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>常量数值可以作为各种类型使用,比如以下代码</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> s,<span class="selector-tag">p</span> = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">m := math.Sqrt(s*s + p*p)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure>
<p>这段代码语法是编译不通过的，因为Sqrt的参数必须是一个浮点数类型；但是呢我们把是s、p定义成常量就可以编译通过了</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s,p = <span class="number">3</span>,<span class="number">4</span></span><br><span class="line">m := math.<span class="built_in">Sqrt</span>(s*s + p*p)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure>
<p>Go语言中的枚举类型就是通过const来实现，同时Go语言中还可以通过iota实现自增的功能</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func enums()&#123;</span><br><span class="line"></span><br><span class="line">	const (</span><br><span class="line">		<span class="selector-tag">a</span> = iota</span><br><span class="line">		b</span><br><span class="line">		c</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面这个函数显而易见，会输出</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4、条件语句"><a href="#1-4、条件语句" class="headerlink" title="1.4、条件语句"></a>1.4、条件语句</h3><h4 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h4><p>正常的条件判断我这边就不做过多的介绍，当然Go语言有它特别的地方，if的条件里可以赋值，比如：</p>
<p>举个读文件的例子，ioutil.ReadFile 这个方法有两个返回值，后面会详细的讲解，常规的写法是</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename  = <span class="string">"file.txt"</span></span><br><span class="line">content,<span class="keyword">err</span> := ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">err</span> != nil &#123;</span><br><span class="line">	fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="built_in">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言可以整合成下面的写法</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename  = <span class="string">"file.txt"</span></span><br><span class="line"><span class="keyword">if</span> content,<span class="keyword">err</span> := ioutil.ReadFile(filename); <span class="keyword">err</span> != nil &#123;</span><br><span class="line">	fmt.Println(<span class="keyword">err</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="built_in">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、switch"><a href="#2、switch" class="headerlink" title="2、switch"></a>2、switch</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func eval(a <span class="built_in">int</span>, b <span class="built_in">int</span>, op <span class="built_in">string</span>) <span class="built_in">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> <span class="literal">result</span> <span class="built_in">int</span></span><br><span class="line">	switch op &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">			<span class="literal">result</span> = a + b</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">			<span class="literal">result</span> = a - b</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">			<span class="literal">result</span> = a * b</span><br><span class="line">		<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">			<span class="literal">result</span> = a / b</span><br><span class="line">		default:</span><br><span class="line">			panic(<span class="string">"unsupported op"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上面的这段代码，你发现和别的语言不一样的地方是怎么没有break，是的，Go语言中switch会自动break，除非使用fallthrough</p>
<p>同时，Go语言的switch还有另外一种写法，结合一个最常见的Switch用法举个例子吧，比如通过考试分数判断是否合格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> score &gt; <span class="number">100</span> || score &lt; <span class="number">0</span>:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"Wrong score"</span>)</span><br><span class="line">		<span class="keyword">case</span> score &gt; <span class="number">80</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">		<span class="keyword">case</span> score &gt; <span class="number">70</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">		<span class="keyword">case</span> score &gt; <span class="number">60</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"D"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的一个写法可以发现switch后面是可以没有表达式的</p>
<h3 id="1-5、循环"><a href="#1-5、循环" class="headerlink" title="1.5、循环"></a>1.5、循环</h3><h4 id="1、for"><a href="#1、for" class="headerlink" title="1、for"></a>1、for</h4><p>for关键字和其他语言有着共同的功能，同时还充当的Go语言中的 while 功能，Go语言中没有 while 关键字</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> scanner.<span class="title">Scan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的循环代码省略了起始条件，省略了递增条件，就跟while的功能非常的类似</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    fmt.<span class="keyword">Println</span>(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面其实就是一个死循环，因为Go语言中经常会用到，后面的并发编程 Goroutine 的时候还会给大家继续介绍。</p>
<h3 id="1-6、函数"><a href="#1-6、函数" class="headerlink" title="1.6、函数"></a>1.6、函数</h3><h4 id="1、普通函数"><a href="#1、普通函数" class="headerlink" title="1、普通函数"></a>1、普通函数</h4><p>普通的函数定义我这边不再过多阐述，跟变量定义类似，函数名在前，函数返回类型在后</p>
<h4 id="2、多返回值"><a href="#2、多返回值" class="headerlink" title="2、多返回值"></a>2、多返回值</h4><p>这个是Go语言的不一样的地方，函数可以有多个返回值，比如 ioutil.ReadFile 这个函数就是有两个返回值，但是呢多返回值不要滥用，尽量贴合Go语言的风格，常规返回值和一个error，那我门这边可以将上面的加减乘除的例子做一下改造，因为panic之后程序就会终止了，我们可以将错误信息直接返回出来，让程序继续执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> op &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">			<span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">			<span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">			<span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">			<span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"unsupported op"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、函数可作为参数"><a href="#3、函数可作为参数" class="headerlink" title="3、函数可作为参数"></a>3、函数可作为参数</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">apply</span>(<span class="params">op func(<span class="keyword">int</span>, <span class="keyword">int</span></span>) <span class="keyword">int</span>, a, b <span class="keyword">int</span>) <span class="keyword">int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言定义这种函数在前，参数在后的复合函数非常的方便，只需要apply一个函数就可以了，当然在现实的过程中有时候也会了偷下懒，相关的op函数就直接写成一个匿名函数了</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"sub(3, 4) is:"</span>, apply(</span><br><span class="line">	func(<span class="selector-tag">a</span> int, <span class="selector-tag">b</span> int) int &#123;</span><br><span class="line">		return <span class="selector-tag">a</span> - b</span><br><span class="line">	&#125;, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<p>这样也是OK的</p>
<h4 id="4、没有默认参数、没有可选参数"><a href="#4、没有默认参数、没有可选参数" class="headerlink" title="4、没有默认参数、没有可选参数"></a>4、没有默认参数、没有可选参数</h4><p>Go语言中没有其他语言类似Lambda这种很花哨的用法，除了一个可变参数列表</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	s := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是一个参数求和函数</p>
<h3 id="1-7、指针"><a href="#1-7、指针" class="headerlink" title="1.7、指针"></a>1.7、指针</h3><h4 id="1、指针不能运算"><a href="#1、指针不能运算" class="headerlink" title="1、指针不能运算"></a>1、指针不能运算</h4><p>比如想对指针做加1运算，Go语言是不支持的；当然要是想在函数内部改变函数外面的变量的值，通过指针是如何实现的呢，如下图所示<br><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15235210375685.jpg" alt=""></p>
<h4 id="2、Go语言只有值传递"><a href="#2、Go语言只有值传递" class="headerlink" title="2、Go语言只有值传递"></a>2、Go语言只有值传递</h4><p>Go语言中想要改变变量的值，只能传一个指针进去，比如常见 a b 两个变量的值交换</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func swap(<span class="selector-tag">a</span>, <span class="selector-tag">b</span> int) &#123;</span><br><span class="line">    *<span class="selector-tag">a</span>, *<span class="selector-tag">b</span> = *<span class="selector-tag">b</span>, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然呢，交换参数值是不建议上面的写法的</p>
<h2 id="2-内建容器"><a href="#2-内建容器" class="headerlink" title="2. 内建容器"></a>2. 内建容器</h2><h3 id="2-0、数组"><a href="#2-0、数组" class="headerlink" title="2.0、数组"></a>2.0、数组</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 [5]int</span><br><span class="line">arr2 := [3]int&#123;1, 3, 5&#125;</span><br><span class="line">arr3 := [...]int&#123;2, 4, 6, 8, 10&#125;</span><br><span class="line">var grid [<span class="string">4</span>][<span class="symbol">5</span>]int</span><br></pre></td></tr></table></figure>
<p>数组的定义和变量的定义类似，数组名在前类型在后；<br>常规的遍历操作也是类似</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span>, v := range arr &#123;</span><br><span class="line">	fmt.Println(<span class="selector-tag">i</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>i 是数组的下标，v是数组的值</p>
<h4 id="2、数组是值类型"><a href="#2、数组是值类型" class="headerlink" title="2、数组是值类型"></a>2、数组是值类型</h4><p>和上面值传递的概念类似，通过传参在函数内部是改变不了数组的值的;当然要是想改变相关的数组的值，可以通过指针来改变的。接下来的Slice可以直接解决上述的问题。</p>
<h3 id="2-1、Slice-切片-的概念"><a href="#2-1、Slice-切片-的概念" class="headerlink" title="2.1、Slice(切片)的概念"></a>2.1、Slice(切片)的概念</h3><h4 id="1、Slice定义"><a href="#1、Slice定义" class="headerlink" title="1、Slice定义"></a>1、Slice定义</h4><p>Slice是什么呢？其实呢就是数组的一个View（视图），先来段代码热个身</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="string">[...]</span>int&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"arr[2:6] ="</span>, arr<span class="string">[2:6]</span>)</span><br><span class="line">fmt.Println(<span class="string">"arr[:6] ="</span>, arr<span class="string">[:6]</span>)</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr<span class="string">[2:6]</span> = <span class="string">[2 3 4 5]</span></span><br><span class="line">arr<span class="string">[:6]</span> = <span class="string">[0 1 2 3 4 5]</span></span><br></pre></td></tr></table></figure>
<p>从上面的输出结果可以直接的看出，arr加一个下标区间都叫做Slice，Slice的区间是一个左闭右开的区间<br>当然我们还需要知道一个概念，Slice是没有数据的，是对底层Array的一个View，如何理解这个概念呢？简单的用一个例子来理解它</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSliceData</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">	s1 := arr[<span class="number">2</span>:]</span><br><span class="line">	fmt.Println(<span class="string">"s1 ="</span>, s1)</span><br><span class="line">	s2 := arr[:]</span><br><span class="line">	fmt.Println(<span class="string">"s2 ="</span>, s2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"更新Slice数据 s1"</span>)</span><br><span class="line">	updateSliceData(s1)</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"更新Slice数据 s2"</span>)</span><br><span class="line">	updateSliceData(s2)</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出为：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = [<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">s2 = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">更新Slice数据 s1</span><br><span class="line">[<span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">更新Slice数据 s2</span><br><span class="line">[<span class="number">666</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[<span class="number">666</span> <span class="number">1</span> <span class="number">666</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<h4 id="2、ReSlice"><a href="#2、ReSlice" class="headerlink" title="2、ReSlice"></a>2、ReSlice</h4><p>就是在一个Slice上进一步slice，比如</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">ss := arr[:6]</span><br><span class="line">ss = ss[:5]</span><br><span class="line">ss = ss[2:]</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<h4 id="3、Slice拓展"><a href="#3、Slice拓展" class="headerlink" title="3、Slice拓展"></a>3、Slice拓展</h4><p>首先我们先看一个例子</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]int&#123;0, 1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="line">s1 := arr[2:6]</span><br><span class="line">s2 := s1[3:5]</span><br></pre></td></tr></table></figure>
<p>大家或许会有疑问，这个s2不会报错么，要是不报错结果又是多少呢？</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span> <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>答案是可以，上述就是s1、s2的值，是不是跟你想的有点不一样。那么这又是为什么呢？</p>
<p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15235352570650.jpg" alt=""></p>
<p>这就是为什么能把 6 这个值取出来的原因，因为slice是array的底层的一个view，是不是依然还是有点懵，具体又是如何实现的呢？</p>
<h4 id="4、Slice实现"><a href="#4、Slice实现" class="headerlink" title="4、Slice实现"></a>4、Slice实现</h4><p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15236013496891.jpg" alt=""></p>
<p>从上图是不是大体明白为什么上面那个例子能把6取出来了；看到这里大家也能大体明白Slice内部的ptr、len、cap是什么意思，ptr指向slice的开头的元素，len是slice的长度，cap代表底层的array从ptr开始到结束的长度，Slice是可以向后扩展的，但是不能向前扩展，所以只要不超过cap的长度slice都是可以扩展的，但是常规的s[i]取值是不可以超过len的。<br>用一个例子来简单的理解一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">fmt.Printf(<span class="string">"len(s1): %d   ; cap(s1): %d "</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s1): <span class="number">4</span>   ; <span class="built_in">cap</span>(s1): <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2、Slice-切片-的操作"><a href="#2-2、Slice-切片-的操作" class="headerlink" title="2.2、Slice(切片)的操作"></a>2.2、Slice(切片)的操作</h3><h4 id="1、向Slice添加元素"><a href="#1、向Slice添加元素" class="headerlink" title="1、向Slice添加元素"></a>1、向Slice添加元素</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">s3</span> := append(<span class="built_in">s2</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">s4</span> := append(<span class="built_in">s3</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">s5</span> := append(<span class="built_in">s4</span>, <span class="number">10</span>)</span><br><span class="line">fmt.Println(<span class="string">"s3, s4, s5 ="</span>, <span class="built_in">s3</span>, <span class="built_in">s4</span>, <span class="built_in">s5</span>)</span><br><span class="line">fmt.Println(<span class="string">"arr ="</span>, arr)</span><br></pre></td></tr></table></figure>
<p>上面的这个例子打印出来结果又是多少呢？</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s3, s4, s5 = [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span>] [<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>]</span><br><span class="line">arr = [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>上面的9 ，10为什么不见了呢？因为Go语言在append数据超过cap长度的时候会分配一个更长的数组，如果arr不再使用的话就会被垃圾回收掉。<br>在append的过程中，由于是值传递的关系，len、cap都有可能会改变，所以呢必须要用一个新的slice来接收这个slice，通常会写成</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = append(s, value1)</span><br></pre></td></tr></table></figure>
<h4 id="2、创建slice"><a href="#2、创建slice" class="headerlink" title="2、创建slice"></a>2、创建slice</h4><p>当然slice也可以直接通过var关键字创建</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>这样创建的slice的初始值就是nil，别的语言中的null的意思，当然也是可以赋初值的，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure>
<p>就上面的Zero Value的Slice的情况，要是我这个时候对这个slice进行append操作会怎么样呢？这个slice的内部的len以及cap又是如何变化的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%v, len = %d, cap = %d\n"</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果我就不输出了，因为相对太长，我把相应的结果总结一下，就是len就是一个步长为1由1增至100，cap呢？当系统发现不够存储的时候会分配一个现有长度两倍的空间。</p>
<p>当然在实际生产过程中，大多是使用的make关键字来创建slice的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">8</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3、Copy-Slice数据"><a href="#3、Copy-Slice数据" class="headerlink" title="3、Copy Slice数据"></a>3、Copy Slice数据</h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written int64, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>文档中可以看的很清晰，直接将第二个参数直接拷贝进第一个参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br><span class="line">fmt.Println(s2)</span><br></pre></td></tr></table></figure>
<p>结果输出</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="4、Slice删除元素"><a href="#4、Slice删除元素" class="headerlink" title="4、Slice删除元素"></a>4、Slice删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br></pre></td></tr></table></figure>
<p>比如我要删除 s2 中的第 3 个元素该如何操作呢？</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">s2</span> = append(<span class="built_in">s2</span>[:<span class="number">2</span>], <span class="built_in">s2</span>[<span class="number">3</span>:]...)</span><br></pre></td></tr></table></figure>
<p>当然现实的使用中还会从slice中pop一个值出来，下面分别演示一下从s2头部pop和从s2尾部pop数据</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">front := s2[0]</span><br><span class="line">s2 = s2[1:]</span><br></pre></td></tr></table></figure>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail := <span class="built_in">s2</span>[len(<span class="built_in">s2</span>)-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">s2</span> = <span class="built_in">s2</span>[:len(<span class="built_in">s2</span>)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="2-3、Map"><a href="#2-3、Map" class="headerlink" title="2.3、Map"></a>2.3、Map</h3><h4 id="1、创建map"><a href="#1、创建map" class="headerlink" title="1、创建map"></a>1、创建map</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>上述就是常见的创建map的方式，但是m1、m2还是有区别的，m1是nil，m2是一个空map;常规的遍历map也是用 range 的方式就可以，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">	fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然细心的会发现，在遍历的过程中是不能保证顺序的，当然要是想顺序遍历，需要自己手动对key进行排序，可以将key存进slice，然后再通过slice遍历相关的key获取map的值。</p>
<h4 id="2、获取map元素"><a href="#2、获取map元素" class="headerlink" title="2、获取map元素"></a>2、获取map元素</h4><p>m[key] 一般就是这样获取map的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map1 = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="string">"name"</span> : <span class="string">"shengguocun"</span>,</span><br><span class="line">	<span class="string">"gender"</span> : <span class="string">"male"</span>,</span><br><span class="line">	<span class="string">"city"</span> : <span class="string">"hangzhou"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">value1 := map1[<span class="string">"age"</span>]</span><br><span class="line">fmt.Println(value1)</span><br></pre></td></tr></table></figure>
<p>先来猜测一下，上述这段代码可以运行么？会不会报错？</p>
<p>答案是不会，这就是Go语言和别的语言不一样的地方，上述的例子中 value1 的值是一个空字符串，map中当key不存在时，会获取value类型的初始值。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gender, ok := map1[<span class="string">"gender"</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.<span class="keyword">Println</span>(<span class="string">"Gender 的值为 : "</span>, gender)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.<span class="keyword">Println</span>(<span class="string">"Key 不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然Go语言的出现就是为了解决别的语言的痛点，所以在使用过程中不再需要每次获取某个 key 的时候都要去 isset 判断一下，Go的获取map的值的时候第二个返回值就是别的语言 isset 的功能；存在返回 true ，不存在返回 false。</p>
<h4 id="3、删除元素"><a href="#3、删除元素" class="headerlink" title="3、删除元素"></a>3、删除元素</h4><p>delete函数，就可以直接删除指定的key的值</p>
<p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15238684220308.jpg" alt=""></p>
<p>这是Go语言的官方文档，不难理解比如要删除上面的 map1 的 city 的值</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delete</span><span class="params">(map1, <span class="string">"city"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>直接调用就可以</p>
<h4 id="4、map的key"><a href="#4、map的key" class="headerlink" title="4、map的key"></a>4、map的key</h4><p>为什么要把key单独拿出来说呢？因为map底层使用的是hash表，所以map的key必须可以比较相等；换句话说就是除了 slice、map、function的内建类型都可以作为key。</p>
<h3 id="2-4、字符和字符串处理"><a href="#2-4、字符和字符串处理" class="headerlink" title="2.4、字符和字符串处理"></a>2.4、字符和字符串处理</h3><h4 id="1、rune介绍"><a href="#1、rune介绍" class="headerlink" title="1、rune介绍"></a>1、rune介绍</h4><p>rune就是Go语言的字符串类型，其实可以理解为是 int32 的一个別名，下面我们通过例子来深入理解一下rune</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"你好,杭州"</span></span><br><span class="line">fmt.Println(s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">byte</span>(s1) &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"%X "</span>, ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ch := <span class="keyword">range</span> s1 &#123;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"(%d %X) "</span>, i, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你好,杭州</span><br><span class="line">E4 BD A0 E5 A5 BD <span class="number">2</span>C E6 <span class="number">9</span>D AD E5 B7 <span class="number">9</span>E</span><br><span class="line">(<span class="number">0</span> <span class="number">4</span>F60) (<span class="number">3</span> <span class="number">597</span>D) (<span class="number">6</span> <span class="number">2</span>C) (<span class="number">7</span> <span class="number">676</span>D) (<span class="number">10</span> <span class="number">5</span>DDE)</span><br></pre></td></tr></table></figure>
<p>从上述的例子我们可以直接的看出来，其实就是将UTF-8编码解码，然后再转成Unicode之后将它存放进一个rune（int32）中</p>
<h4 id="2、字符串处理"><a href="#2、字符串处理" class="headerlink" title="2、字符串处理"></a>2、字符串处理</h4><p>UTF-8编码的rune长度统计</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">count</span> := utf8.RuneCountInString(s1)</span><br><span class="line">fmt.<span class="keyword">Println</span>(<span class="string">"Rune Count :"</span>, <span class="keyword">count</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rune Count : 5</span><br></pre></td></tr></table></figure>
<p>字符串的输出操作</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bytes </span>:= []<span class="keyword">byte(s1)</span></span><br><span class="line"><span class="keyword">for </span>len(<span class="keyword">bytes) </span>&gt; <span class="number">0</span> &#123;</span><br><span class="line">	ch, size := utf8.DecodeRune(<span class="keyword">bytes)</span></span><br><span class="line"><span class="keyword">	</span><span class="keyword">bytes </span>= <span class="keyword">bytes[size:]</span></span><br><span class="line"><span class="keyword">	</span>fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用rune实现上述同样的功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s1) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%c "</span>, ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-面向“对象”"><a href="#3-面向“对象”" class="headerlink" title="3. 面向“对象”"></a>3. 面向“对象”</h2><h3 id="3-0、结构体和方法"><a href="#3-0、结构体和方法" class="headerlink" title="3.0、结构体和方法"></a>3.0、结构体和方法</h3><h4 id="1、结构体的创建"><a href="#1、结构体的创建" class="headerlink" title="1、结构体的创建"></a>1、结构体的创建</h4><p>go语言仅支持封装，不支持继承和多态；这句话怎么理解呢？就是说在Go语言内部没有class，只有struct；也没有复杂的继承和多态，那继承和多态的任务又是通过什么实现的呢？Go是面向接口编程，可以通过接口来实现继承和多态的相关的任务，后面我会再进行介绍。<br>下面先来介绍一下struct的创建：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">Node</span> <span class="title">struct</span> &#123;</span><br><span class="line">	Value       int</span><br><span class="line">	Left, Right *<span class="keyword">Node</span><span class="title"></span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过type、struct关键字创建结构体类型，当然在创建了结构体类型之后，就可以创建相关类型的变量</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> root tree.Node</span><br><span class="line">root = tree.Node&#123;Value:<span class="number">1</span>&#125;</span><br><span class="line">root<span class="selector-class">.Value</span> = <span class="number">2</span></span><br><span class="line">root<span class="selector-class">.Left</span> = &amp;tree.Node&#123;Value:<span class="number">3</span>&#125;</span><br><span class="line">root<span class="selector-class">.Right</span> = &amp;tree.Node&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、方法创建"><a href="#2、方法创建" class="headerlink" title="2、方法创建"></a>2、方法创建</h4><p>结构体的方法的创建和普通的函数创建没有太大的区别，只是在方法名前面添加一个接收者，就相当于其他语言的this</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">Node</span>) Print() &#123;</span><br><span class="line">	fmt.Print(<span class="keyword">node</span>.<span class="title">Value</span>, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述就是一个值接收者打印出Node的Value的值的方法。<br>当然要是需要改变Value的值的时候，就需要一个指针接收者。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">*Node</span>) SetValue(value int) &#123;</span><br><span class="line">	<span class="keyword">node</span>.<span class="title">Value</span> = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个疑问，要是对一个值为nil的Node进行 SetValue 操作会发生什么？</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> pRoot *tree.Node</span><br><span class="line">pRoot.SetValue(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>虽说nil指针可以调用方法，但是下面的Value是拿不到，自然就会报下面的错了</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">panic: runtime error: invalid memory<span class="built_in"> address </span><span class="keyword">or</span> <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation <span class="attribute">code</span>=0x1 <span class="attribute">addr</span>=0x0 <span class="attribute">pc</span>=0x20c3]</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">panic(0x8f100, 0xc42000a070)</span><br></pre></td></tr></table></figure>
<p>实际使用过程中可以添加相关的判断在做处理。结合上面的知识我们不难写出一个树的遍历的方法的代码</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func (<span class="keyword">node</span> <span class="title">*Node</span>) Traverse()  &#123;</span><br><span class="line"></span><br><span class="line">	if <span class="keyword">node</span> <span class="title">== nil</span> &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">node</span>.<span class="title">Print</span>()</span><br><span class="line">	<span class="keyword">node</span>.<span class="title">Left</span>.Traverse()</span><br><span class="line">	<span class="keyword">node</span>.<span class="title">Right</span>.Traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1、包和封装"><a href="#3-1、包和封装" class="headerlink" title="3.1、包和封装"></a>3.1、包和封装</h3><h4 id="1、命名规范"><a href="#1、命名规范" class="headerlink" title="1、命名规范"></a>1、命名规范</h4><ul>
<li>名字一般使用 CamelCase（驼峰式）</li>
<li>首字母大写：Public</li>
<li>首字母小写：Private</li>
</ul>
<h4 id="2、包的概念"><a href="#2、包的概念" class="headerlink" title="2、包的概念"></a>2、包的概念</h4><ul>
<li>每个目录一个包，但是包名和目录名不一定要一样的，但是每个目录只能包含一个包；</li>
<li>main包是一个相对特殊的，main包包含一个可执行入口；</li>
<li>为结构体定义的方法必须放在同一个包内</li>
</ul>
<p>当然上面的例子已经在不经意间提前引入了package的概念</p>
<h3 id="3-2、扩展已有类型"><a href="#3-2、扩展已有类型" class="headerlink" title="3.2、扩展已有类型"></a>3.2、扩展已有类型</h3><p>在面向对象中，我们想要扩展一下别人的类，我们通常继承一下就好了，但是Go语言中没有继承的概念，我们该如何处理呢？</p>
<h4 id="1、定义别名（1-9新特性）"><a href="#1、定义别名（1-9新特性）" class="headerlink" title="1、定义别名（1.9新特性）"></a>1、定义别名（1.9新特性）</h4><p>在大规模的重构项目代码的时候，尤其是将一个类型从一个包移动到另一个包中的时候，有些代码使用新包中的类型，有些代码使用旧包中的类型</p>
<p>基本语法就是：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">identifier </span>= <span class="keyword">Type</span></span><br></pre></td></tr></table></figure>
<p>比如内建的byte类型，其实是uint8的类型别名，而rune其实是int32的类型别名。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// byte <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> uint8 <span class="keyword">and</span> <span class="keyword">is</span> equivalent <span class="keyword">to</span> uint8 <span class="keyword">in</span> <span class="keyword">all</span> ways. It <span class="keyword">is</span></span><br><span class="line">// used, by convention, <span class="keyword">to</span> distinguish byte values from <span class="number">8</span>-<span class="built_in">bit</span> <span class="built_in">unsigned</span></span><br><span class="line">// <span class="built_in">integer</span> values.</span><br><span class="line"><span class="keyword">type</span> byte = uint8</span><br><span class="line"></span><br><span class="line">// rune <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> int32 <span class="keyword">and</span> <span class="keyword">is</span> equivalent <span class="keyword">to</span> int32 <span class="keyword">in</span> <span class="keyword">all</span> ways. It <span class="keyword">is</span></span><br><span class="line">// used, by convention, <span class="keyword">to</span> distinguish <span class="built_in">character</span> values from <span class="built_in">integer</span> values.</span><br><span class="line"><span class="keyword">type</span> rune = int32</span><br></pre></td></tr></table></figure>
<p>通过别名的方式就可以拓展了，比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> T3 = T1</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t1 T1)</span> <span class="title">say</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t3 *T3)</span> <span class="title">greeting</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t1 T1</span><br><span class="line">	<span class="comment">// var t2 T2</span></span><br><span class="line">	<span class="keyword">var</span> t3 T3</span><br><span class="line">	t1.say()</span><br><span class="line">	t1.greeting()</span><br><span class="line">	t3.say()</span><br><span class="line">	t3.greeting()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然要是T1也定义了 greeting 的方法，那么编译会报错的，因为有重复的方法定义。</p>
<h4 id="2、使用组合"><a href="#2、使用组合" class="headerlink" title="2、使用组合"></a>2、使用组合</h4><p>比如我们想扩展上面的树的包，实现一个自己的中序遍历，该如何实现呢？通过代码来理解一下使用组合的概念</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type myNode <span class="class"><span class="keyword">struct</span> </span>&#123;</span><br><span class="line">	node *tree.<span class="type">Node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(myNodeNode *myNode)</span></span> <span class="type">Traverse</span>() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> myNodeNode == <span class="literal">nil</span> || myNodeNode.node == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">left</span> := myNode&#123;myNodeNode.node.<span class="type">Left</span>&#125;</span><br><span class="line">	<span class="keyword">right</span> := myNode&#123;myNodeNode.node.<span class="type">Right</span>&#125;</span><br><span class="line">	<span class="keyword">left</span>.ownFunc()</span><br><span class="line">	myNodeNode.node.<span class="type">Print</span>()</span><br><span class="line">	<span class="keyword">right</span>.ownFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3、GOPATH以及目录结构"><a href="#3-3、GOPATH以及目录结构" class="headerlink" title="3.3、GOPATH以及目录结构"></a>3.3、GOPATH以及目录结构</h3><ul>
<li>默认在 ～／go 目录下（unix或者Linux环境），%USERPROFILE%\go 目录下（windows环境）</li>
<li>官方推荐：所有的项目和第三方库都放在同一个GOPATH下</li>
<li>当然也可以将每个项目放在不同的GOPATH下</li>
</ul>
<p>如何查看自己的GOPATH呢？</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ sheng$ echo <span class="variable">$GOPATH</span></span><br><span class="line"><span class="regexp">/Users/</span>verton<span class="regexp">/GoLangProject</span></span><br></pre></td></tr></table></figure>
<h4 id="1、go-get获取第三方库"><a href="#1、go-get获取第三方库" class="headerlink" title="1、go get获取第三方库"></a>1、go get获取第三方库</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">go</span> <span class="built_in">get</span> url</span><br></pre></td></tr></table></figure>
<p>这样是可以获取GitHub上面的三方的库，但是Golang.org上面要是不能翻墙是获取不了的，这里我给大家介绍一个新的工具 <strong>gopm</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sheng$ <span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gpmgo/gopm</span><br></pre></td></tr></table></figure>
<p>一行命令就可以装好了，这个时候再get三方的库就毫无压力了，因为这个国内有相关的镜像</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopm <span class="builtin-name">get</span> -g url</span><br></pre></td></tr></table></figure>
<p>采用-g 参数，可以把依赖包下载到GOPATH目录中</p>
<h4 id="2、目录结构"><a href="#2、目录结构" class="headerlink" title="2、目录结构"></a>2、目录结构</h4><ul>
<li>src<ul>
<li>git repo 1</li>
<li>git repo 2</li>
</ul>
</li>
<li>pkg<ul>
<li>git repo 1</li>
<li>git repo 2</li>
</ul>
</li>
<li>bin<ul>
<li>执行文件 1 2</li>
</ul>
</li>
</ul>
<p>从上述的目录结构上我们可以看出来，src pkg 是对应的，src 是我们的代码的位置以及三方库的位置，pkg 是build的中间过程，可以暂时先不用关注，bin下面就是可执行文件。</p>
<h2 id="4-面向接口"><a href="#4-面向接口" class="headerlink" title="4. 面向接口"></a>4. 面向接口</h2><h3 id="4-0、Duck-Typing的概念"><a href="#4-0、Duck-Typing的概念" class="headerlink" title="4.0、Duck Typing的概念"></a>4.0、Duck Typing的概念</h3><p>很多语言都有duck typing的概念， 用一个简单的例子来描述一下这个概念</p>
<p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15240576798805.jpg" alt=""></p>
<p>大黄鸭是鸭子么？这个答案是要看基于什么角度来看，从生物角度来看，那它当然不是鸭子，连基本的生命都没有；但是从duck typing的角度来看它就是一个鸭子，因为它外部长得像鸭子，通俗点概括一下duck typing的概念就是：描述事物的外部行为而非内部结构。</p>
<p>从严格意义上讲，go语言只能说是类似duck typing，go语言不是动态绑定的，go语言是编译时绑定的。</p>
<h3 id="4-1、接口的定义和实现"><a href="#4-1、接口的定义和实现" class="headerlink" title="4.1、接口的定义和实现"></a>4.1、接口的定义和实现</h3><p>在Go语言中，接口interface其实和其他语言的接口意思也没什么区别。一个结构体必须实现了一个接口的所有方法，才能被一个接口对象接受，这一点和Java语言中的接口的要求是一样的。interface理解其为一种类型的规范或者约定。</p>
<h4 id="1、接口的定义"><a href="#1、接口的定义" class="headerlink" title="1、接口的定义"></a>1、接口的定义</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span>&#123;</span><br><span class="line">    Get(url <span class="built_in">string</span>) <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就定义了一个接口，它包含一个Get函数。</p>
<h4 id="2、接口的实现"><a href="#2、接口的实现" class="headerlink" title="2、接口的实现"></a>2、接口的实现</h4><p>现在我们就来实现一下这个接口。比如我们做一个拉取某个页面的操作</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rick</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/http/httputil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	resp.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"shengguocun.com/retriever/rick"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Retriever <span class="keyword">interface</span>&#123;</span><br><span class="line">	Get(url <span class="keyword">string</span>) <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(r Retriever)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Get(<span class="string">"http://www.shengguocun.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> r Retriever</span><br><span class="line">	r = rick.Retriever&#123;&#125;</span><br><span class="line">	fmt.Println(download(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述rick.Retriever就实现了Retriever接口。</p>
<h3 id="4-2、接口值的类型"><a href="#4-2、接口值的类型" class="headerlink" title="4.2、接口值的类型"></a>4.2、接口值的类型</h3><h4 id="1、接口变量里面有什么"><a href="#1、接口变量里面有什么" class="headerlink" title="1、接口变量里面有什么"></a>1、接口变量里面有什么</h4><p>继续使用上面的例子</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r Retriever</span><br><span class="line">r = rick.Retriever&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"<span class="subst">\n</span> %T %v <span class="subst">\n</span>"</span>, r, r)</span><br></pre></td></tr></table></figure>
<p>会输出什么呢？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">rick</span><span class="selector-class">.Retriever</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这就是常规的值传递，没有什么特别的地方。要是 Retriever 这个struct很大，我们不希望通过传值的方法去拷贝，而是通过指针访问Get方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Retriever)</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	resp, err := http.Get(url)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	result, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line">	resp.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="keyword">string</span>(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r Retriever</span><br><span class="line">r = &amp;rick.Retriever&#123;&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"<span class="subst">\n</span> %T %v <span class="subst">\n</span>"</span>, r, r)</span><br></pre></td></tr></table></figure>
<p>这时候的Type、Value又是什么？</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-tag">rick</span><span class="selector-class">.Retriever</span> &amp;&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到是一个指针，所以我们一般用到接口的指针，因为它的肚子里含有一个指针，通常我们会说“<strong>接口变量自带指针</strong>”，那我们现在用两个图来总结一下上面的概念</p>
<p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15244909642810.jpg" alt=""></p>
<p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15244910308713.jpg" alt=""></p>
<p>概括为：接口变量里面可以是实现者的类型和实现者的值，或者是接口类型里面可以是实现者的类型和实现者的指针，同时指向实现者。</p>
<h4 id="2、查看接口变量"><a href="#2、查看接口变量" class="headerlink" title="2、查看接口变量"></a>2、查看接口变量</h4><p>说到这里要提到一个特殊的接口，空接口 interface{} ，对于空接口 interface{} 其实和泛型的概念很像，任何类型都实现了空接口。在方法需要返回多个类型的时候，返回值的类型我们一般定义为 interface{} 。</p>
<p>这时我们现在引入获取接口变量肚子里的类型的另外一种写法，叫 Type Assertion（断言）。比如</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> interface&#123;&#125;</span><br><span class="line">fmt.Println(<span class="string">"Are you ok?"</span>, <span class="selector-tag">a</span>.(string))</span><br></pre></td></tr></table></figure>
<p>然而上述的写法一旦断言失败，会报出panic错误，当然这样的程序就显得十分的不友好。我们需要在断言前进行一个判断。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">value</span>, ok := a.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">"断言失败，这不是一个string类型"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"值为："</span>, <span class="keyword">value</span>)</span><br></pre></td></tr></table></figure>
<p>另外我们可以结合switch进行类型判断</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r = balabalaFunction()</span><br><span class="line"><span class="keyword">switch</span> v := r.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">		fmt.Println(<span class="string">"type bool..."</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">		fmt.Println(<span class="string">"type int..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tips:转换类型的时候如果是string可以不用断言，使用fmt.Sprint()函数可以达到想要的效果。</p>
<h3 id="4-3、接口的组合"><a href="#4-3、接口的组合" class="headerlink" title="4.3、接口的组合"></a>4.3、接口的组合</h3><h4 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h4><p>什么叫接口的组合？当然这就是它的字面上的意思，接口可以组合其他的接口。这种方式等效于在接口中添加其他的接口的方法。在系统函数中就有很多这样的组合，比如：ReadWriter</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ReadWriter <span class="keyword">is</span> the <span class="keyword">interface</span> that groups the basic Read <span class="keyword">and</span> Write methods.</span><br><span class="line"><span class="keyword">type</span> <span class="type">ReadWriter </span><span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在常见的读写文件的时候，网络相关以及一些底层的东西经常会遇到 Reader 、Writer</p>
<h4 id="2、实例演示"><a href="#2、实例演示" class="headerlink" title="2、实例演示"></a>2、实例演示</h4><p>为了更好的理解接口的组合的概念，下面用一个简单的例子来进一步了解</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Reader接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">	read()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义Writer接口</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	write()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现上述两个接口</span></span><br><span class="line"><span class="keyword">type</span> myReaderWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw *myReaderWriter)</span> <span class="title">read</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">"myReaderWriter read func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mrw *myReaderWriter)</span> <span class="title">write</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"myReadWriter writer func..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个接口，组合上述两个接口</span></span><br><span class="line"><span class="keyword">type</span> ReaderWriterV1 <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">type</span> ReaderWriterV2 <span class="keyword">interface</span> &#123;</span><br><span class="line">	read()</span><br><span class="line">	write()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mrw := &amp;myReaderWriter&#123;&#125;</span><br><span class="line">	<span class="comment">//mrw对象实现了read()方法和write()方法，因此可以赋值给ReaderWriterV1和ReaderWriterV2</span></span><br><span class="line">	<span class="keyword">var</span> rwv1 ReaderWriterV1 = mrw</span><br><span class="line">	rwv1.read()</span><br><span class="line">	rwv1.write()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> rwv2 ReaderWriterV2 = mrw</span><br><span class="line">	rwv2.write()</span><br><span class="line">	rwv2.read()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//同时，ReaderWriterV1和ReaderWriterV2两个接口对象可以相互赋值</span></span><br><span class="line">	rwv1 = rwv2</span><br><span class="line">	rwv2 = rwv1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4、常用的系统接口"><a href="#4-4、常用的系统接口" class="headerlink" title="4.4、常用的系统接口"></a>4.4、常用的系统接口</h3><h4 id="1、Stringer"><a href="#1、Stringer" class="headerlink" title="1、Stringer"></a>1、Stringer</h4><p>这个就是常见的 toString 的功能，</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Stringer <span class="keyword">is</span> implemented by any value that <span class="built_in">has</span> <span class="keyword">a</span> String method,</span><br><span class="line">// which defines the ``native<span class="string">''</span> format <span class="keyword">for</span> that value.</span><br><span class="line">// The String method <span class="keyword">is</span> used <span class="keyword">to</span> <span class="keyword">print</span> <span class="built_in">values</span> passed <span class="keyword">as</span> <span class="keyword">an</span> operand</span><br><span class="line">// <span class="keyword">to</span> any format that accepts <span class="keyword">a</span> <span class="built_in">string</span> <span class="built_in">or</span> <span class="keyword">to</span> <span class="keyword">an</span> unformatted printer</span><br><span class="line">// such <span class="keyword">as</span> <span class="keyword">Print</span>.</span><br><span class="line"><span class="built_in">type</span> Stringer interface &#123;</span><br><span class="line">	String() <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stringer接口定义在fmt包中，该接口包含String()函数。任何类型只要定义了String()函数，进行Print输出时，就可以得到定制输出。比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	gender <span class="keyword">string</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"age:%d, gender:%s, name:%s"</span>, p.age, p.gender, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i Person = Person&#123;</span><br><span class="line">		age: <span class="number">25</span>,</span><br><span class="line">		gender: <span class="string">"male"</span>,</span><br><span class="line">		name: <span class="string">"sheng.guocun"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"%s\n"</span>, i)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	fmt.Printf(<span class="string">"%v"</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br><span class="line"><span class="selector-tag">age</span><span class="selector-pseudo">:25</span>, <span class="selector-tag">gender</span><span class="selector-pseudo">:male</span>, <span class="selector-tag">name</span><span class="selector-pseudo">:sheng.guocun</span></span><br></pre></td></tr></table></figure>
<h4 id="2、Reader、Writer"><a href="#2、Reader、Writer" class="headerlink" title="2、Reader、Writer"></a>2、Reader、Writer</h4><p>Reader Writer 上面有提到过，就是常见的读写文件的时候经常会用到，就是对文件的一个抽象，但是不仅这些，比如常见的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewScanner returns a new Scanner to read from r.</span></span><br><span class="line"><span class="comment">// The split function defaults to ScanLines.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScanner</span><span class="params">(r io.Reader)</span></span> *<span class="type">Scanner</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;<span class="type">Scanner</span>&#123;</span><br><span class="line">		r:            r,</span><br><span class="line">		<span class="built_in">split</span>:        <span class="type">ScanLines</span>,</span><br><span class="line">		maxTokenSize: <span class="type">MaxScanTokenSize</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这的参数也是一个Reader，还有很多的底层的代码都是基于 Reader Writer 的，这里就不一一举例了。</p>
<h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="5. 函数式编程"></a>5. 函数式编程</h2><h3 id="5-0、函数式编程"><a href="#5-0、函数式编程" class="headerlink" title="5.0、函数式编程"></a>5.0、函数式编程</h3><p>Go语言作为一个通用型语言，它对函数式编程主要体现在闭包上面。</p>
<h4 id="1、函数式编程-VS-函数指针"><a href="#1、函数式编程-VS-函数指针" class="headerlink" title="1、函数式编程 VS 函数指针"></a>1、函数式编程 VS 函数指针</h4><ul>
<li><p>函数是一等公民：参数、变量、返回值都可以是函数，在别的语言中大多不是这样的，比如在C++里面只有函数指针，在Java里面我们只能调用，不能把函数传给别人。</p>
</li>
<li><p>高阶函数：参数可以是函数，1.6.3里面的apply函数就是一个高阶函数。</p>
</li>
<li><p>函数 –&gt; 闭包：首先用个例子来了解一下闭包的用法</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	a := adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++  &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"0 + 1 + 2 + ... + %d = %d\n"</span>, i, a(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出为</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">6</span> = <span class="number">21</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">8</span> = <span class="number">36</span></span><br><span class="line"><span class="symbol">0 </span>+ <span class="number">1</span> + <span class="number">2</span> + ... + <span class="number">9</span> = <span class="number">45</span></span><br></pre></td></tr></table></figure>
<p>上述的 v 就称为局部变量， sum 称为自由变量，<code>func(v int) int {
        sum += v
        return sum
    }</code> 称为函数体，整个就叫做一个闭包。用一张图来概括就是：</p>
<p><img src="https://nos.netease.com/hi-163-common/media/15231955282344/15245726261451.jpg" alt=""></p>
<h4 id="2、“正统”函数式编程"><a href="#2、“正统”函数式编程" class="headerlink" title="2、“正统”函数式编程"></a>2、“正统”函数式编程</h4><ul>
<li><p>不可变性：不能有状态，只有常量和函数；当然这和平常的函数不一样，连变量都没有，甚至连选择语句、循环语句都没有。</p>
</li>
<li><p>函数只能有一个参数</p>
</li>
</ul>
<p>要是上面的累加想做一个稍微正统函数怎么做呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iAdder <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">adderV2</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">iAdder</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, iAdder)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> base + v, adderV2(base + v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	a := adderV2(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</span><br><span class="line">		<span class="keyword">var</span> s <span class="keyword">int</span></span><br><span class="line">		s, a = a(i)</span><br><span class="line">		fmt.Printf(<span class="string">"0 + 1 + 2 + ... + %d = %d\n"</span>, i, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然正统的不一定是最好的，正统式的写法经常导致代码的可读性变得不是很好。</p>
<h3 id="5-1、函数式编程实例一"><a href="#5-1、函数式编程实例一" class="headerlink" title="5.1、函数式编程实例一"></a>5.1、函数式编程实例一</h3><h3 id="5-2、函数式编程实例二"><a href="#5-2、函数式编程实例二" class="headerlink" title="5.2、函数式编程实例二"></a>5.2、函数式编程实例二</h3><h2 id="6-错误处理和资源管理"><a href="#6-错误处理和资源管理" class="headerlink" title="6. 错误处理和资源管理"></a>6. 错误处理和资源管理</h2><h3 id="6-0、defer调用"><a href="#6-0、defer调用" class="headerlink" title="6.0、defer调用"></a>6.0、defer调用</h3><h3 id="6-1、错误处理概念"><a href="#6-1、错误处理概念" class="headerlink" title="6.1、错误处理概念"></a>6.1、错误处理概念</h3><h3 id="6-2、服务器统一出错处理1"><a href="#6-2、服务器统一出错处理1" class="headerlink" title="6.2、服务器统一出错处理1"></a>6.2、服务器统一出错处理1</h3><h3 id="6-3、panic和recover"><a href="#6-3、panic和recover" class="headerlink" title="6.3、panic和recover"></a>6.3、panic和recover</h3><h2 id="7-测试和性能调优"><a href="#7-测试和性能调优" class="headerlink" title="7. 测试和性能调优"></a>7. 测试和性能调优</h2><h3 id="7-0、测试"><a href="#7-0、测试" class="headerlink" title="7.0、测试"></a>7.0、测试</h3><h3 id="7-1、代码覆盖率和性能测试"><a href="#7-1、代码覆盖率和性能测试" class="headerlink" title="7.1、代码覆盖率和性能测试"></a>7.1、代码覆盖率和性能测试</h3><h3 id="7-2、使用pprof进行性能调优"><a href="#7-2、使用pprof进行性能调优" class="headerlink" title="7.2、使用pprof进行性能调优"></a>7.2、使用pprof进行性能调优</h3><h3 id="7-3、生成文档和事例代码"><a href="#7-3、生成文档和事例代码" class="headerlink" title="7.3、生成文档和事例代码"></a>7.3、生成文档和事例代码</h3><h2 id="8-Goroutine"><a href="#8-Goroutine" class="headerlink" title="8. Goroutine"></a>8. Goroutine</h2><h3 id="8-0、Goroutine介绍"><a href="#8-0、Goroutine介绍" class="headerlink" title="8.0、Goroutine介绍"></a>8.0、Goroutine介绍</h3><h3 id="8-1、Go语言调度器"><a href="#8-1、Go语言调度器" class="headerlink" title="8.1、Go语言调度器"></a>8.1、Go语言调度器</h3><h2 id="9-Channel"><a href="#9-Channel" class="headerlink" title="9. Channel"></a>9. Channel</h2><h3 id="9-0、Channel介绍"><a href="#9-0、Channel介绍" class="headerlink" title="9.0、Channel介绍"></a>9.0、Channel介绍</h3><h3 id="9-1、使用Channel等待任务结束"><a href="#9-1、使用Channel等待任务结束" class="headerlink" title="9.1、使用Channel等待任务结束"></a>9.1、使用Channel等待任务结束</h3><h3 id="9-2、使用Channel进行树遍历"><a href="#9-2、使用Channel进行树遍历" class="headerlink" title="9.2、使用Channel进行树遍历"></a>9.2、使用Channel进行树遍历</h3><h3 id="9-3、用select进行调度"><a href="#9-3、用select进行调度" class="headerlink" title="9.3、用select进行调度"></a>9.3、用select进行调度</h3><h3 id="9-4、传统同步机制"><a href="#9-4、传统同步机制" class="headerlink" title="9.4、传统同步机制"></a>9.4、传统同步机制</h3><h2 id="10-Http及其他标准库"><a href="#10-Http及其他标准库" class="headerlink" title="10. Http及其他标准库"></a>10. Http及其他标准库</h2><h3 id="10-0、Http标准库介绍"><a href="#10-0、Http标准库介绍" class="headerlink" title="10.0、Http标准库介绍"></a>10.0、Http标准库介绍</h3><h3 id="10-1、其他库介绍"><a href="#10-1、其他库介绍" class="headerlink" title="10.1、其他库介绍"></a>10.1、其他库介绍</h3><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h2></div><div class="tags"><a href="/tags/Go语言/">Go语言</a><a href="/tags/入门/">入门</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/blog/2018/03/15/taste-gdb/" class="next">GDB抓虫之旅</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-前言"><span class="toc-text">0. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-基础"><span class="toc-text">1. 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-0、环境搭建"><span class="toc-text">1.0、环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、下载安装包安装"><span class="toc-text">1、下载安装包安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、命令行安装"><span class="toc-text">2、命令行安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、变量定义"><span class="toc-text">1.1、变量定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、通过var关键字"><span class="toc-text">1、通过var关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、使用-定义变量"><span class="toc-text">2、使用 := 定义变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2、内建变量类型"><span class="toc-text">1.2、内建变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、bool-、string"><span class="toc-text">1、bool 、string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、-u-int、-u-int8、-u-int16、-u-int32、-u-int64、uintptr"><span class="toc-text">2、(u)int、(u)int8、(u)int16、(u)int32、(u)int64、uintptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、byte、rune"><span class="toc-text">3、byte、rune</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、float32、float64、complex64、complex128"><span class="toc-text">4、float32、float64、complex64、complex128</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3、常量与枚举"><span class="toc-text">1.3、常量与枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4、条件语句"><span class="toc-text">1.4、条件语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、if"><span class="toc-text">1、if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、switch"><span class="toc-text">2、switch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5、循环"><span class="toc-text">1.5、循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、for"><span class="toc-text">1、for</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6、函数"><span class="toc-text">1.6、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、普通函数"><span class="toc-text">1、普通函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、多返回值"><span class="toc-text">2、多返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、函数可作为参数"><span class="toc-text">3、函数可作为参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、没有默认参数、没有可选参数"><span class="toc-text">4、没有默认参数、没有可选参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7、指针"><span class="toc-text">1.7、指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、指针不能运算"><span class="toc-text">1、指针不能运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、Go语言只有值传递"><span class="toc-text">2、Go语言只有值传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-内建容器"><span class="toc-text">2. 内建容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-0、数组"><span class="toc-text">2.0、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、定义"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、数组是值类型"><span class="toc-text">2、数组是值类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、Slice-切片-的概念"><span class="toc-text">2.1、Slice(切片)的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、Slice定义"><span class="toc-text">1、Slice定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、ReSlice"><span class="toc-text">2、ReSlice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、Slice拓展"><span class="toc-text">3、Slice拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、Slice实现"><span class="toc-text">4、Slice实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、Slice-切片-的操作"><span class="toc-text">2.2、Slice(切片)的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、向Slice添加元素"><span class="toc-text">1、向Slice添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、创建slice"><span class="toc-text">2、创建slice</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、Copy-Slice数据"><span class="toc-text">3、Copy Slice数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、Slice删除元素"><span class="toc-text">4、Slice删除元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、Map"><span class="toc-text">2.3、Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、创建map"><span class="toc-text">1、创建map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、获取map元素"><span class="toc-text">2、获取map元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、删除元素"><span class="toc-text">3、删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、map的key"><span class="toc-text">4、map的key</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、字符和字符串处理"><span class="toc-text">2.4、字符和字符串处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、rune介绍"><span class="toc-text">1、rune介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、字符串处理"><span class="toc-text">2、字符串处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-面向“对象”"><span class="toc-text">3. 面向“对象”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0、结构体和方法"><span class="toc-text">3.0、结构体和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、结构体的创建"><span class="toc-text">1、结构体的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、方法创建"><span class="toc-text">2、方法创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、包和封装"><span class="toc-text">3.1、包和封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、命名规范"><span class="toc-text">1、命名规范</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、包的概念"><span class="toc-text">2、包的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2、扩展已有类型"><span class="toc-text">3.2、扩展已有类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、定义别名（1-9新特性）"><span class="toc-text">1、定义别名（1.9新特性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、使用组合"><span class="toc-text">2、使用组合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3、GOPATH以及目录结构"><span class="toc-text">3.3、GOPATH以及目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、go-get获取第三方库"><span class="toc-text">1、go get获取第三方库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、目录结构"><span class="toc-text">2、目录结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-面向接口"><span class="toc-text">4. 面向接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-0、Duck-Typing的概念"><span class="toc-text">4.0、Duck Typing的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1、接口的定义和实现"><span class="toc-text">4.1、接口的定义和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、接口的定义"><span class="toc-text">1、接口的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、接口的实现"><span class="toc-text">2、接口的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2、接口值的类型"><span class="toc-text">4.2、接口值的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、接口变量里面有什么"><span class="toc-text">1、接口变量里面有什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、查看接口变量"><span class="toc-text">2、查看接口变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3、接口的组合"><span class="toc-text">4.3、接口的组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、定义-1"><span class="toc-text">1、定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、实例演示"><span class="toc-text">2、实例演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4、常用的系统接口"><span class="toc-text">4.4、常用的系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、Stringer"><span class="toc-text">1、Stringer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、Reader、Writer"><span class="toc-text">2、Reader、Writer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-函数式编程"><span class="toc-text">5. 函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-0、函数式编程"><span class="toc-text">5.0、函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、函数式编程-VS-函数指针"><span class="toc-text">1、函数式编程 VS 函数指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、“正统”函数式编程"><span class="toc-text">2、“正统”函数式编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1、函数式编程实例一"><span class="toc-text">5.1、函数式编程实例一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2、函数式编程实例二"><span class="toc-text">5.2、函数式编程实例二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-错误处理和资源管理"><span class="toc-text">6. 错误处理和资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-0、defer调用"><span class="toc-text">6.0、defer调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1、错误处理概念"><span class="toc-text">6.1、错误处理概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2、服务器统一出错处理1"><span class="toc-text">6.2、服务器统一出错处理1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3、panic和recover"><span class="toc-text">6.3、panic和recover</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-测试和性能调优"><span class="toc-text">7. 测试和性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-0、测试"><span class="toc-text">7.0、测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1、代码覆盖率和性能测试"><span class="toc-text">7.1、代码覆盖率和性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2、使用pprof进行性能调优"><span class="toc-text">7.2、使用pprof进行性能调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3、生成文档和事例代码"><span class="toc-text">7.3、生成文档和事例代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Goroutine"><span class="toc-text">8. Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-0、Goroutine介绍"><span class="toc-text">8.0、Goroutine介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1、Go语言调度器"><span class="toc-text">8.1、Go语言调度器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Channel"><span class="toc-text">9. Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-0、Channel介绍"><span class="toc-text">9.0、Channel介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1、使用Channel等待任务结束"><span class="toc-text">9.1、使用Channel等待任务结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2、使用Channel进行树遍历"><span class="toc-text">9.2、使用Channel进行树遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3、用select进行调度"><span class="toc-text">9.3、用select进行调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4、传统同步机制"><span class="toc-text">9.4、传统同步机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Http及其他标准库"><span class="toc-text">10. Http及其他标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-0、Http标准库介绍"><span class="toc-text">10.0、Http标准库介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1、其他库介绍"><span class="toc-text">10.1、其他库介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-总结"><span class="toc-text">11. 总结</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2018/04/20/a-bite-of-golang/">A Bite of Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/03/15/taste-gdb/">GDB抓虫之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/02/08/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Go语言/" style="font-size: 15px;">Go语言</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/入门/" style="font-size: 15px;">入门</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">ShengGuocun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e3ed45ce04d57be9fec7dd674aec65e0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>