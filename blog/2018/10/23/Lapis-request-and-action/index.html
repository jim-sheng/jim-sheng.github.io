<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录生活的每一滴"><title>Lapis-Request和Action | 盛国存</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Lapis-Request和Action</h1><a id="logo" href="/.">盛国存</a><p class="description">个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Lapis-Request和Action</h1><div class="post-meta"><a href="/blog/2018/10/23/Lapis-request-and-action/#comments" class="comment-count"></a><p><span class="date">Oct 23, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>【原文】 <a href="http://leafo.net/lapis/reference/actions.html" target="_blank" rel="noopener">http://leafo.net/lapis/reference/actions.html</a></p>
<p>每一个 <code>Lapis</code> 的 <code>Http</code> 请求都会遵循 <code>Nginx</code> 的基础流程。第一步：路由；一个路由必须有一个匹配的 <code>URL</code> 与之对应。从语法角度，你定义一个路由同时你需要绑定一个关联的 <code>Action</code> 。当一个请求匹配到你之前定义的路由的时候，对应的 <code>Action</code> 的方法就会被调用。</p>
<p>所有 <code>Action</code> 被调用时都会传入一个 <code>Request</code> 对象参数。这个 <code>Request</code> 对象主要用于 <code>Action</code> 和 <code>view</code> 的数据传输。另外，<code>Request</code> 对象还充当着 <code>WebServer</code> 返回 <code>Client</code> 结果的接口。</p>
<p>这些 <code>Action</code> 的返回结果通常会被用于渲染输出。字符串的返回结果通常直接交由浏览器直接解析。<code>table</code> 的返回类型通常是会被当作渲染的可选参数。如果返回值不止一个，后期会将它们合并成一个结果集。所以输出结果可以返回字符串加 <code>table</code>。</p>
<p>如果路由文件内没有定义与当前请求匹配的路由，会进入到默认的路由，在后面的 <code>application callback</code> 中会继续介绍。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由定义有它自己的语法规则。下面用一段简单的事例做一下介绍：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lapis = <span class="built_in">require</span>(<span class="string">"lapis"</span>)</span><br><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="keyword">end</span>)</span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="keyword">end</span>)</span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"/users/all"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>上面的路由规则是一个精确匹配的路由定义。比如：一个 <code>/hello/world</code> 不会匹配到 <code>/hello</code> 的路由上。</p>
<p>当然你可以指定一个命名参数和 <code>:</code> 跟着这个名称。这个参数会匹配除了 <code>/</code> 之外的任意字符（一般情况下）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"/page/:page"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="built_in">print</span>(self.params.page)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"/post/:post_id/:post_name"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： 我们可以调用 <code>print</code> 进行 <code>debug</code> 。在 <code>OpenResty</code> 内运行的时候，<code>print</code> 的输出会发送到 <code>Nginx</code> 的 <code>notice</code> 日志。</p>
<p>捕获的路由参数的值会被存储到 <code>Request</code> 对象的 <code>params</code> 字段中。当然每个命名参数至少包含一个字符，否则会匹配失败。</p>
<p><code>splat</code> 是另外一种匹配模式，它可以匹配所有甚至包含 <code>/</code> 字符。所有通过 <code>splat</code> 规则匹配到的数据会被存储到 <code>Request</code> 对象的名叫 <code>params</code> 的 <code>table</code> 中的 <code>splat</code> 的参数中。它的语法上就是一个 <code>*</code> ：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"/browse/*"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="built_in">print</span>(self.params.splat)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"/user/:name/file/*"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="built_in">print</span>(self.params.name, self.params.splat)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>如果你直接把长文本直接拼在地址后面，将不会匹配成功。当然有其他的办法，你可以在URL参数的最后加上 <code>.zip</code> 后缀以及加上 <code>/files/:filename.zip</code> 的路由规则。</p>
<h3 id="路由可选组件"><a href="#路由可选组件" class="headerlink" title="路由可选组件"></a>路由可选组件</h3><p>括号可以让路由规则变得可选：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/projects/:username(/:project)</span><br></pre></td></tr></table></figure>
<p>上面的路由规则可以匹配 <code>/projects/leafo</code> 也可以匹配 <code>/projects/leafo/lapis</code> 。可选项如果没有匹配到数据的话会是一个 <code>nil</code> 值。</p>
<p>当然路由的可选规则还可以嵌套，比如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/settings(/:username(/:page))(.:<span class="built_in">format</span>)</span><br></pre></td></tr></table></figure>
<h3 id="路由参数字符类"><a href="#路由参数字符类" class="headerlink" title="路由参数字符类"></a>路由参数字符类</h3><p>一个字符类可以像 <code>Lua</code> 语法一样限制一个参数的规则。下面的这路由例子就是为了确保 <code>user_id</code> 是一个数字：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/user/:user_id[%d]/posts</span><br></pre></td></tr></table></figure>
<p>下面这个路由就是限制是一个 16进制 的参数。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/color/:hex[a-fA-F%d]</span><br></pre></td></tr></table></figure>
<h3 id="路由优先级"><a href="#路由优先级" class="headerlink" title="路由优先级"></a>路由优先级</h3><p>首先第一步会把所有的匹配到的路由都匹配进来，然后进行从高到低排序：</p>
<ul>
<li>精确路由 <code>/hello/world</code></li>
<li>可变参路由 <code>/hello/:variable</code><ul>
<li>每添加一个可变参数会降低一下路由的优先级</li>
</ul>
</li>
<li>模糊路由 <code>/hello/*</code><ul>
<li>每加一个模糊匹配的规则它的优先级就会升高一级</li>
</ul>
</li>
</ul>
<p>比如：<code>/hello/*spat</code> 和 <code>/hello/*spat/world/*rest</code> 第二个的优先级要比第一个更高。</p>
<p>以上就是路由的优先级排序：精确路由 <code>&gt;</code> 可变参数路由 <code>&gt;</code> 模糊路由</p>
<h2 id="路由名称"><a href="#路由名称" class="headerlink" title="路由名称"></a>路由名称</h2><p>路由名称不再是一个硬编码的 <code>URL</code> 结构的一部分，而是可以通过路由的名称可以直观的知道路由对应的 <code>Action</code> 是干嘛的，同时可以方便重定向到其它的路由。</p>
<p>在定义路由的时候的第一个参数就是用于命名路由的：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lapis = <span class="built_in">require</span>(<span class="string">"lapis"</span>)</span><br><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"index"</span>, <span class="string">"/"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">return</span> self:url_for(<span class="string">"user_profile"</span>, &#123; name = <span class="string">"leaf"</span> &#125;)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"user_profile"</span>, <span class="string">"/user/:name"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello "</span> .. self.params.name .. <span class="string">", go home: "</span> .. self:url_for(<span class="string">"index"</span>)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以用 <code>self:url_for()</code> 用于重定向操作。第一个参数为重定向的路由的名称，第二个参数为可选参数可以用于传路由的参数。</p>
<p><strong>注意</strong>：后续会继续介绍 <code>url_for</code> 的不同的生成 <code>URL</code> 的用法。</p>
<h2 id="Http的请求方式"><a href="#Http的请求方式" class="headerlink" title="Http的请求方式"></a>Http的请求方式</h2><p>通常一个 <code>URL</code> 地址可以通过定义不同的 <code>Http</code> 请求方式来定义出不同的 <code>Action</code> 。<code>Lapis</code> 内部的方法 <code>respond_to</code> 可以完成上述的目标。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lapis = <span class="built_in">require</span>(<span class="string">"lapis"</span>)</span><br><span class="line"><span class="keyword">local</span> respond_to = <span class="built_in">require</span>(<span class="string">"lapis.application"</span>).respond_to</span><br><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"create_account"</span>, <span class="string">"/create-account"</span>, respond_to(&#123;</span><br><span class="line">  GET = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123; render = <span class="literal">true</span> &#125;</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">  POST = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    do_something(self.params)</span><br><span class="line">    <span class="keyword">return</span> &#123; redirect_to = self:url_for(<span class="string">"index"</span>) &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><code>respond_to</code> 也可以设置一个前置过滤器用于在请求前的一些操作。我们可以定义一个 <code>before</code> 函数。同时这个和前置过滤器有相同的语义，如果你调用了 <code>self:write()</code> 此调用往后的逻辑讲不会继续被执行。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lapis = <span class="built_in">require</span>(<span class="string">"lapis"</span>)</span><br><span class="line"><span class="keyword">local</span> respond_to = <span class="built_in">require</span>(<span class="string">"lapis.application"</span>).respond_to</span><br><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"edit_user"</span>, <span class="string">"/edit-user/:id"</span>, respond_to(&#123;</span><br><span class="line">  before = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    self.user = Users:<span class="built_in">find</span>(self.params.id)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.user <span class="keyword">then</span></span><br><span class="line">      self:<span class="built_in">write</span>(&#123;<span class="string">"Not Found"</span>, <span class="built_in">status</span> = <span class="number">404</span>&#125;)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">  GET = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Edit account "</span> .. self.user.name</span><br><span class="line">  <span class="keyword">end</span>,</span><br><span class="line">  POST = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">    self.user:update(self.params.user)</span><br><span class="line">    <span class="keyword">return</span> &#123; redirect_to = self:url_for(<span class="string">"index"</span>) &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>当然还有一个特殊情况：任意的 <code>POST</code> 请求如果它的 <code>Content-type</code> 头信息被设置为 <code>application/x-www-form-urlencoded</code> ，不管有没有 <code>respond_to</code> ，所有的请求体会被转义同时所有的参数会赋值给 <code>self.params</code>。</p>
<p>在此之前你可以看到过调用 <code>app:get()</code> 和 <code>app:post()</code> 方法的例子。它们都是基于 <code>respond_to</code> 做了一些封装，这样你可以快速的定义一个 <code>Http</code> 请求。比如 ：<code>get</code> 、<code>post</code> 、<code>delete</code> 、<code>put</code> 。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app:get(<span class="string">"/test"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"I only render for GET requests"</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">app:delete(<span class="string">"/delete-account"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="comment">-- do something destructive</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<h2 id="前置过滤器"><a href="#前置过滤器" class="headerlink" title="前置过滤器"></a>前置过滤器</h2><p>有时候你需要在执行某个 <code>Action</code> 之前运行一段代码。一个很常见的例子，比如：设置用户的 <code>session</code> 。我们可以定义一个前置过滤器或者一个函数在 <code>Action</code> 之前，比如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app:before_filter(<span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">if</span> self.session.user <span class="keyword">then</span></span><br><span class="line">    self.current_user = load_user(self.session.user)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"current user is: "</span> .. <span class="built_in">tostring</span>(self.current_user)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>这样就相当于调用了 <code>app:before_filter</code>。这样里面的逻辑就会按照既定的顺序执行。</p>
<p>如果在前置过滤器中调用了 <code>self:write()</code> 方法，然后这个 <code>action</code> 的逻辑就会运行至此结束。比如我们可以结束某个 <code>Action</code> 的后续逻辑或者没有满足某个条件是重定向到其他的页面：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app:before_filter(<span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> user_meets_requirements() <span class="keyword">then</span></span><br><span class="line">    self:<span class="built_in">write</span>(&#123;redirect_to = self:url_for(<span class="string">"login"</span>)&#125;)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"login"</span>, <span class="string">"/login"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>： <code>self:write()</code> 是一个常规的 <code>Action</code> 返回结果的过程，所以在 <code>self:write()</code> 中你可以返回你过去在 <code>Action</code> 里面的返沪的数据。</p>
<h2 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a><code>Request</code> 对象</h2><p>每个 <code>Action</code> 的第一个参数就是 <code>Request</code> 对象。也就是上面例子中的 <code>self</code> 。</p>
<p><code>Request</code> 对象有如下的参数：</p>
<ul>
<li><code>self.params</code> – 一个 <code>table</code> ，包含所有 <code>GET</code> 、<code>POST</code> 的请求参数</li>
<li><code>self.req</code> – 原生的 <code>request table</code> （由 <code>ngx</code> 生成）</li>
<li><code>self.res</code> – 原生的 <code>response table</code> (用于更新 <code>ngx</code>)</li>
<li><code>self.app</code> – 应用的实例</li>
<li><code>self.cookies</code>  – <code>cookies</code> 的 <code>table</code> ，可用于设置 <code>Cookies</code> 数据，且值仅支持字符串</li>
<li><code>self.session</code> – 和 <code>Cookie</code> 对应的，可以存储任何可以被 <code>JSON</code> 编码的类型</li>
<li><code>self.route_name</code> – 与请求匹配的路由名称</li>
<li><code>self.options</code> – 控制请求的选项，底层都通过 <code>write</code></li>
<li><code>self.buffer</code> – 输出的缓冲，不需要通过人为的干涉，底层依然通过 <code>write</code></li>
</ul>
<p><code>Request</code> 对象还有其他的方法：</p>
<ul>
<li><code>write(options, ...)</code> – 告知请求如何渲染结果</li>
<li><code>url_for(route, params, ...)</code> – 获取一个命名的路由的<code>URL</code> 地址，或者一个对象</li>
<li><code>build_url(path, params)</code> – <code>build</code> 一个完全限定的 <code>URL</code> 地址</li>
<li><code>html(fn)</code> – 通过 <code>Html</code> 构造器的语法生成一个字符串</li>
</ul>
<h3 id="req"><a href="#req" class="headerlink" title="@req"></a><code>@req</code></h3><p>这是对 <code>ngx</code> 中的原生的 <code>self.req</code> 进行的一次封装。以下是它的相关的特性。</p>
<ul>
<li><code>self.req.headers</code> – <code>Request</code> 的 <code>header</code> 的 <code>table</code></li>
<li><code>self.req.parsed_url</code> – 请求的 <code>URL</code> 的转义的结果。包含 <code>scheme</code> 、<code>path</code> 、<code>host</code> 、<code>port</code> 和 <code>query</code> 这些属性。</li>
<li><code>self.req.params_post</code> – 存储所有的 <code>POST</code> 请求的参数</li>
<li><code>self.req.params_get</code> – 存储所有的 <code>GET</code> 请求的参数</li>
</ul>
<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a><code>Cookies</code></h3><p>你可以通过 <code>self.cookies</code> 进行 <code>cookie</code> 的读写操作。当然需要注意的是，当你遍历 <code>cookie</code> 内部的数据的时候需要判断空的情况：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"/my-cookies"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(self.cookies) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>现有的 <code>cookie</code> 会存储在 <code>metatable</code> 的 <code>__index</code> 中。因为所有的数据都会存储在 <code>self.cookies</code> 中，所以我们可以直接在 <code>action</code> 中就使用。</p>
<p>因此，操作 <code>cookie</code> 的代码就会变得下面这么简洁：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"/sets-cookie"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  self.cookies.foo = <span class="string">"bar"</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>通常情况下所有的 <code>cookie</code> 还有其它的属性 <code>Path=/; HttpOnly</code> （这会创建一个 <code>Session Cookie</code>）。你可以通过 <code>cookie_attributes</code> 函数配置你应用里面的 <code>Cookie</code> 设置。下面是一个简单的设置过期时间的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">date</span> = <span class="built_in">require</span>(<span class="string">"date"</span>)</span><br><span class="line"><span class="keyword">local</span> app = lapis.Application()</span><br><span class="line"></span><br><span class="line">app.cookie_attributes = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">local</span> expires = <span class="built_in">date</span>(<span class="literal">true</span>):adddays(<span class="number">365</span>):fmt(<span class="string">"$&#123;http&#125;"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Expires="</span> .. expires .. <span class="string">"; Path=/; HttpOnly"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>cookie_attributes</code> 方法将 <code>Request</code> 对象作为它的第一个参数，然后下面就是具体的 <code>Cookie</code> 的设置操作。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><code>self.session</code> 是一个更高级的请求方式。<code>session</code> 的内容会被序列化成 <code>JSON</code> 然后存储到特定的 <code>cookie</code> 中。这些序列化的 <code>cookie</code> 通常是经过签名的，所以通常这些数据不能随意篡改的。</p>
<p><code>session</code> 的读写方式和 <code>cookie</code> 的方式很像：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="built_in">match</span>(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> self.session.current_user <span class="keyword">then</span></span><br><span class="line">    self.session.current_user = <span class="string">"Adam"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>默认 <code>session</code> 的名称会存储在叫 <code>lapis_session</code> 的 <code>cookie</code> 中。当然可以通过修改配置文件中的 <code>session_name</code> 变量来修改 <code>session</code> 的名称。<code>session</code> 是通过你的应用的密钥进行签名，它存储在你的配置文件变量 <code>secret</code> 中。强烈建议替换掉这个默认值。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- config.lua</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">config</span> = <span class="built_in">require</span>(<span class="string">"lapis.config"</span>).<span class="built_in">config</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">config</span>(<span class="string">"development"</span>, &#123;</span><br><span class="line">  session_name = <span class="string">"my_app_session"</span>,</span><br><span class="line">  secret = <span class="string">"this is my secret string 123456"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Request-对象的方法"><a href="#Request-对象的方法" class="headerlink" title="Request 对象的方法"></a><code>Request</code> 对象的方法</h2><h3 id="write-things"><a href="#write-things" class="headerlink" title="write(things...)"></a><code>write(things...)</code></h3><p>写所有的参数。不同的 <code>action</code> 根据参数的类型进行区分。</p>
<ul>
<li><code>string</code> – 字符串附加到输出缓冲区</li>
<li><code>function</code>(或者可以调用的 <code>table</code>) – 在输出缓冲区被调用，同时结果递归传给 <code>write</code></li>
<li><code>table</code> – 键值对会分配给 <code>self.options</code>，其它的值会递归传给 <code>write</code></li>
</ul>
<p>大多数的情况下，将调用 <code>write</code> 作为 <code>action</code> 的返回值传给 <code>write</code> 这样的方式没有必要。在前置过滤器中，<code>write</code> 有双重作用，不但可以输出内容，还可以取消正在运行的 <code>action</code>。</p>
<h3 id="url-for-name-or-obj-params-query-params-nil"><a href="#url-for-name-or-obj-params-query-params-nil" class="headerlink" title="url_for(name_or_obj, params, query_params=nil, ...)"></a><code>url_for(name_or_obj, params, query_params=nil, ...)</code></h3><p>给 <code>name_or_obj</code> 生成一个 <code>URL</code>。</p>
<p><strong>注意</strong>：<code>url_for</code> 命名上有点不太恰当，因为通常它会生成一个页面的路径。如果你想得到一个完整的路径，你可以使用 <code>build_for</code> 函数。</p>
<p>如果 <code>name_or_obj</code> 是一个字符串，然后会去查找这个名称的 <code>route</code> ，参数就是二个参数的值。如果没有指定名称的路由，会抛出一个错误。</p>
<p>事例如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"index"</span>, <span class="string">"/"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">app:<span class="built_in">match</span>(<span class="string">"user_data"</span>, <span class="string">"/data/:user_id/:data_field"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>具体的 <code>url_for</code> 的使用如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- returns: /</span></span><br><span class="line">self:url_for(<span class="string">"index"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- returns: /data/123/height</span></span><br><span class="line">self:url_for(<span class="string">"user_data"</span>, &#123; user_id = <span class="number">123</span>, data_field = <span class="string">"height"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>如果第三个参数 <code>query_params</code> 有值。将会转成具体的 <code>URL</code> 参数拼接在地址后面。如果 <code>route</code> 没有任何的参数，第二个参数仍要传一个 <code>nil</code>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- returns: /data/123/height?sort=asc</span></span><br><span class="line">self:url_for(<span class="string">"user_data"</span>, &#123; user_id = <span class="number">123</span>, data_field = <span class="string">"height"</span>&#125;, &#123; <span class="built_in">sort</span> = <span class="string">"asc"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- returns: /?layout=new</span></span><br><span class="line">self:url_for(<span class="string">"index"</span>, <span class="literal">nil</span>, &#123;layout = <span class="string">"new"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>当然 <code>route</code> 的所有的可选组件只有在被传值之后才会引入进来。如果没有被赋值就会被忽略。</p>
<p>比如，给出的 <code>route</code> 规则如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"user_page"</span>, <span class="string">"/user/:username(/:page)(.:format)"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>以下是 <code>URL</code> 的生成逻辑：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- returns: /user/leafo</span></span><br><span class="line">self:url_for(<span class="string">"user_page"</span>, &#123; username = <span class="string">"leafo"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- returns: /user/leafo/projects</span></span><br><span class="line">self:url_for(<span class="string">"user_page"</span>, &#123; username = <span class="string">"leafo"</span>, page = <span class="string">"projects"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- returns: /user/leafo.json</span></span><br><span class="line">self:url_for(<span class="string">"user_page"</span>, &#123; username = <span class="string">"leafo"</span>, <span class="built_in">format</span> = <span class="string">"json"</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- returns: /user/leafo/code.json</span></span><br><span class="line">self:url_for(<span class="string">"user_page"</span>, &#123; username = <span class="string">"leafo"</span>, page = <span class="string">"code"</span>, <span class="built_in">format</span> = <span class="string">"json"</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>如果一个 <code>route</code> 包含一个通用匹配符，在传值的过程中你可以将数据赋值给 <code>splat</code> 参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"browse"</span>, <span class="string">"/browse(/*)"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="comment">-- ...</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- returns: /browse</span></span><br><span class="line">self:url_for(<span class="string">"browse"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- returns: /browse/games/recent</span></span><br><span class="line">self:url_for(<span class="string">"browse"</span>, &#123; splat = <span class="string">"games/recent"</span> &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="url-for-的第一个参数为对象"><a href="#url-for-的第一个参数为对象" class="headerlink" title="url_for 的第一个参数为对象"></a><code>url_for</code> 的第一个参数为对象</h3><p>如果 <code>name_or_obj</code> 是一个 <code>table</code>，然后在这个 <code>table</code> 中调用了 <code>url_params</code> 方法，最终返回值传递给 <code>url_for</code>。</p>
<p><code>url_params</code> 方法里面的 <code>request</code> 对象参数以及其它的参数都会传递给 <code>url_for</code>。</p>
<p>我们常见的方式是在 <code>model</code> 中实现 <code>url_params</code>，同时赋予相关的功能。比如：一个 <code>User</code> <code>model</code> 定义了一个 <code>url_params</code> 方法，实现查看用户详情页的功能：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Users = Model:extend(<span class="string">"users"</span>, &#123;</span><br><span class="line">  url_params = <span class="function"><span class="keyword">function</span><span class="params">(self, req, ...)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"user_profile"</span>, &#123; id = self.id &#125;, ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结合上面的 <code>url_for</code> 实例演示一下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> user = Users:<span class="built_in">find</span>(<span class="number">100</span>)</span><br><span class="line">self:url_for(user)</span><br><span class="line"><span class="comment">-- could return: /user-profile/100</span></span><br></pre></td></tr></table></figure>
<p>你可能注意到传递给 <code>url_params</code> 一个 <code>...</code> 参数以及返回值里面也有 <code>...</code>。意思是可以传递 <code>query_params</code> 参数：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> user = Users:<span class="built_in">find</span>(<span class="number">1</span>)</span><br><span class="line">self:url_for(user, &#123; page = <span class="string">"likes"</span> &#125;)</span><br><span class="line"><span class="comment">-- could return: /user-profile/100?page=likes</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-url-key-方法"><a href="#使用-url-key-方法" class="headerlink" title="使用 url_key 方法"></a>使用 <code>url_key</code> 方法</h3><p>如果 <code>params</code> 的参数的值是一个字符串类型，会直接赋值到生成的地址中。如果是一个 <code>table</code> 类型，在 <code>table</code> 中会调用 <code>url_key</code> 方法，然后返回值同样会赋值到生成的地址中。</p>
<p>举个例子，在一个 <code>user</code> <code>model</code>中使用 <code>url_key</code> 方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Users = Model:extend(<span class="string">"users"</span>, &#123;</span><br><span class="line">  url_key = <span class="function"><span class="keyword">function</span><span class="params">(self, route_name)</span></span></span><br><span class="line">    <span class="keyword">return</span> self.id</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果我们想要生成一个用户详情页的路径，通常会这么写：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> user = Users:<span class="built_in">find</span>(<span class="number">1</span>)</span><br><span class="line">self:url_for(<span class="string">"user_profile"</span>, &#123;id = user.id&#125;)</span><br></pre></td></tr></table></figure>
<p>因为上面的 <code>url_key</code> 的例子中 <code>User</code> 对象等同于 <code>id</code> 参数，所以写法上可以变换一下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> user = Users:<span class="built_in">find</span>(<span class="number">1</span>)</span><br><span class="line">self:url_for(<span class="string">"user_profile"</span>, &#123;id = user&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>url_key</code> 方法的第一个参数是路径名称，所以我们可以根据自己的需求修改相应的 <code>route</code> 的句柄。</p>
<h3 id="build-for-path-options"><a href="#build-for-path-options" class="headerlink" title="build_for(path, [options])"></a><code>build_for(path, [options])</code></h3><p>构建一个绝对地址。</p>
<p>比如，我们的服务运行在 <code>localhost:8080</code> 上面：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self:build_url() <span class="comment">--&gt; http://localhost:8080</span></span><br><span class="line">self:build_url(<span class="string">"hello"</span>) <span class="comment">--&gt; http://localhost:8080/hello</span></span><br><span class="line"></span><br><span class="line">self:build_url(<span class="string">"world"</span>, &#123; host = <span class="string">"leafo.net"</span>, port = <span class="number">2000</span> &#125;) <span class="comment">--&gt; http://leafo.net:2000/world</span></span><br></pre></td></tr></table></figure>
<h2 id="渲染-render-的可选项"><a href="#渲染-render-的可选项" class="headerlink" title="渲染(render)的可选项"></a>渲染(<code>render</code>)的可选项</h2><p>当一个 <code>table</code> 被写入时，它们的键值对（仅是字符串类型的<code>key</code>）会被拷贝到 <code>self.options</code> 中。比如，下面的例子中的 <code>render</code> 和 <code>status</code> 属性会被拷贝。这个 <code>table</code> 仅会在 <code>action</code> 生命周期结束的时候使用，用于返回数据。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">return</span> &#123; render = <span class="string">"error"</span>, <span class="built_in">status</span> = <span class="number">404</span>&#125;</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<p>以下就是可选值清单：</p>
<ul>
<li><code>status</code> – 设置一个 <code>Http</code> 状态值 (例如：200、404、500 …)</li>
<li><code>render</code> – 视图的名称，必须是一个字符串或者是一个视图类</li>
<li><code>content_type</code> – 用于设置 <code>Content-type</code>头信息</li>
<li><code>headers</code> – 返回数据的 <code>header</code>, <code>table</code> 类型</li>
<li><code>json</code> – 返回的 <code>json</code> 字符串</li>
<li><code>layout</code> – 修改应用的默认的 <code>layout</code></li>
<li><code>redirect_to</code> – 重定向到其它的地址，支持相对路径和绝对路径</li>
</ul>
<p>当使用 <code>json</code> 渲染的时候，需要确保内容的类型，以及应用的 <code>layout</code> 属性会被禁用：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app:<span class="built_in">match</span>(<span class="string">"/hello"</span>, <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">  <span class="keyword">return</span> &#123; json = &#123; hello = <span class="string">"world"</span> &#125; &#125;</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>
<h2 id="应用回调"><a href="#应用回调" class="headerlink" title="应用回调"></a>应用回调</h2><p>应用回调是一个特殊的方法，在我们的应用中处理某些特定类型的请求的时候可以覆盖相应的方法。这些函数在我们的应用中可以正常的调用，这也意味着这些函数的第一个参数是 <code>request</code> 对象的实例。</p>
<h3 id="默认-action"><a href="#默认-action" class="headerlink" title="默认 action"></a>默认 <code>action</code></h3><p>当一个请求不能匹配给定的所有的路由规则时，它会去运行一个默认的 <code>action</code> 。<code>Lapis</code> 会预定义一个 <code>action</code> ，事例如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app:default_route</span><span class="params">()</span></span></span><br><span class="line">  <span class="comment">-- strip trailing /</span></span><br><span class="line">  <span class="keyword">if</span> self.req.parsed_url.<span class="built_in">path</span>:<span class="built_in">match</span>(<span class="string">"./$"</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> stripped = self.req.parsed_url:<span class="built_in">match</span>(<span class="string">"^(.+)/+$"</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      redirect_to = self:build_url(stripped, &#123;</span><br><span class="line">        <span class="built_in">status</span> = <span class="number">301</span>,</span><br><span class="line">        query = self.req.parsed_url.query,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    self.app.handle_404(self)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，以 <code>/</code> 为后缀的请求会被重定向到没有斜杠的位置，其他的请求会调用应用的 <code>handle_404</code> 方法。</p>
<p><code>default_route</code> 方法也是应用中的一个普通的方法。你可以根据你的实际的业务需求覆盖这个方法。比如，添加日志：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app:default_route</span><span class="params">()</span></span></span><br><span class="line">  ngx.<span class="built_in">log</span>(ngx.NOTICE, <span class="string">"User hit unknown path "</span> .. self.req.parsed_url.<span class="built_in">path</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- call the original implementaiton to preserve the functionality it provides</span></span><br><span class="line">  <span class="keyword">return</span> lapis.Application.default_route(self)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>你会注意到除了 <code>default_route</code> 还有另外一个方法 <code>handle_404</code> 也可以进行预定义操作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app:handle_404</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">error</span>(<span class="string">"Failed to find route: "</span> .. self.req.cmd_url)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会触发一个 <code>500</code> 的错误和一个无效请求的堆栈的跟踪记录。如果你想让 <code>404</code> 页面变得更友好一点，你需要按照下面的操作进行重写。</p>
<p>通过覆盖 <code>handle_404</code> 方法进行自定义 <code>404</code> 页面。</p>
<p>下面是一个简单的 <code>404</code> 页面，仅输出 <code>&quot;Not Found!&quot;</code>。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app:handle_404</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="built_in">status</span> = <span class="number">404</span>, layout = <span class="literal">false</span>, <span class="string">"Not Found!"</span> &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>每个 <code>Lapis</code> 的 <code>action</code> 的执行都会被 <a href="http://www.lua.org/manual/5.1/manual.html#pdf-xpcall" target="_blank" rel="noopener"><code>xpcall</code></a> 进行封装。这样可以确保那些致命错误可以输出一些可读性更高的信息，而不是一些 <code>Nginx</code> 的默认的错误信息。</p>
<p>错误处理主要处理那些意想不到的错误，该知识点后面还会进一步展开。</p>
<p><code>Lapis</code> 的预定义了错误处理相关的操作，比如所有的额错误信息会被渲染到 <code>&quot;lapis.views.error&quot;</code> 中。错误页面包含调用栈以及错误信息。</p>
<p>如果你想自定义错误信息，你可以覆盖 <code>handle_error</code> 方法：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- config.custom_error_page is made up for this example</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">app:handle_error</span><span class="params">(err, trace)</span></span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">config</span>.custom_error_page <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> &#123; render = <span class="string">"my_custom_error_page"</span> &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> lapis.Application.handle_error(self, err, trace)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><code>request</code> 对象或者 <code>self</code> 在系统异常的时候会传递失败。<code>Lapis</code> 提供了一个其他的方式获取 <code>request</code> 对象。</p>
<p>你可以使用 <code>self.original_request</code> 获取原始的 <code>request</code> 对象。</p>
<p>因为在错误页面里面会把全部的调用栈全部打出来，所以在线上环境建议设置自己的自定义错误页面，同时在日志记录相关的异常信息。</p>
<p><a href="https://github.com/leafo/lapis-exceptions" target="_blank" rel="noopener"><code>lapis-exception</code></a> 模块增加了错误记录数据库的功能，同时可以发送通知邮件。</p>
</div><div class="tags"><a href="/tags/lapis/">lapis</a><a href="/tags/Lua/">Lua</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/blog/2018/10/25/lapis-creating-configuration/" class="pre">lapis-配置和环境</a><a href="/blog/2018/10/23/lapis-getting-started-with-lua/" class="next">创建一个Lua版本的Lapis项目</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjk1MS8xMzQ4Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#路由"><span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#路由可选组件"><span class="toc-text">路由可选组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由参数字符类"><span class="toc-text">路由参数字符类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路由优先级"><span class="toc-text">路由优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#路由名称"><span class="toc-text">路由名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http的请求方式"><span class="toc-text">Http的请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#前置过滤器"><span class="toc-text">前置过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Request-对象"><span class="toc-text">Request 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#req"><span class="toc-text">@req</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookies"><span class="toc-text">Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session"><span class="toc-text">Session</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Request-对象的方法"><span class="toc-text">Request 对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#write-things"><span class="toc-text">write(things...)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url-for-name-or-obj-params-query-params-nil"><span class="toc-text">url_for(name_or_obj, params, query_params=nil, ...)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#url-for-的第一个参数为对象"><span class="toc-text">url_for 的第一个参数为对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-url-key-方法"><span class="toc-text">使用 url_key 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#build-for-path-options"><span class="toc-text">build_for(path, [options])</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染-render-的可选项"><span class="toc-text">渲染(render)的可选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用回调"><span class="toc-text">应用回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认-action"><span class="toc-text">默认 action</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2018/10/25/lapis-creating-configuration/">lapis-配置和环境</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/10/23/Lapis-request-and-action/">Lapis-Request和Action</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/10/23/lapis-getting-started-with-lua/">创建一个Lua版本的Lapis项目</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/10/23/lapis-getting-started/">Lapis-快速开始</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/10/10/create-openresty-docker-image/">手把手教你创建OpenResty Docker镜像</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/09/19/quick-start-Vanilla-lua-web-framework/">Vanilla （lua web framework）中文文档 [2018.09.19]</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/01/nginx-book/">Nginx</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/05/18/automatic-investment-plan-by-golang/">基于Go语言的简易基金定投系统</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/04/20/a-bite-of-golang/">A Bite of Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/03/15/taste-gdb/">GDB抓虫之旅</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/lapis/" style="font-size: 15px;">lapis</a> <a href="/tags/Go语言/" style="font-size: 15px;">Go语言</a> <a href="/tags/基金/" style="font-size: 15px;">基金</a> <a href="/tags/定投/" style="font-size: 15px;">定投</a> <a href="/tags/OpenResty/" style="font-size: 15px;">OpenResty</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/Lapis/" style="font-size: 15px;">Lapis</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/基础概念/" style="font-size: 15px;">基础概念</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/入门/" style="font-size: 15px;">入门</a> <a href="/tags/Vanilla中文文档/" style="font-size: 15px;">Vanilla中文文档</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">ShengGuocun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e3ed45ce04d57be9fec7dd674aec65e0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>