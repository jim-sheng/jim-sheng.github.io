<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录生活的每一滴"><title>Vanilla （lua web framework）中文文档 [2018.09.19] | 盛国存</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Vanilla （lua web framework）中文文档 [2018.09.19]</h1><a id="logo" href="/.">盛国存</a><p class="description">个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Vanilla （lua web framework）中文文档 [2018.09.19]</h1><div class="post-meta"><a href="/blog/2018/09/19/quick-start-Vanilla-lua-web-framework/#comments" class="comment-count"></a><p><span class="date">Sep 19, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h2><p><em>香草/Vanilla是一个基于Openresty实现的高性能Web应用开发框架.</em></p>
<p><img src="http://m1.sinaimg.cn/maxwidth.300/m1.sinaimg.cn/120d7329960e19cf073f264751e8d959_2043_2241.png" alt="Vanilla"></p>
<p><strong>邮件列表</strong></p>
<ul>
<li>vanilla-en  <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#58;&#x76;&#x61;&#110;&#105;&#x6c;&#x6c;&#97;&#45;&#x65;&#110;&#64;&#103;&#x6f;&#111;&#103;&#108;&#101;&#103;&#114;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;">&#x76;&#x61;&#110;&#105;&#x6c;&#x6c;&#97;&#45;&#x65;&#110;&#64;&#103;&#x6f;&#111;&#103;&#108;&#101;&#103;&#114;&#111;&#x75;&#x70;&#115;&#x2e;&#x63;&#x6f;&#109;</a></li>
<li>vanilla-devel  <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x76;&#97;&#x6e;&#x69;&#x6c;&#108;&#97;&#45;&#x64;&#x65;&#118;&#101;&#x6c;&#64;&#103;&#111;&#111;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#46;&#x63;&#x6f;&#109;">&#x76;&#97;&#x6e;&#x69;&#x6c;&#108;&#97;&#45;&#x64;&#x65;&#118;&#101;&#x6c;&#64;&#103;&#111;&#111;&#x67;&#108;&#101;&#x67;&#114;&#x6f;&#x75;&#x70;&#x73;&#46;&#x63;&#x6f;&#109;</a></li>
<li>vanilla中文邮件列表  <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#118;&#97;&#x6e;&#105;&#108;&#x6c;&#x61;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;">&#118;&#97;&#x6e;&#105;&#108;&#x6c;&#x61;&#64;&#x67;&#111;&#x6f;&#x67;&#108;&#x65;&#103;&#114;&#x6f;&#117;&#112;&#115;&#x2e;&#x63;&#x6f;&#x6d;</a></li>
</ul>
<p><strong>推荐始终使用最新版的Vanilla</strong></p>
<p><em>当前Vanilla最新版本0.1.0.rc6，支持命令：</em></p>
<ul>
<li>vanilla-0.1.0.rc6（<em>你没看错，自0.1.0.rc5起，vanilla的命令行和框架代码都带着版本号，方便多版本共存，也方便框架升级</em>）</li>
<li>v-console-0.1.0.rc6</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>提供很多优良组件诸如：bootstrap、 router、 controllers、 models、 views。</li>
<li>强劲的插件体系。</li>
<li>多 Application 部署。</li>
<li>多版本框架共存，支持便捷的框架升级。</li>
<li>一键 nginx 配置、 应用部署。</li>
<li>便捷的服务批量管理。</li>
<li>你只需关注自身业务逻辑。</li>
</ul>
<h3 id="0-1、安装"><a href="#0-1、安装" class="headerlink" title="0.1、安装"></a>0.1、安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./setup-framework -v <span class="variable">$VANILLA_PROJ_ROOT</span> -o <span class="variable">$OPENRESTY_ROOT</span>        <span class="comment">#运行 ./setup-framework -h 查看更多参数细节</span></span><br></pre></td></tr></table></figure>
<h3 id="0-2、快速开始"><a href="#0-2、快速开始" class="headerlink" title="0.2、快速开始"></a>0.2、快速开始</h3><p><strong>部署你的第一个Vanilla Application</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./setup-vanilal-demoapp  [-a <span class="variable">$VANILLA_APP_ROOT</span> -u <span class="variable">$VANILLA_APP_USER</span> -g <span class="variable">$VANILLA_APP_GROUP</span> -e <span class="variable">$VANILLA_RUNNING_ENV</span>]    <span class="comment">#运行 ./setup-vanilal-demoapp -h 查看更多参数细节</span></span><br></pre></td></tr></table></figure>
<p><strong>启动你的 Vanilla 服务</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./<span class="variable">$VANILLA_APP_ROOT</span>/va-appname-service start</span><br></pre></td></tr></table></figure>
<p><strong>社区组织</strong></p>
<p><strong>QQ群&amp;&amp;微信公众号</strong></p>
<ul>
<li><em>Openresty/Vanilla 开发 1 群：205773855</em></li>
<li><em>Openresty/Vanilla 开发 2 群：419191655</em></li>
<li><em>Openresty 技术交流 1 群：34782325</em></li>
<li><em>Openresty 技术交流 2 群：481213820</em></li>
<li><em>Openresty 技术交流 3 群：124613000</em></li>
<li><em>Vanilla开发微信公众号:Vanilla-OpenResty(Vanilla相关资讯、文档推送)</em></li>
</ul>
<h2 id="1、快速上手"><a href="#1、快速上手" class="headerlink" title="1、快速上手"></a>1、快速上手</h2><h3 id="1-1、Hello-World"><a href="#1-1、Hello-World" class="headerlink" title="1.1、Hello World"></a>1.1、Hello World</h3><h4 id="1-1-1、Vanilla-的安装"><a href="#1-1-1、Vanilla-的安装" class="headerlink" title="1.1.1、Vanilla 的安装"></a>1.1.1、Vanilla 的安装</h4><p><strong>安装准备</strong></p>
<ol>
<li>安装好 OpenResty</li>
<li>Vanilla Github 地址：<a href="https://github.com/idevz/vanilla" target="_blank" rel="noopener">https://github.com/idevz/vanilla</a></li>
</ol>
<p><strong>安装</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.git clone 最新 Vanilla 版本（或者下载相应的 Vanilla release 版本）</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/idevz/vanilla.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 切换到 Vanilla 文件夹</span></span><br><span class="line"><span class="built_in">cd</span> vanilla</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.编译 vanilla： ./setup-framework -v $VANILLA_PROJ_ROOT -o $OPENRESTY_ROOT 其中 $VANILLA_PROJ_ROOT 为 vanilla 框架安装目录。 -o 为 openresty 安装目录</span></span><br><span class="line"></span><br><span class="line">./setup-framework -v /application/vanilla -o /application/openresty</span><br></pre></td></tr></table></figure>
<p><em>经过这 3 步如果没有报错，则安装 vanilla 成功</em></p>
<p><strong>创建 vanilla 项目</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 创建 vanilla 的运行用户</span></span><br><span class="line"></span><br><span class="line">useradd -s /sbin/nologin -M nginx</span><br><span class="line"></span><br><span class="line">id nginx <span class="comment"># 可以查看到创建的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、创建 vanilla 项目, -a 为 项目路径，-u 为执行用户 -g 为用户组 （在根目录 /home/webserver 下创建名为 cms 的项目）</span></span><br><span class="line"></span><br><span class="line">./setup-vanilla-demoapp -a /home/webserver/cms -u nginx -g nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、删掉默认 Nginx 服务</span></span><br><span class="line"></span><br><span class="line">pkill -9 nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、切换到项目文件夹 编辑项目配置文件，改成你要的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/webserver/cms</span><br><span class="line"><span class="built_in">cd</span> nginx_conf</span><br><span class="line">vim va-nginx.conf</span><br><span class="line">vim va-nginx-development.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、同步配置文件到运行目录</span></span><br><span class="line"></span><br><span class="line">./va-cms-service initconf dev -f <span class="comment">#开发模式</span></span><br><span class="line">./va-cms-service initconf -f <span class="comment">#生产模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、启动项目（2选1）</span></span><br><span class="line"></span><br><span class="line">./va-cms-service start dev  <span class="comment"># 启动开发模式</span></span><br><span class="line">./va-cms-service start  <span class="comment"># 启动生产模式</span></span><br></pre></td></tr></table></figure>
<p><em>服务启动后，开发环境默认启动在 9110 端口，<a href="http://localhost:9110" target="_blank" rel="noopener">http://localhost:9110</a> 即可访问</em></p>
<p><strong>vanilla 常用命令</strong></p>
<ol>
<li><p>启动项目： <code>./va-cms-service start</code> 或者 <code>./va-orcms-service start dev</code></p>
</li>
<li><p>重启项目  <code>./va-cms-service restart</code> 或者 <code>./va-orcms-service restart dev</code></p>
</li>
<li><p>停止项目： <code>./va-cms-service stop</code> 或者 <code>./va-orcms-service stop dev</code></p>
</li>
<li><p>创建配置文件 <code>./va-cms-service initconf dev -f</code></p>
</li>
</ol>
<h3 id="1-2、如何调试"><a href="#1-2、如何调试" class="headerlink" title="1.2、如何调试"></a>1.2、如何调试</h3><h4 id="1-2-1、Vanilla-的-调试"><a href="#1-2-1、Vanilla-的-调试" class="headerlink" title="1.2.1、Vanilla 的 调试"></a>1.2.1、Vanilla 的 调试</h4><p><em>除了查看 nginx 错误日志辅助开发外，为了方便 Vanilla 项目的开发和调试，Vanilla 提供了诸如 <code>print_r</code> 之类的对象输出方法，以及详细友好的页面报错输出，你不需要到服务器日志去查看，就能所见即所得的开发调试代码.</em></p>
<p><strong>sprint_r，print_r，lprint_r，err_log</strong></p>
<ul>
<li><strong>sprint_r</strong></li>
</ul>
<p><em>将 LUA 对象等格式化为易读的字符串返回</em></p>
<ul>
<li><strong>print_r</strong></li>
</ul>
<p><em>类似 <code>ngx.say</code> 的效果，将对象、变量等以易读的格式进行输出，适用于 Vanilla 开发的 Web 服务</em></p>
<ul>
<li><strong>lprint_r</strong></li>
</ul>
<p><em><code>print_r</code> 的 CLI 版本，适用于 v-console 命令行环境</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">╰─○ v-console-0.1.0.rc6</span><br><span class="line">Lua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio</span><br><span class="line">v-console&gt;a=&#123;&#125;</span><br><span class="line">v-console&gt;a.v1=<span class="string">'a_v1'</span></span><br><span class="line">v-console&gt;a.v2=<span class="string">'a_v2'</span></span><br><span class="line">v-console&gt;lprint_r(a)</span><br><span class="line">&#123;</span><br><span class="line">  v2 = <span class="string">"a_v2"</span>,</span><br><span class="line">  v1 = <span class="string">"a_v1"</span></span><br><span class="line">&#125;</span><br><span class="line">v-console&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>err_log</strong></li>
</ul>
<p><em>err_log 方法是对 <code>ngx.ERR</code> 的封装，将 <code>msg</code> 记录到 nginx 错误日志</em></p>
<h3 id="1-3、如何新增一个Controller"><a href="#1-3、如何新增一个Controller" class="headerlink" title="1.3、如何新增一个Controller"></a>1.3、如何新增一个Controller</h3><h4 id="1-3-1、Vanilla-的-controller"><a href="#1-3-1、Vanilla-的-controller" class="headerlink" title="1.3.1、Vanilla 的 controller"></a>1.3.1、Vanilla 的 controller</h4><p><em>vanilla 的 controller 是业务处理的关键，vanilla 通过对 URI 的路由，找到本次请求对应的 controller 和 action。</em></p>
<ul>
<li><strong>最简单的 Controller</strong></li>
</ul>
<p><em>自动生成的 demo 中默认生成了 IndexController 和 index action（<code>function IndexController:index()</code>），默认使用简单路由协议（<code>vanilla.v.routes.simple</code>）对 URI 进行路由</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self:getView()</span><br><span class="line">    <span class="keyword">local</span> p = &#123;&#125;</span><br><span class="line">    p[<span class="string">'vanilla'</span>] = <span class="string">'Welcome To Vanilla...'</span> .. user_service:get()</span><br><span class="line">    p[<span class="string">'zhoujing'</span>] = <span class="string">'Power by Openresty'</span></span><br><span class="line">    <span class="comment">-- view:assign(p)</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> view:render(<span class="string">'index/index.html'</span>, p) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> view:display()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure>
<p><strong>以上代码解释</strong></p>
<p><em>关于上面的 controller 实例代码，我们只需关注下面几点</em></p>
<ul>
<li>IndexController:index （index Controller 中的 index Action），通过 <code>self:getView()</code> 方法获取视图实例</li>
<li>可以通过先调用 <code>view:assign(p)</code> 将所需要的参数传入视图，再调用 <code>view:display()</code> 进行模板渲染，或者可以直接调用 <code>view:render(&#39;index/index.html&#39;, p)</code> 方法，指定需要渲染的模板，并同时传入相应的参数</li>
<li>模板参数都是与 LUA 数组的形式进行传递</li>
<li>每个 action 的返回值都必须是字符串，所以可以知道 <code>view:display()</code> 和 <code>view:render()</code> 方法都是返回字符串</li>
<li>IndexController:action_b （index Controller 中的 action_b Action，这里注意，action 的方法名必须小写），使用默认的简单路由协议，访问 URI 为 <code>curl http://localhost:9110/index/action_b</code></li>
</ul>
<p><em>注：目前 vanilla 所默认使用的模板引擎是 appo 老师开发的 <a href="https://github.com/bungle/lua-resty-template" target="_blank" rel="noopener">resty-template</a>，模板详细的使用文档请移步 appo 老师处参阅。</em></p>
<h4 id="1-3-2、新添加一个-Controller"><a href="#1-3-2、新添加一个-Controller" class="headerlink" title="1.3.2、新添加一个 Controller"></a>1.3.2、新添加一个 Controller</h4><p><em>给 Vanilla 添加一个新的 Controller 非常简单，只需要在项目的 controllers 目录，实现一个 LUA 包，包导入的函数即为各个 action， 文件名与 controller 同名。例如添加一个名为 idevz 的 controller， 且实现一个名为 dohello 的 action（）。</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IdevzController = &#123;&#125;</span><br><span class="line"><span class="comment">-- curl http://localhost:9110/idevz/dohello</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IdevzController:dohello</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'do-hello-action.'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> IdevzController</span><br></pre></td></tr></table></figure>
<h3 id="1-4、如何使用Models-Dao"><a href="#1-4、如何使用Models-Dao" class="headerlink" title="1.4、如何使用Models/Dao"></a>1.4、如何使用Models/Dao</h3><h4 id="1-4-1、Vanilla-的-DAO"><a href="#1-4-1、Vanilla-的-DAO" class="headerlink" title="1.4.1、Vanilla 的 DAO"></a>1.4.1、Vanilla 的 DAO</h4><p><em>vanilla 的 DAO 预设为项目对数据源的封装，一切对数据源的操作都可以封装成 DAO，方便维护、管理、缓存等。 Vanilla 的 DAO 在项目的 models/dao 路径下，一般使用 <code>LoadModel</code> 方法进行加载</em></p>
<p><strong>最简单的 DAO</strong></p>
<p><em>由自动生成的 demo 中默认生成了 TableDao，可以看出 TableDao 只是一个普通的 LUA 包。</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> TableDao = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableDao:set</span><span class="params">(key, value)</span></span></span><br><span class="line">    self.__cache[key] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableDao:new</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> instance = &#123;</span><br><span class="line">        set = self.set,</span><br><span class="line">        __cache = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(instance, TableDao)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TableDao:__index</span><span class="params">(key)</span></span></span><br><span class="line">    <span class="keyword">local</span> out = <span class="built_in">rawget</span>(<span class="built_in">rawget</span>(self, <span class="string">'__cache'</span>), key)</span><br><span class="line">    <span class="keyword">if</span> out <span class="keyword">then</span> <span class="keyword">return</span> out <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> TableDao</span><br></pre></td></tr></table></figure>
<p><strong>以上代码解释</strong></p>
<p><em>DAO 可以是任何对数据层访问封装的 LUA 包，实现方式非常自由。</em></p>
<h3 id="1-5、如何使用Models-Service"><a href="#1-5、如何使用Models-Service" class="headerlink" title="1.5、如何使用Models/Service"></a>1.5、如何使用Models/Service</h3><h4 id="1-5-1、Vanilla-的-Service"><a href="#1-5-1、Vanilla-的-Service" class="headerlink" title="1.5.1、Vanilla 的 Service"></a>1.5.1、Vanilla 的 Service</h4><p><em>vanilla 的 Service 预设为项目对某些通用业务逻辑封装为独立的 Service，方便维护、管理、缓存等。 Vanilla 的 Service 在项目的 models/service 路径下，一般使用 <code>LoadModel</code> 方法进行加载</em></p>
<p><strong>最简单的 Service</strong></p>
<p><em>由自动生成的 demo 中默认生成了 UserService，可以看出 UserService 也只是一个普通的 LUA 包。不过 Service 一般调用更底层的 DAO ，并对之做必要封装，并将相关的 Service 暴露给 Controller 使用</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> table_dao = LoadApplication(<span class="string">'models.dao.table'</span>):new()</span><br><span class="line"><span class="keyword">local</span> UserService = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserService:get</span><span class="params">()</span></span></span><br><span class="line">    table_dao:set(<span class="string">'zhou'</span>, <span class="string">'UserService res'</span>)</span><br><span class="line">    <span class="keyword">return</span> table_dao.zhou</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> UserService</span><br></pre></td></tr></table></figure>
<p><strong>以上代码解释</strong></p>
<p><em>Service 可以是任何对数据层访问封装的 LUA 包</em></p>
<h2 id="2、APIs"><a href="#2、APIs" class="headerlink" title="2、APIs"></a>2、APIs</h2><h3 id="2-1、配置"><a href="#2-1、配置" class="headerlink" title="2.1、配置"></a>2.1、配置</h3><p><em>香草/Vanilla的配置由以下三个部分组成.</em></p>
<ul>
<li><em>App配置</em></li>
<li><em>Nginx配置</em></li>
<li><em>WAF配置</em></li>
</ul>
<h4 id="2-1-1、App配置"><a href="#2-1-1、App配置" class="headerlink" title="2.1.1、App配置"></a>2.1.1、App配置</h4><p><strong>应用基础配置（config/application.lua）</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Appconf.sysconf = &#123;				<span class="comment">--系统预加载配置文件</span></span><br><span class="line">    <span class="string">'v_resource'</span>,</span><br><span class="line">&#125;</span><br><span class="line">Appconf.name = <span class="string">'app_name'</span>		<span class="comment">--app名称，执行vanilla new命令时给定的应用名</span></span><br><span class="line"></span><br><span class="line">Appconf.route=<span class="string">'vanilla.v.routes.simple'</span>		<span class="comment">--路由器，指定URL路由方式，目的解析出需要执行的controller与action</span></span><br><span class="line">Appconf.bootstrap=<span class="string">'application.bootstrap'</span>		<span class="comment">--初始化bootstrap（用来对应用进行初始化操作）</span></span><br><span class="line">Appconf.app=&#123;&#125;		<span class="comment">--app相关配置</span></span><br><span class="line">Appconf.app.root=<span class="string">'./'</span>		<span class="comment">--当前vanilla start命令执行路径</span></span><br><span class="line"></span><br><span class="line">Appconf.controller=&#123;&#125;		<span class="comment">--当前app的controller相关配置</span></span><br><span class="line">Appconf.controller.<span class="built_in">path</span>=Appconf.app.root .. <span class="string">'application/controllers/'</span>		<span class="comment">--controller文件所在路径（使用默认生成路径即可）</span></span><br><span class="line"></span><br><span class="line">Appconf.view=&#123;&#125;		<span class="comment">--当前app的视图层相关配置</span></span><br><span class="line">Appconf.view.<span class="built_in">path</span>=Appconf.app.root .. <span class="string">'application/views/'</span>		<span class="comment">--模板路径</span></span><br><span class="line">Appconf.view.suffix=<span class="string">'.html'</span>		<span class="comment">--模板后缀</span></span><br><span class="line">Appconf.view.auto_render=<span class="literal">true</span>		<span class="comment">--是否开启自动渲染</span></span><br></pre></td></tr></table></figure>
<p><strong>应用基础配置的引用</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如上的配置，可以在代码中通过 Registry['APP_CONF'] 表来进行获取，比如获取 APP_NAME</span></span><br><span class="line"><span class="keyword">local</span> app_name = Registry[<span class="string">'APP_CONF'</span>][<span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>
<p><strong>错误处理配置（config/errors.lua）</strong></p>
<p><em>根据errors.lua文件中实例，配置用户级别错误码.</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Errors = &#123;</span><br><span class="line">    [<span class="number">1000</span>] = &#123; <span class="built_in">status</span> = <span class="number">500</span>, message = <span class="string">"Controller Err."</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Restful 路由协议配置（config/restful.lua）</strong></p>
<p><em>根据 URI 需要来自定义路由协议的配置</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> restful = &#123;</span><br><span class="line">    v1=&#123;&#125;,</span><br><span class="line">    v=&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restful.v.GET = &#123;</span><br><span class="line">    &#123;pattern = <span class="string">'/'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'index'</span>&#125;,</span><br><span class="line">    &#123;pattern = <span class="string">'/:category'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'list'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restful.v.POST = &#123;</span><br><span class="line">    &#123;pattern = <span class="string">'/post'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'post'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restful.v1.GET = &#123;</span><br><span class="line">    &#123;pattern = <span class="string">'/api'</span>, controller = <span class="string">'index'</span>, action = <span class="string">'api_get'</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> restful</span><br></pre></td></tr></table></figure>
<p><strong>系统相关配置（sys/*）</strong></p>
<p><em>比如DB、MC等资源配置，系统相关的分机房配置等（在某些大公司，这部分配置又运维人员统一管理和下发），文件格式目前使用相对更运维友好的 ini 文件，开发中可以方便的在 Registry[‘sys_conf’] 中获取相关数据，如 <code>Registry[&#39;sys_conf&#39;][&#39;cache&#39;][&#39;lrucache&#39;]</code> 获取 lrucache 相关配置</em></p>
<p><strong>系统缓存相关配置 （sys/cache）</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[shared_dict]</span></span><br><span class="line"><span class="attr">dict</span>=idevz</span><br><span class="line"><span class="attr">exptime</span>=<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="section">[memcached]</span></span><br><span class="line"><span class="attr">instances</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">11211</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">11211</span></span><br><span class="line"><span class="attr">exptime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">poolsize</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">idletimeout</span>=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[redis]</span></span><br><span class="line"><span class="attr">instances</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span></span><br><span class="line"><span class="attr">exptime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">poolsize</span>=<span class="number">100</span></span><br><span class="line"><span class="attr">idletimeout</span>=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lrucache]</span></span><br><span class="line"><span class="attr">items</span>=<span class="number">200</span></span><br><span class="line"><span class="attr">exptime</span>=<span class="number">60</span></span><br><span class="line"><span class="attr">useffi</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>目前这部分配置一般由 vanilla.v.libs.cache 来使用</li>
<li>目前支持的配置项如 poolsize（连接池大小）、timeout（数据获取超时等）</li>
</ul>
<p><strong>系统缓存相关配置 （sys/v_resource）</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mc]</span></span><br><span class="line"><span class="attr">conf</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7348</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">11211</span></span><br><span class="line"></span><br><span class="line"><span class="section">[redis]</span></span><br><span class="line"><span class="attr">conf</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7348</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7349</span></span><br><span class="line"></span><br><span class="line"><span class="section">[redisq]</span></span><br><span class="line"><span class="attr">conf</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7348</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">7349</span></span><br><span class="line"></span><br><span class="line"><span class="section">[db.user.write]</span></span><br><span class="line"><span class="attr">host</span> =<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br><span class="line"><span class="attr">dbname</span> =user.info</span><br><span class="line"><span class="attr">user</span> =idevz</span><br><span class="line"><span class="attr">passwd</span> =idevz</span><br><span class="line"></span><br><span class="line"><span class="section">[db.user.read]</span></span><br><span class="line"><span class="attr">host</span> =<span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> =<span class="number">3306</span></span><br><span class="line"><span class="attr">dbname</span> =user.info</span><br><span class="line"><span class="attr">user</span> =idevz</span><br><span class="line"><span class="attr">passwd</span> =idevz</span><br></pre></td></tr></table></figure>
<ul>
<li>对所使用的数据资源做配置</li>
<li><code>Registry[&#39;sys_conf&#39;][&#39;v_resource）&#39;][&#39;db.user.write&#39;][&#39;host&#39;]</code> 获取写库的 HOST 信息</li>
</ul>
<h4 id="2-1-2、Nginx配置"><a href="#2-1-2、Nginx配置" class="headerlink" title="2.1.2、Nginx配置"></a>2.1.2、Nginx配置</h4><p><strong>自动生成的 Nginx 配置文件</strong></p>
<p><em>初始化项目的时候会在项目目录下（nginx_conf/）自动生成这个项目所对应的两套（分别对应开发和线上环境）配置文件，生成的两套配置文件中，每套都包含 nginx.conf 和 vhost 两个配置文件</em></p>
<ul>
<li><strong>生产环境</strong></li>
</ul>
<p><strong>va-nginx.conf 文件</strong></p>
<p><em>va-nginx.conf 配置文件内容包含 nginx 配置主干（main、events、http 等重点配置段），包括用户、组的配置，工作进程等等通用配置，关键的还有 <code>lua_package_path</code>、<code>lua_package_cpath</code> 的配置，还有框架初始化文件（vanilla/framework/init.lua）的加载</em></p>
<p><strong>vhost/app_name.conf 文件</strong></p>
<p><em>vhost/app_name.conf 文件是当前应用的相关配置，包括 APP_NAME、VANILLA_VERSION、$template_root、$va_cache_status 等全局变量的初始化，$document_root，Server_name 等的设置，还有关键的应用入口（content_by_lua_file），lua_shared_dict 等的设置，不过这些设置都是自动生成的，开发人员没有特殊需求的话，并不需要关注这些</em></p>
<ul>
<li><strong>开发环境</strong></li>
</ul>
<p><strong>va-nginx-development.conf 文件</strong></p>
<p><em>va-nginx-development.conf 文件的内容跟开发环境类似，唯一的区别在于加载框架初始化文件（vanilla/framework/init.lua）的方式为 <code>init_by_lua_file</code></em></p>
<p><strong>dev_vhost/app_name.conf 文件</strong></p>
<p><em>默认的dev_vhost/app_name.conf 文件的配置同生产环境的配置基本一样，关键不同在于 <code>lua_code_cache</code> 的设置</em></p>
<p><em>注：所以初始化项目后，首先需要执行 <code>sudo ./va-app_name-service initconf dev</code> 命令，就是为了将自动生成的配置文件部署到 OpenResty 默认的配置文件路径下，如果需要更新 va-nginx（-development）.conf 则还需要在命令后面加上 <code>-f</code> 参数进行强行部署，每次如果需要修改配置，也只需修改这部分配置，然后执行 <code>initconf</code> 即可</em></p>
<p><em><strong>nginx.lua( vanilla-0.1.0.rc5 后废弃此配置 )</strong></em></p>
<p><em>分为ngx_conf.common和ngx_conf.env两个部分，common是对Openresty指令集的配置如INIT_BY_LUA，可以是包或者文件(BY_LUA_FILE)，env是环境的部分，包括了开发环境，测试环境和生产环境端口和缓存配置等控制.</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ngx_conf.common = &#123;</span><br><span class="line">    INIT_BY_LUA = <span class="string">'nginx.init'</span>,</span><br><span class="line">    CONTENT_BY_LUA_FILE = <span class="string">'./pub/index.lua'</span></span><br><span class="line">&#125;</span><br><span class="line">ngx_conf.env = &#123;&#125;</span><br><span class="line">ngx_conf.env.development = &#123;</span><br><span class="line">    LUA_CODE_CACHE = <span class="literal">false</span>,</span><br><span class="line">    PORT = <span class="number">7200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3、WAF配置"><a href="#2-1-3、WAF配置" class="headerlink" title="2.1.3、WAF配置"></a>2.1.3、WAF配置</h4><p><strong>waf.lua</strong></p>
<p><em>包括WAF规则的配置，及各种规则参数的配置，相关使用方法详见 <a href="https://github.com/loveshell/ngx_lua_waf" target="_blank" rel="noopener">waf</a></em></p>
<h3 id="2-2、Bootstrap"><a href="#2-2、Bootstrap" class="headerlink" title="2.2、Bootstrap"></a>2.2、Bootstrap</h3><h4 id="2-2-1、使用-Bootstrap-来做服务初始化"><a href="#2-2-1、使用-Bootstrap-来做服务初始化" class="headerlink" title="2.2.1、使用 Bootstrap 来做服务初始化"></a>2.2.1、使用 Bootstrap 来做服务初始化</h4><p><em>Vanilla 使用 Bootstrap 来做应用初始化的工作，用户可以在此对应用做一些配置（比如所使用的路由协议，使用何种视图引擎），对配置做一些初始化加载，初始化 WAF，初始化 Plugins 等操作，Vanilla 运行在 OpenResty content_by_lua\</em>这个 Phrase，使用 Bootstrap 可以很好的实现对请求的细粒度控制*</p>
<p><strong>Bootstrap 即类 <code>application.bootstrap</code></strong></p>
<p><em>Bootstrap 的实现其实是一个名为 <code>application.bootstrap</code> 的 Vanilla 类，实现了构造器初始化的属性只有一个（当前请求所使用的 dispatcher），我们只需要关注根据需求实现各种 init 方法即可，最后只要在 <code>boot_list</code> 方法返回的列表中的 init 方法都会被顺序执行</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:boot_list</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">-- Bootstrap.initWaf,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initErrorHandle,</span></span><br><span class="line">        Bootstrap.initRoute,</span><br><span class="line">        <span class="comment">-- Bootstrap.initView,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initPlugin,</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:__construct</span><span class="params">(dispatcher)</span></span></span><br><span class="line">    self.dispatcher = dispatcher</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>上面的定义代表只有 <code>initRoute</code> 方法会被执行，而上面两个方法的实现我们并不需要关心和更改，只需要定义各种 init 方法，并更新 <code>boot_list</code> 返回的表元素即可，比如下面初始化路由协议的 <code>initRoute</code></em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initRoute</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> router = self.dispatcher:getRouter()</span><br><span class="line">    <span class="keyword">local</span> restful_route = restful:new(self.dispatcher:getRequest())</span><br><span class="line">    router:addRoute(restful_route, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>注：可以通过 self.dispatcher 获取当前请求相关的详细信息，并进行相关控制</em></p>
<h3 id="2-3、Controllers"><a href="#2-3、Controllers" class="headerlink" title="2.3、Controllers"></a>2.3、Controllers</h3><h4 id="2-3-1、Vanilla-的-controller"><a href="#2-3-1、Vanilla-的-controller" class="headerlink" title="2.3.1、Vanilla 的 controller"></a>2.3.1、Vanilla 的 controller</h4><p><em>vanilla 的 controller 是业务处理的关键，基本的用法请参考上文 (如何新增一个Controller) 。</em></p>
<p><strong>关于 Controller</strong></p>
<p><em>Vanilla 的 Controller 可以是任何普通的 LUA 包，只不过导入的方法被用作处理请求的 Action。如下示例：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self:getView()</span><br><span class="line">    <span class="keyword">local</span> p = &#123;&#125;</span><br><span class="line">    p[<span class="string">'vanilla'</span>] = <span class="string">'Welcome To Vanilla...'</span> .. user_service:get()</span><br><span class="line">    p[<span class="string">'zhoujing'</span>] = <span class="string">'Power by Openresty'</span></span><br><span class="line">    <span class="comment">-- view:assign(p)</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> view:render(<span class="string">'index/index.html'</span>, p) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> view:display()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure>
<p><strong>更面向对象的 Controller</strong></p>
<p><em>Vanilla 支持使用 <code>Class</code> 方法来声明一个 Controller，实例如下：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = Class(<span class="string">'controllers.index'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure>
<p><em>这种情况下，可以定义 Controller 的构造器来对其进行初始化。示例如下：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = Class(<span class="string">'controllers.index'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:__construct</span><span class="params">()</span></span></span><br><span class="line">    self.aa = aa(&#123;info=<span class="string">'ppppp'</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- curl http://localhost:9110/index/action_b</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:action_b</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index-&gt;action_b'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure>
<p><em>甚至还可以声明一个 Controller 基类，处理某些通用的逻辑，相关的详细用法参见 Vanilla<a href="../advanced/oo.md">面向对象</a> 相关章节。</em></p>
<p><strong>关于 Action 的返回值</strong></p>
<p><em>Vanilla 底层会将 Action 执行的结果，完全使用 <code>ngx.print</code> 进行输出，所以 Action 的返回值必须不能为空。而由于 Vanilla 的 Response 中，提供了给响应添加头尾的 <code>Response:appendBody</code> 和 <code>Response:prependBody</code> 方法，最终的结果会将这些部分合起来一起返回，所以 Action 的返回值要求如下：</em></p>
<ul>
<li>Action 返回值必须非空</li>
<li>Action 返回值可以为一维索引数组（不可以是多维 Hash 数组）或者字符串</li>
</ul>
<h3 id="2-4、模板引擎"><a href="#2-4、模板引擎" class="headerlink" title="2.4、模板引擎"></a>2.4、模板引擎</h3><h4 id="2-4-1、Vanilla-的视图引擎"><a href="#2-4-1、Vanilla-的视图引擎" class="headerlink" title="2.4.1、Vanilla 的视图引擎"></a>2.4.1、Vanilla 的视图引擎</h4><p><em>为去除模板运行时模板解析带来的不必要开销，从 vanilla-0.1.0.rc7 起 Vanilla 开始支持 OpenResty 官方的 Lemplate 模板引擎，下面将简要介绍 Vanilla 中 Lemplate 的用法，以及 Vanilla View 接口介绍</em></p>
<p><strong>Vanilla 的视图渲染</strong></p>
<p><em>Vanilla 在 <code>vanilla.v.dispatcher</code> 中导入了默认的模板引擎（<code>local View = LoadV &#39;vanilla.v.views.rtpl&#39;</code>），但是可以在 Bootstrap 中实现 <code>initView</code> 来修改所使用的视图引擎。</em><br><em>而 Vanilla 的模板渲染，只需要在相应的 Action 中获取当前视图实例，注入数据，展示即可。下面就以 Lemplate 模板引擎为例，展示相关用法</em></p>
<p><strong>首先在 Bootstrap 中实现 <code>initView</code> 方法，修改项目所使用的视图引擎</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- application/bootstrap.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initView</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = LoadV(<span class="string">'vanilla.v.views.lemplate'</span>):new(self.dispatcher.application.<span class="built_in">config</span>.view)</span><br><span class="line">    self.dispatcher:setView(view)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- boot_list 中打开 Bootstrap.initView 方法调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:boot_list</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">-- Bootstrap.initWaf,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initErrorHandle,</span></span><br><span class="line">        <span class="comment">-- Bootstrap.initRoute,</span></span><br><span class="line">        Bootstrap.initView,</span><br><span class="line">        <span class="comment">-- Bootstrap.initPlugin,</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><strong>运行 <code>./va-{app_name}-service ltpl</code> 命令调用 <code>Lemplate</code> 编译你的 TT2 模板</strong></p>
<p><em>下面是 TT2 模板示意</em></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>[% title %]<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">[% FOREACH userinfo IN userlists %]</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h6</span>&gt;</span>姓名：[% userinfo.name %] / 地址：[% userinfo.addr %]<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">[% END %]</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>在 Vanilla Action 中调用编译好的模板</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> view = self:getView()</span><br><span class="line">    <span class="keyword">local</span> users = &#123;</span><br><span class="line">                        &#123;name=<span class="string">'idevz'</span>, addr=<span class="string">'yunnan'</span>&#125;,</span><br><span class="line">                        &#123;name=<span class="string">'vanilla'</span>, addr=<span class="string">'beijing'</span>&#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">    <span class="keyword">return</span> view:assign(&#123;userlists=users, title = <span class="string">'Vanilla-Lemplate'</span>&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>注：</em></p>
<ul>
<li><code>local view = self:getView()</code> 获取当前视图实例</li>
<li><code>view:assign({userlists=users, title = &#39;Vanilla-Lemplate&#39;})</code> 将数据注入视图</li>
</ul>
<p><em>注：以上为 Lemplate 所使用的 TT2 模板实例，关于 Lemplate 的详细使用，可参考其详细 <a href="https://github.com/openresty/lemplate" target="_blank" rel="noopener">文档</a></em></p>
<h3 id="2-5、插件"><a href="#2-5、插件" class="headerlink" title="2.5、插件"></a>2.5、插件</h3><h4 id="2-5-1、Vanilla-的插件体系"><a href="#2-5-1、Vanilla-的插件体系" class="headerlink" title="2.5.1、Vanilla 的插件体系"></a>2.5.1、Vanilla 的插件体系</h4><p><em>为了减少运行占用的系统资源，使开发更简便，Vanilla 默认只运行在 content_by_lua 这个 phrase，但是为了支持业务开发有层次化的请求控制，Vanilla 实现了便捷的插件机制，提供了六个钩子，给请求的细粒度控制提供了可能。下面我们来看看如何使用</em></p>
<p><strong>Vanilla Plugin 的简单使用</strong></p>
<p><em>在 Vanilla 项目中使用插件是非常简单的，只需要在 application/plugins/ 路径下实现 Vanilla 的插件 LUA 包即可，插件包可以按需实现 6 个钩子的方法。默认生成的 demo 项目中自动生成了一个 admin plugin，见 application/plugins/admin.lua。六个钩子方法按需实现，空方法可去掉，如下所示：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> AdminPlugin = LoadV(<span class="string">'vanilla.v.plugin'</span>):new()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AdminPlugin:routerStartup</span><span class="params">(request, response)</span></span></span><br><span class="line">    print_r(<span class="string">'&lt;pre&gt;'</span>)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span> <span class="keyword">then</span></span><br><span class="line">        print_r(<span class="string">'-----------'</span> .. sprint_r(request.headers) .. <span class="string">'----------'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        print_r(request.headers)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> AdminPlugin</span><br></pre></td></tr></table></figure>
<p><strong>Vanilla Plugin 的调用</strong></p>
<p><em>Vanilla Plugins 的调用非常简单，只需要在 application/bootstrap.lua 中实现 <code>initPlugin</code> 方法，并调用 <code>dispatcher</code> 的插件注册方法将插件注入项目（ <code>self.dispatcher:registerPlugin(admin_plugin)</code>），即能在对应的时机执行相关钩子对应的方法</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Bootstrap = Class(<span class="string">'application.bootstrap'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initPlugin</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> admin_plugin = LoadPlugin(<span class="string">'plugins.admin'</span>):new()</span><br><span class="line">    self.dispatcher:registerPlugin(admin_plugin);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:boot_list</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        Bootstrap.initPlugin,</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:__construct</span><span class="params">(dispatcher)</span></span></span><br><span class="line">    self.dispatcher = dispatcher</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Bootstrap</span><br></pre></td></tr></table></figure>
<p><strong>Vanilla 支持的插件钩子</strong></p>
<p><em>以下列出 Vanilla 支持的 6 中插件钩子</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:routerStartup</span><span class="params">(request, response)</span></span>			<span class="comment">-- 开始路由</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:routerShutdown</span><span class="params">(request, response)</span></span>			<span class="comment">-- 路由结束</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:dispatchLoopStartup</span><span class="params">(request, response)</span></span>		<span class="comment">-- 开始请求分发</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:preDispatch</span><span class="params">(request, response)</span></span>				<span class="comment">-- 预分发（载入相关的 controller）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:postDispatch</span><span class="params">(request, response)</span></span>				<span class="comment">-- 请求响应</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin:dispatchLoopShutdown</span><span class="params">(request, response)</span></span>		<span class="comment">-- 请求分发执行结束</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6、路由"><a href="#2-6、路由" class="headerlink" title="2.6、路由"></a>2.6、路由</h3><h4 id="2-6-1、Vanilla-的路由体系"><a href="#2-6-1、Vanilla-的路由体系" class="headerlink" title="2.6.1、Vanilla 的路由体系"></a>2.6.1、Vanilla 的路由体系</h4><p><em>Vanilla 实现的路由体系有一个路由器（<code>vanilla.v.router</code>）和若干路由协议构成（Vanilla 默认实现了 <code>vanilla.v.routes.simple</code> 和 <code>vanilla.v.routes.restful</code> 两种路由协议，默认使用 <code>simple</code> 路由来路由请求），请求处理的开始阶段，Vanilla 通过调用路由器协议栈中的各种路由协议，计算出处理当前请求的 <code>controller</code> 和 <code>action</code>，这就是 Vanilla 路由体系的职责所在。如果默认的两种路由协议不能满足你的 URI 路由需求，你可以参考我的一篇<a href="https://my.oschina.net/idevz/blog/603657" target="_blank" rel="noopener">《如何给Vanilla(OpenResty)添加一个路由协议》</a>的博文</em></p>
<blockquote>
<p><strong>Vanilla 路由器</strong></p>
</blockquote>
<p><em>Vanilla 的路由器 <code>vanilla.v.router</code> 是请求路由的基础，路由器提供了对路由协议的添加 <code>addRoute(route, only_one)</code>，删除 <code>removeRoute(route_name)</code>，获取路由列表 <code>getRoutes()</code> 等方法，用户可以调用这些方法来管理路由协议栈并使用路由器，不过用户不需要关心路由器的实现，而只需要关注路由协议的实现。</em></p>
<p><strong>给路由器添加一条路由协议</strong></p>
<p><em>路由器只有唯一一个 <code>vanilla.v.router</code>，但路由协议可以有多个，通过 <code>addRoute(route, only_one)</code> 方法的调用可以向路由协议栈添加一条路由协议，第二个参数为可选参数，当设置为 <code>true</code> 时，代表将清空路由协议栈，只使用当前添加的这条路由协议，因为 Vanilla 路由请求的方式是路由器根据路由协议栈中的路由协议挨条解析，直到找到匹配的 <code>controller</code> 和 <code>action</code> 为止，太多的路由协议栈可能影响路由性能。</em></p>
<p><strong>删除一条路由协议</strong></p>
<p><em>Vanilla 的每条路由协议都有 <code>route_name</code> 属性，删除时只需要调用 <code>removeRoute(route_name)</code></em></p>
<p><strong>获取当前所使用的路由协议</strong></p>
<p><em>Vanilla 支持获取当前请求所使用的路由协议，只需调用 <code>getCurrentRoute()</code> 方法，调用 <code>getCurrentRouteName()</code> 方法可以获取当前路由协议名</em></p>
<blockquote>
<p><strong>路由协议</strong></p>
</blockquote>
<p><em>路由协议非常的简单，因为路由协议的关键功能在于为当前请求找到对应的 <code>controller</code> 和 <code>action</code>，核心在于根据当前请求实例 <code>request</code>，通过实现 <code>match</code> 方法，来获取结果，下面是根据 <code>vanilla.v.routes.simple</code> 路由协议提炼出来的路由协议简单骨架：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Simple = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Simple:new</span><span class="params">(request)</span></span></span><br><span class="line">    <span class="keyword">local</span> instance = &#123;</span><br><span class="line">        route_name = <span class="string">'vanilla.v.routes.simple'</span>,</span><br><span class="line">    	request = request</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setmetatable</span>(instance, &#123;</span><br><span class="line">        <span class="built_in">__index</span> = self,</span><br><span class="line">        <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span> <span class="keyword">return</span> self.route_name <span class="keyword">end</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Simple:match</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Simple</span><br></pre></td></tr></table></figure>
<p><em>注：我们需要关注以下两点</em></p>
<ul>
<li><code>route_name</code> 这是路由协议栈索引的关键，协议栈中的路由协议依靠 route_name 进行管理</li>
<li><code>request</code> 是当前请求的实例，包含了当前请求携带的 URI，http_header 等数据，是请求路由的依据</li>
</ul>
<h3 id="2-7、异常处理"><a href="#2-7、异常处理" class="headerlink" title="2.7、异常处理"></a>2.7、异常处理</h3><h4 id="2-7-1、Vanilla-的错误处理"><a href="#2-7-1、Vanilla-的错误处理" class="headerlink" title="2.7.1、Vanilla 的错误处理"></a>2.7.1、Vanilla 的错误处理</h4><p><em>Vanilla 的错误处理分为框架系统错误和应用错误两种类型，系统错误由框架控制，一般导致致命错误，直接抛出 500 内部错误，切不再往下执行，而应用错误则可以通过定义 <code>errorController</code> 来自定义处理</em></p>
<p><strong>Vanilla 应用错误</strong></p>
<p><em>Vanilla 提供了方便的错误处理方式，避免当代码运行报错后，页面只显示一个 500 错误的白页，没有详细报错信息，影响开发效率，Vanilla 的应用错误处理非常简单，在业务开发中，我们所关注的各个组件比如 DAO、Service、Controller、Action、Library 等都可能报错，Controller Action 作为 Vanilla 项目处理请求的执行体，一切业务组件的错误都可以通过一个统一的处理口径 <code>errorController</code> 来方便的处理。在业务组件开发过程中的错误，或者用户自定义的错误，都可以在 <code>errorController</code> 中得到捕获和处理，默认初始化的 demo 项目中，application/controllers/ 路径下，默认定义了一个 error.lua 文件，这就是前面所说的 <code>errorController</code>，下面我们具体来看看这段代码：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> ErrorController = &#123;&#125;</span><br><span class="line"><span class="keyword">local</span> ngx_log = ngx.<span class="built_in">log</span></span><br><span class="line"><span class="keyword">local</span> ngx_redirect = ngx.redirect</span><br><span class="line"><span class="keyword">local</span> os_getenv = <span class="built_in">os</span>.<span class="built_in">getenv</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ErrorController:error</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> env = os_getenv(<span class="string">'VA_ENV'</span>) <span class="keyword">or</span> <span class="string">'development'</span></span><br><span class="line">    <span class="keyword">if</span> env == <span class="string">'development'</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> view = self:getView()</span><br><span class="line">        view:assign(self.err)</span><br><span class="line">        <span class="keyword">return</span> view:display()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">local</span> helpers = <span class="built_in">require</span> <span class="string">'vanilla.v.libs.utils'</span></span><br><span class="line">        ngx_log(ngx.ERR, helpers.sprint_r(self.err))</span><br><span class="line">        <span class="comment">-- return ngx_redirect("http://sina.cn?vt=4", ngx.HTTP_MOVED_TEMPORARILY)</span></span><br><span class="line">        <span class="keyword">return</span> helpers.sprint_r(self.err)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> ErrorController</span><br></pre></td></tr></table></figure>
<p><em>代码释意：（你只需要关注以下几点，即可随意，按需定义适合你的 errorController）</em></p>
<ul>
<li>这是一个普通的 LUA 包，一个普通的 Vanilla Controller，唯一需要注意的一点就是需要实现一个 <code>error</code> 方法，注意方法名小写</li>
<li>可以通过对运行环境的判断来，对不同的运行环境进行不同的错误处理，比如开发环境可能需要直接将错误打印到页面，而生产环境可能需要出错误页面等</li>
</ul>
<p><strong>Vanilla 框架系统错误（致命错误）</strong></p>
<p><em>当有些 Vanilla 项目所必须的配置或者关键步骤执行异常而影响项目往下运行的情况下，会抛出致命错误，并结束当前请求，目前有以下几种情况</em></p>
<ul>
<li><strong>关键配置缺少</strong></li>
</ul>
<p><em>项目未配置项目名 <code>name</code>，或者未指定项目根路径 <code>root</code>，Vanilla 有很多地方依赖项目名，比如缓存的 KEY 设置，项目的各类包加载依赖于项目根路径做全局加载，多 APP 支持也依赖与此。如果 config/application.lua 中缺少这两个配置，则会如下错误：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sys Err: Please <span class="built_in">set</span> app name and app root <span class="keyword">in</span> config/application.lua like:</span><br><span class="line"></span><br><span class="line">    Appconf.name = <span class="string">'idevz.org'</span></span><br><span class="line">    Appconf.app.root=<span class="string">'/data1/VANILLA_ROOT/idevz.org/'</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>bootstrap 报错</strong></li>
</ul>
<p><em>Bootstrap 中的各种 init 方法并不是必须的，但是如果这部分方法定义后，执行错误，将影响整体项目的正常运行，所以 application/bootstrap.lua 中的运行报错也会报出系统致命错误，举例如下：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bootstrap:initRoute</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> router = self.dispatcher:getRouter()</span><br><span class="line">    <span class="keyword">local</span> restful_route = restful:new(self.dispatcher:getRequest())</span><br><span class="line">    router:addRoute(restful_route, <span class="literal">true</span>)</span><br><span class="line">    print_r(<span class="string">'xx'</span> .. <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><em>注：以上代码，最后一行操作试图将字符串与 bool 值 false 连接，会报出致命错误，如下：</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre /&gt;</span><br><span class="line"><span class="string">"...g/idevz/code/www/vanilla/orcon/application/bootstrap.lua:18: attempt to concatenate a boolean value"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>dispatch 执行报错</strong></li>
</ul>
<p><em>dispatch 属于框架的请求分发操作，请求分发执行出错直接导致致命错误，不过这个错误由框架自己处理，用户不需要关注</em></p>
<h3 id="2-8、内建类"><a href="#2-8、内建类" class="headerlink" title="2.8、内建类"></a>2.8、内建类</h3><h4 id="2-8-1、Vanilla-的內建变量和方法"><a href="#2-8-1、Vanilla-的內建变量和方法" class="headerlink" title="2.8.1、Vanilla 的內建变量和方法"></a>2.8.1、Vanilla 的內建变量和方法</h4><p><em>为方便业务开发，Vanilla 提供了一些比较实用的內建方法和变量，这里我们说明如下，随着框架的更新，本页面会及时更新，欢迎随时关注。</em></p>
<p><strong>Vanilla 的內建变量</strong></p>
<p><em>Vanilla 的內建变量很多来自于 nginx.conf，其他则来自于 <code>ngx.var</code>，Vanilla 将这些变量都缓存在了 Registry 中</em></p>
<ul>
<li><strong>Registry 变量</strong></li>
</ul>
<p><em>Registry 是 Vanilla 中为了全局数据共享，及高效数据访问而封装的一个全局表，这里缓存了刻画当前请求比较全的数据，具体列表说明如下：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以下数据以 "curl http://domain.org/?arg1=aa1&amp;arg2=aa2" 访问为例进行说明</span></span><br><span class="line">Registry[<span class="string">'APP_CONF'</span>]	<span class="comment">-- 当前应用的配置数据，来自于（config/application.lua）</span></span><br><span class="line">Registry[<span class="string">'sys_conf'</span>]	<span class="comment">-- 当前应用的系统配置，来自于（sys/*路径，比如可以使用 Registry['sys_conf']['cache'] 获取 sys/cache 文件中关于 cache 的配置）</span></span><br><span class="line">Registry[<span class="string">'REQ_URI'</span>]		<span class="comment">-- 当前请求的 URI ，为 "/"</span></span><br><span class="line">Registry[<span class="string">'REQ_ARGS'</span>]	<span class="comment">-- 当前请求的参数字符串，即 Query_String，为 "arg1=aa1&amp;arg2=aa2"</span></span><br><span class="line">Registry[<span class="string">'REQ_ARGS_ARR'</span>]	<span class="comment">-- 当前请求的参数列表，为一个 LUA 数组</span></span><br><span class="line">Registry[<span class="string">'REQ_HEADERS'</span>]		<span class="comment">-- 当前请求的请求头数组</span></span><br><span class="line">Registry[<span class="string">'APP_NAME'</span>] 		<span class="comment">-- 应用名称</span></span><br><span class="line">Registry[<span class="string">'APP_ROOT'</span>] 		<span class="comment">-- 应用所在根目录</span></span><br><span class="line">Registry[<span class="string">'APP_HOST'</span>] 		<span class="comment">-- 当前请求的 HOST 信息</span></span><br><span class="line">Registry[<span class="string">'APP_PORT'</span>] 		<span class="comment">-- 当前请求的 PORT 信息</span></span><br><span class="line">Registry[<span class="string">'VANILLA_ROOT'</span>] 	<span class="comment">-- VANIALLA 框架的根目录</span></span><br><span class="line">Registry[<span class="string">'VANILLA_VERSION'</span>] <span class="comment">-- 当前所使用的 VANILLA 版本号</span></span><br><span class="line">Registry[<span class="string">'VANILLA_APPLICATION'</span>] <span class="comment">-- 'vanilla.v.application' LUA 包</span></span><br><span class="line">Registry[<span class="string">'VANILLA_UTILS'</span>] 		<span class="comment">-- 'vanilla.v.libs.utils' LUA 包</span></span><br><span class="line">Registry[<span class="string">'VANILLA_CACHE_LIB'</span>] 	<span class="comment">-- 'vanilla.v.cache' LUA 包</span></span><br><span class="line">Registry[<span class="string">'VANILLA_COOKIE_LIB'</span>] 	<span class="comment">-- 'vanilla.v.libs.cookie' LUA 包</span></span><br><span class="line">Registry[<span class="string">'APP_BOOTS'</span>] 			<span class="comment">-- 应用 'application.bootstrap' LUA 包</span></span><br><span class="line">Registry[<span class="string">'APP_PAGE_CACHE_CONF'</span>] <span class="comment">-- 应用 Page Cache 相关配置</span></span><br></pre></td></tr></table></figure>
<p><em>注：上面很多全局变量是从 <code>ngx.var.</code> 获取来的结果缓存的，这样避免每次都请求 <code>ngx.var</code> 而减少这部分性能开销，并且其中有些信息比如 <code>APP_NAME</code>，<code>APP_ROOT</code> 等服务一经启动就不会更改，而像 `REQ_</em><code>相关的数据则是每次请求都不一样，好在一次请求可能对这部分数据会多次调用，所以将其缓存在</code>Registry` 表中*</p>
<p><strong>Vanilla 的內建函数</strong></p>
<p><em>Vanilla 有很多内建的函数，这些函数有些来自于 Vanilla 框架本身功能性的一些 LUA 包中，比如 <code>vanilla.v.controller</code>、<code>vanilla.v.request</code>、<code>vanilla.v.response</code> 等，另一些比如通用的方法，比如 <code>print_r</code>、 <code>page_cache</code> 和 <code>vanilla_init</code>，再有比如 Vanilla 定义的各种包加载函数，列表如下：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LoadLibrary 	<span class="comment">-- 加载项目 library 路径下的 LUA 包</span></span><br><span class="line">LoadController 	<span class="comment">-- 加载项目 controller</span></span><br><span class="line">LoadModel 	<span class="comment">-- 加载项目 model 路径下的包，包括 DAO 和 Service</span></span><br><span class="line">LoadPlugin 	<span class="comment">-- 加载项目 plugins 路径下所定义的插件</span></span><br><span class="line">LoadApplication 	<span class="comment">-- 加载项目 application 路径下的 LUA 包</span></span><br><span class="line">LoadApp 	<span class="comment">-- 加载项目根目录下面的 LUA 包</span></span><br><span class="line">LoadV 	<span class="comment">-- 加载 Vanilla 框架相关的 LUA 包</span></span><br></pre></td></tr></table></figure>
<p><em>注：以上有些加载器功能重复，目的在于减短所传递参数的长度，比如加载 Index Controller， 使用 LoadController 方法是，只需要写 <code>LoadController(&#39;index&#39;)， 而如果使用方法 LoadApp 则应该写成</code>LoadApp(‘application.controllers.index’)`</em></p>
<ul>
<li><strong>方法 <code>page_cache</code></strong></li>
</ul>
<p><em>该方法调用 Vanilla 封装的页面缓存逻辑，详细内容参见 (进阶/页缓存)</em></p>
<ul>
<li><strong>单步调试方法 <code>print_r</code>、<code>sprint_r</code> 等</strong></li>
</ul>
<p><em>调试系列方法主要为了开发时能清晰方便的查看变量状态，记录开发日志等功能，详细内容参见 (快速上手/如何调试)</em></p>
<ul>
<li><strong>方法 <code>init_vanilla</code></strong></li>
</ul>
<p><em>方法 <code>init_vanilla</code> 主要完成框架基础功能的初始化，比如 Registry 的初始化，各种 Loader 的定义，页面缓存的实现等，本方法默认在应用请求处理入口的第一句语句执行</em></p>
<h2 id="3、Libs"><a href="#3、Libs" class="headerlink" title="3、Libs"></a>3、Libs</h2><h3 id="3-1、Cookie"><a href="#3-1、Cookie" class="headerlink" title="3.1、Cookie"></a>3.1、Cookie</h3><h4 id="3-1-1、Vanilla-中使用-Cookie"><a href="#3-1-1、Vanilla-中使用-Cookie" class="headerlink" title="3.1.1、Vanilla 中使用 Cookie"></a>3.1.1、Vanilla 中使用 Cookie</h4><p><em>Vanilla 中封装了 <code>vanilla.v.libs.cookie</code> 包，源至 <a href="https://github.com/cloudflare/lua-resty-cookie" target="_blank" rel="noopener"><code>lua-resty-cookie</code></a>，提供了简单的 <code>get</code>、<code>set</code>、<code>getAll</code> 等方法来控制 Cookie，下面具体使用举例如下：</em></p>
<p><strong>vanilla.v.libs.cookie 包使用</strong></p>
<p><em>一例胜千言：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 载入 vanilla.v.libs.cookie 包</span></span><br><span class="line"><span class="keyword">local</span> vcookie_lib = LoadV(<span class="string">'vanilla.v.libs.cookie'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:index</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 实例化 vanilla.v.libs.cookie 类</span></span><br><span class="line">    <span class="keyword">local</span> cookie = vcookie_lib()</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 调用 set 方法，设置 cookie</span></span><br><span class="line">    cookie:set(<span class="string">'idevz'</span>, <span class="string">'kkkk'</span>, &#123;expires=<span class="number">1000</span>&#125;)</span><br><span class="line">    cookie:set(<span class="string">'idevz_api'</span>, <span class="string">'kkkk'</span>, &#123;expires=<span class="number">1000</span>,<span class="built_in">path</span>=<span class="string">'/'</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 调用 getAll 方法，获取所有 cookie，也可以调用 get 获取单个cookie</span></span><br><span class="line">    print_r(cookie:getAll())</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> <span class="string">''</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure>
<p><em>注：</em></p>
<p><em><code>vanilla.v.libs.cookie</code> 支持以下 cookie 选项</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span></span><br><span class="line">domain</span><br><span class="line">max_age</span><br><span class="line">secure</span><br><span class="line">httponly</span><br><span class="line">samesite</span><br><span class="line">extension</span><br></pre></td></tr></table></figure>
<h2 id="4、进阶"><a href="#4、进阶" class="headerlink" title="4、进阶"></a>4、进阶</h2><h3 id="4-1、页缓存"><a href="#4-1、页缓存" class="headerlink" title="4.1、页缓存"></a>4.1、页缓存</h3><h4 id="4-1-1、Vanilla-的-Page-Cache"><a href="#4-1-1、Vanilla-的-Page-Cache" class="headerlink" title="4.1.1、Vanilla 的 Page Cache"></a>4.1.1、Vanilla 的 Page Cache</h4><p><em>vanilla 的 Page Cache 实现了类似 Nginx 的 FastCGICache 或者 ProxyCache 的访问结果整体缓存，以 URI 的一定规则作为缓存的 KEY，属于内存型 Cache，存储位置可配置，默认存储在 OpenResty 共享字典（Share Dict）中，默认生成的项目中 Page Cache 为关闭状态</em></p>
<blockquote>
<p><strong>Page Cache 相关配置</strong></p>
</blockquote>
<p><em>Page Cache 相关的所有配置见项目的 config/application.lua 中， <code>Appconf.page_cache</code> 相关配置段，如下所示：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Appconf.page_cache = &#123;&#125;</span><br><span class="line">Appconf.page_cache.cache_on = <span class="literal">true</span></span><br><span class="line"><span class="comment">-- Appconf.page_cache.cache_handle = 'lru'</span></span><br><span class="line">Appconf.page_cache.no_cache_cookie = <span class="string">'va-no-cache'</span></span><br><span class="line">Appconf.page_cache.no_cache_uris = &#123;</span><br><span class="line">    <span class="string">'uris'</span></span><br><span class="line">&#125;</span><br><span class="line">Appconf.page_cache.build_cache_key_without_args = &#123;<span class="string">'rd'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置释意</strong></p>
<ul>
<li>cache_on 缓存开关，true 为开启 Page Cache，false 则为关闭</li>
<li>cache_handle 设置 Page Cache 的存储介质，目前支持 Memcache、Redis、resty.lrucache、OpenResty Share Dict，默认为 OpenResty Share Dict</li>
<li>no_cache_cookie 设置不缓存的 cookie KEY，Vanilla Page Cache 使用这个设置所指的 cookie KEY 来对某些特殊页面不缓存，默认当页面中有 KEY 为 <code>va-no-cache</code> 这个 COOKIE 的时候，当前页面不缓存</li>
<li>no_cache_uris 设置不缓存的 URI 列表，默认配置例如 <a href="http://app.com/uris" target="_blank" rel="noopener">http://app.com/uris</a> 命中 <code>uris</code> 则，当前页面不缓存</li>
<li>build_cache_key_without_args 设置在缓存 KEY 中去除某些参数，比如某些 API 的版本号，或者随机数等，默认配置中的 <code>rd</code> 设置代表，当 URI 中有 rd 参数时，则生成的 Page Cache KEY 中清除这个参数</li>
</ul>
<p><em>注：缓存的清理，只需要在请求的 URL 中，添加参数 <code>vapurge</code></em></p>
<h3 id="4-2、面向对象"><a href="#4-2、面向对象" class="headerlink" title="4.2、面向对象"></a>4.2、面向对象</h3><h4 id="4-2-1、面向对象的-Vanilla"><a href="#4-2-1、面向对象的-Vanilla" class="headerlink" title="4.2.1、面向对象的 Vanilla"></a>4.2.1、面向对象的 Vanilla</h4><p><em>Lua 提供了部分面向对象的语法糖，这仅仅能在开发中提供一个功能不完备的独立 Class 的使用，有 <code>self</code> 可以来引用 LUA 表的某些属性和方法，但是更多的面向对象特性，比如继承，比如类的构造等，LUA 支持的并不是非常好，日常的业务开发中，我们确实有些通用的逻辑可能需要复用，或者数据需要共享，需要有父子关系等等。所以我们在 Vanilla 中，简单封装了部分面向对象的特性，这里我们简单介绍其使用方法。</em></p>
<blockquote>
<p><strong>一个简单的 Vanilla 类</strong></p>
</blockquote>
<p><em>下面我们看一个例子：</em></p>
<p><strong>类定义</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibA = Class(<span class="string">"LibA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LibA:idevzDo</span><span class="params">(params)</span></span></span><br><span class="line">    <span class="keyword">local</span> params = params <span class="keyword">or</span> &#123; lib_bb = <span class="string">'idevzDo LibA'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LibA:__construct</span><span class="params">( data )</span></span></span><br><span class="line">    self.name = <span class="string">'name--&gt;'</span> .. data.name</span><br><span class="line">    self.sex = <span class="string">'sex--&gt;'</span> .. data.sex</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> LibA</span><br></pre></td></tr></table></figure>
<p><em>代码释意：</em></p>
<ul>
<li><code>Class(&quot;LibA&quot;)</code> 声明一个 Vanilla 类，类名为 <code>LibA</code></li>
<li><code>LibA:__construct( data )</code> 提供了一个类 LibA 的构造器，并对相应的属性进行初始化</li>
</ul>
<p><strong>类使用</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibA = LoadLibrary(<span class="string">'aa'</span>)</span><br><span class="line"><span class="keyword">local</span> liba_instance = LibA(&#123;name=<span class="string">'idevz'</span>,sex=<span class="string">'man'</span>&#125;)</span><br><span class="line">print_r(liba_instance.sex)</span><br></pre></td></tr></table></figure>
<p><em>执行结果 <code>sex--&gt;man</code></em></p>
<p><em>代码释意：（类使用的时候需要注意，类的使用分为类文件的加载 <code>Load( 如这里的 LoadLibrary )</code> 和实例化 <code>LibA()</code>） 两个步骤</em></p>
<ul>
<li><code>local LibA = LoadLibrary(&#39;aa&#39;)</code> 载入类名为 <code>LibA</code> 的类</li>
<li><code>local liba_instance = LibA({name=&#39;idevz&#39;,sex=&#39;man&#39;})</code> 传入表 <code>{name=&#39;idevz&#39;,sex=&#39;man&#39;}</code> 对类进行相关的实例化</li>
<li><code>liba_instance.sex</code> 是对实例属性的引用</li>
</ul>
<p><em>注：载入和实例化也可以一步达成 <code>local liba_instance = LoadLibrary(&#39;aa&#39;)({name=&#39;idevz&#39;,sex=&#39;man&#39;})</code></em></p>
<blockquote>
<p><strong>类继承</strong></p>
</blockquote>
<p><em>下面我么定义一个类 LibB，并使之集成于 LibA</em></p>
<p><strong>类定义</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibB = Class(<span class="string">"LibB"</span>, LoadLibrary(<span class="string">'LibA'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LibB:__construct</span><span class="params">( data )</span></span></span><br><span class="line">	<span class="keyword">local</span> data = data <span class="keyword">or</span> &#123;name=<span class="string">'kk'</span>, sex=<span class="string">'xxx'</span>&#125;</span><br><span class="line">	data.sex = data.sex .. <span class="string">'--&gt;son'</span></span><br><span class="line">	self.parent:__construct(data)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> LibB</span><br></pre></td></tr></table></figure>
<p><em>代码释意：</em></p>
<ul>
<li><code>Class(&quot;LibB&quot;, LoadLibrary(&#39;LibA&#39;))</code> 声明一个 Vanilla 类，类名为 <code>LibB</code> 继承自类 <code>LibA</code></li>
<li><code>self.parent:__construct(data)</code> 构造器中调用父类的构造器</li>
</ul>
<p><strong>类使用</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> LibB = LoadLibrary(<span class="string">'LibB'</span>)</span><br><span class="line"><span class="keyword">local</span> libb_instance = LibB(&#123;name=<span class="string">'idevz'</span>,sex=<span class="string">'man'</span>&#125;)</span><br><span class="line">print_r(libb_instance:idevzDo(&#123;doo=<span class="string">'xxx'</span>&#125;)[<span class="string">'doo'</span>])</span><br></pre></td></tr></table></figure>
<p><em>执行结果 <code>xxx</code></em></p>
<p><em>代码释意：</em></p>
<ul>
<li><code>libb_instance:idevzDo</code> 调用父类的 <code>idevzDo</code> 方法</li>
</ul>
<h3 id="4-3、Vanilla-包开发"><a href="#4-3、Vanilla-包开发" class="headerlink" title="4.3、Vanilla 包开发"></a>4.3、Vanilla 包开发</h3><h4 id="4-3-1、Vanilla-的包开发"><a href="#4-3-1、Vanilla-的包开发" class="headerlink" title="4.3.1、Vanilla 的包开发"></a>4.3.1、Vanilla 的包开发</h4><p><em>可以使用任意 LUA 包的开发方式来开发 Vanilla 包（Controllers，Library，Dao，Services等），也可以使用 Vanilla 所提供的 (面向对象) 方式进行开发</em></p>
<p><strong>对 Controller 使用继承和构造器</strong></p>
<p><em>下面我们看一个例子：</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> IndexController = Class(<span class="string">'controllers.index'</span>,</span><br><span class="line">    LoadApplication(<span class="string">'controllers.base'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexController:__construct</span><span class="params">()</span></span></span><br><span class="line">    self.parent:__construct()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> IndexController</span><br></pre></td></tr></table></figure>
<h2 id="5、OpenResty"><a href="#5、OpenResty" class="headerlink" title="5、OpenResty"></a>5、OpenResty</h2><h3 id="5-1、OR文档精炼"><a href="#5-1、OR文档精炼" class="headerlink" title="5.1、OR文档精炼"></a>5.1、OR文档精炼</h3><p><strong>OR文档精炼</strong></p>
<p><em>感谢春哥给我们带来这么好的平台，在这里希望能通读 OR 文档，把自己的理解记录下来，并与时俱进的更新</em></p>
<h4 id="5-1-1、描述-Description"><a href="#5-1-1、描述-Description" class="headerlink" title="5.1.1、描述 / Description"></a>5.1.1、描述 / Description</h4><p><code>lua-nginx-module</code> 模块通过标准的 Lua 5.1 解释器，或者 LuaJIT 2.0/2.1 在 Nginx 运行环境中嵌入 Lua，并利用 Nginx 的子请求，允许在 Nginx 的时间模块中集成强大的 Lua 线程（Lua 协程）。</p>
<p>与 Apache 的 <code>mod_lua</code> 和 Lighttpd 的 <code>mod_magnet</code> 不同的是，只要使用 <code>lua-nginx-module</code> 模块为 Lua 提供的 Nginx API 来处理上游服务的请求，诸如 MySQL、PostgreSQL、Memcached、Redis 或者上游的 HTTP Web 服务，网络传输都是 100% 非阻塞的。</p>
<p>至少下面列举的这些 Lua 包，和 Nginx 模块可以与 <code>ngx_lua</code> 模块完美结合使用：</p>
<h4 id="5-1-2、ngx-timer"><a href="#5-1-2、ngx-timer" class="headerlink" title="5.1.2、ngx.timer"></a>5.1.2、ngx.timer</h4><blockquote>
<p><strong>ngx.timer.at</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)</code></p>
<p><em>上下文：</em></p>
<p><code>init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p>
<p><em>使用一个自定义函数以及可选的自定义参数创建一个 Nginx 计时器</em></p>
<p>第一个参数 <code>delay</code> 以秒为单位指定计时器的延迟时间，支持分秒设置，比如 0.001 在这里表示 1 毫秒延迟。<code>delay</code> 同样可以设置为 0 ，此时如果当前句柄正被唤醒则计时器将立即获得执行。（in which case the timer will immediately expire when the current handler yields execution.//TODO yields）</p>
<p>第二个参数 <code>callback</code> 可以是任何 Lua 函数，后期延迟时间到了，该函数将被以一个后台 “轻线程” 的形式被调用。这个自定义的回调函数将被 Nginx 核心使用 <code>premature</code> 参数、user_arg1、user_arg2 等参数自动调用，参数 <code>premature</code> 是一个 boolean 值，表示当前定时器是否过期以后，而 user_arg1、user_arg2 等参数就是调用 <code>ngx.timer.at</code> 时所传递的余下参数列表。</p>
<p>当 Nginx 工作进程尝试关闭，比如在 Nginx 由于收到 HUP 信号而触发了 Nginx 配置重载的时候，或者 Nginx 服务正在关闭的时候，将会出现无效的计时器（//TODO Premature timer）。当 Nginx 工作进程尝试关闭，将无法通过调用 <code>ngx.timer.at</code> 来创建一个新的非零延迟的计时器，并且此时 <code>ngx.timer.at</code> 将返回 <code>nil</code> 和 “process exiting” 错误。</p>
<p>这个 API 从 v0.9.3 版本开始，即使 Nginx 工作进程开始关闭的时候，仍然允许创建零延迟计时器。</p>
<p>当一个计时器到期时，计时器中用户定义回调的 Lua 代码将在一个与创建这个计时器的源请求完全隔离的 “轻线程” 中运行，所以，源请求生命周期内的对象，比如 <code>cosockets</code> 并不能与回调函数共享。</p>
<p>下面来看一个简单的例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"> ...</span><br><span class="line"> log_by_lua_block &#123;</span><br><span class="line">     <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">push_data</span><span class="params">(premature, uri, args, status)</span></span></span><br><span class="line">         <span class="comment">-- push the data uri, args, and status to the remote</span></span><br><span class="line">         <span class="comment">-- via ngx.socket.tcp or ngx.socket.udp</span></span><br><span class="line">         <span class="comment">-- (one may want to buffer the data in Lua a bit to</span></span><br><span class="line">         <span class="comment">-- save I/O operations)</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">local</span> ok, err = ngx.timer.at(<span class="number">0</span>, push_data,</span><br><span class="line">                                  ngx.var.uri, ngx.var.args, ngx.header.<span class="built_in">status</span>)</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">         ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to create timer: "</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以创建一个无限执行的计时器，例如，一个每 5 秒触发执行一次的计时器，在它的回调方法中递归的调用 <code>ngx.timer.at</code> ，这里给出这样的一个例子。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> delay = <span class="number">5</span></span><br><span class="line"><span class="keyword">local</span> handler</span><br><span class="line">handler = <span class="function"><span class="keyword">function</span> <span class="params">(premature)</span></span></span><br><span class="line"> <span class="comment">-- do some routine job in Lua just like a cron job</span></span><br><span class="line"> <span class="keyword">if</span> premature <span class="keyword">then</span></span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">local</span> ok, err = ngx.timer.at(delay, handler)</span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">     ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to create the timer: "</span>, err)</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ok, err = ngx.timer.at(delay, handler)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line"> ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to create the timer: "</span>, err)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>因为定时器的回调函数都是运行在后端，而且他们的运行时间不会叠加到客户端请求的相应时间中，它们可能会因为 Lua 语法错误，或者过多的客户端请求而很容易在服务端造成累积，或者耗尽系统资源。为了防止出现像 Nginx 服务器宕机这种极端结果，在一个 Nginx 工作进程中提供了对 “等待中的计时器” 和 “运行中的计时器” 这两种计时器的数量限制。这里 “等待中的计时器” 是指还没有过期的计时器，而 “运行中的计时器” 是指那些用户回调方法当前正在运行的计时器。</p>
<p>一个 Nginx 进程中所允许的 “等待中的计时器” 允许的最大数量由 <code>lua_max_pending_timers</code> 指令控制。而允许的 “运行中的计时器” 允许的最大数量由 <code>lua_max_running_timers</code> 指令控制。</p>
<p>目前的实现，每个 “运行中的计时器” 都会从 nginx.conf 配置中 <code>worker_connections</code> 指令配置的全局连接列表中占用一个 （虚） 连接记录，所以必须确保 <code>worker_connections</code> 指令设置了一个足够大的值能同时包含真正的连接数和计时器回调函数运行所需要的虚连接数（这个连接数是有 <code>lua_max_running_timers</code> 指令设限的）。</p>
<p>许多 Nginx 的 Lua API 能在计时器回调函数的上下文中使用，比如操作流和数据包的 cosockets API（<code>ngx.socket.tcp</code> 和 <code>ngx.socket.udp</code>），共享内存字典（<code>ngx.shared.DICT</code>），用户协程函数（<code>coroutine.*</code>），用户“轻线程”（<code>ngx.thread.*</code>），<code>ngx.exit</code>，<code>ngx.now/ngx.time</code>，<code>ngx.md5/ngx.sha1_bin</code>等都是可用的，但是相关子请求的 API （诸如<code>ngx.location.capture</code>），<code>ngx.req.* API</code>，下游输出 API （诸如 <code>ngx.say</code>，<code>ngx.print</code> 和 <code>ngx.flush</code>）都是明确在此上下文中不支持的。</p>
<p>你可以给计时器的回调函数传递大部分的标准 Lua 值类型（nils、布尔、数字、字符串、表、闭包、文件句柄等），要么显示的使用用户参数或者隐式的使用回调函数闭包的上游值。然而有一些例外诸如：你不能传递任何由 <code>coroutine.create</code> 和 <code>ngx.thread.spawn</code> 返回的线程对象，或者任何由 <code>ngx.socket.tcp</code>、<code>ngx.socket.udp</code> 和 <code>ngx.req.socket</code> 返回的 cosocket 对象，因为这些对象的生命周期是与创建他们的请求上下文绑定的，而计时器的回调函数（设计时）是与创建他们的请求上下文分离的，并且运行在它自己的（虚）请求上下文中。如果你试图跨越创建这些线程和 cosocket 的请求上下文边界来共享这些线程和 cosocket 对象，将会报错，对线程将报错 <code>no co ctx found</code>，对 cosocket 将报错 <code>bad request</code>，然而在计时器回调函数内部来创建这些对象则是没问题的。</p>
<p>这个 API 在 v0.8.0 版本第一次释出。</p>
<blockquote>
<p><strong>ngx.timer.running_count</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>count = ngx.timer.running_count()</code></p>
<p><em>上下文：</em></p>
<p><code>init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p>
<p><em>返回当前正在运行的计时器数量。</em><br>这个指令在 v0.9.20 版本第一次释出。</p>
<blockquote>
<p><strong>ngx.timer.pending_count</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>count = ngx.timer.pending_count()</code></p>
<p><em>上下文：</em></p>
<p><code>init_worker_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, balancer_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p>
<p><em>返回当前正在等待的计时器数量。</em><br>这个指令在 v0.9.20 版本第一次释出。</p>
<h4 id="5-1-3、ngx-config"><a href="#5-1-3、ngx-config" class="headerlink" title="5.1.3、ngx.config"></a>5.1.3、ngx.config</h4><blockquote>
<p><strong>ngx.config.subsystem</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>subsystem = ngx.config.subsystem</code></p>
<p><em>上下文：</em></p>
<p><code>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</code></p>
<p><em>这个字符串字段表示了当前基于哪个 Nginx 子系统，对当前模块（ngx_stream_lua_module），这个字段始终返回 “http”，而对 ngx_stream_lua_module 模块，这个字段将返回 “stream”</em></p>
<p>这个字段在 v0.10.1 版本第一次释出。</p>
<blockquote>
<p><strong>ngx.config.debug</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>debug = ngx.config.debug</code></p>
<p><em>上下文：</em></p>
<p><code>set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*, init_by_lua*, init_worker_by_lua*</code></p>
<p>*这个布尔字段表示了当前 Nginx 是否打开 debug 编译选项，如编译时配置为 <code>./configure option --with-debug</code>。</p>
<p>这个字段在 v0.8.7 版本第一次释出。</p>
<h4 id="5-1-4、coroutine"><a href="#5-1-4、coroutine" class="headerlink" title="5.1.4、coroutine"></a>5.1.4、coroutine</h4><blockquote>
<p><strong>coroutine.create</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>co = coroutine.create(f)</code></p>
<p><em>上下文：</em></p>
<p><code>rewrite_by_lua*, access_by_lua*, content_by_lua*, init_by_lua*, ngx.timer.*, header_filter_by_lua*, body_filter_by_lua*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*, ssl_session_store_by_lua*</code></p>
<p><em>使用 Lua 函数创建一个用户态 Lua 协程， 并返回一个协程对象。与标准 Lua 中的协程创建的 API <code>coroutine.create</code> 类似，但是工作在 ngx_lua 模块创建的 Lua 协程上下文中，这个 API 第一次是被使用在 0.9.2 版本的 `init_by_lua</em>` 上下文中。*</p>
<p>这个 API 在 v0.6.0 版本第一次释出。</p>
<h4 id="5-1-5、ngx-thread"><a href="#5-1-5、ngx-thread" class="headerlink" title="5.1.5、ngx.thread"></a>5.1.5、ngx.thread</h4><blockquote>
<p><strong>ngx.config.subsystem</strong></p>
</blockquote>
<p><em>语法：</em></p>
<p><code>co = ngx.thread.spawn(func, arg1, arg2, ...)</code></p>
<p><em>上下文：</em></p>
<p><code>rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*, ssl_certificate_by_lua*, ssl_session_fetch_by_lua*</code></p>
<p><em>使用 Lua 函数 <code>func</code> 以及可选的参数 <code>arg1</code>，<code>arg2</code> 等生成一个新的用户“轻线程”，返回一个 Lua 线程（或者 Lua 协程）对象代表这个 “轻线程”</em><br>“轻线程”仅仅是一种特殊的由 <code>ngx_lua</code> 模块来调度的 Lua 协程。<br>在 <code>ngx.thread.spawn</code> 返回之前， <code>func</code> 函数将会被使用响应的可选参数进行调用，直到此函数调用返回、或者因为错误而终止或是因为通过使用 Nginx 的 I/O 操作 API 导致请求挂起（如 <code>tcpsock:receive</code> 操作）。<br>在 <code>ngx.thread.spawn</code> 返回后，新被创建的“轻线程”将在各种 I/O 事件中保持通常的异步运行。</p>
<p>所有在 <code>rewrite_by_lua</code>、<code>access_by_lua</code> 和 <code>content_by_lua</code> 运行的 Lua 代码块都在一个由 ngx_lua 自动创建的样板“轻线程”中，这些样板“轻线程”通常又叫“入口线程”。</p>
<p>默认情况下，相应的 Nginx 处理程序（例如 <code>rewrite_by_lua</code> 处理程序）不会终止直到“入口线程”和所有的用户“轻线程”都终止，一个“轻线程（要么是“入口线程”要么是“用户轻线程”因为调用 <code>ngx.exit</code>，<code>ngx.exec</code>，<code>ngx.redirect</code> 或者 <code>ngx.req.set_uri(uri, true)</code>）或者“入口线程”因为报错而终止。<br>当一个用户“轻线程”因为报错而终止，他将不会像“入口线程”一样终止其他线程的运行。</p>
<p>因为 Nginx 子请求模块的限制，一般不允许中止一个正在运行中的 Nginx 子请求。所以同样禁止中止一个运行中的正在等待一个或多个 Nginx 子请求的“轻线程”。你应该调用 <code>ngx.thread.wait</code> 来在结束前等待这些“轻线程”结束。这里有个值得注意的例外是你可以通过使用而且只能使用 <code>ngx.ERROR(-1),408,444或者499</code> 状态调用 <code>ngx.exit</code> 来中止等待的子请求。</p>
<p>“轻线程”不是使用预先抢占的方式来调度的，换句话说，没有自动执行的时间片，一个“轻线程”将保持在 CPU 运行，直到一个（非阻塞）I/O 操作在一个单线程运行不能被完成。</p>
<p>The “light threads” are not scheduled in a pre-emptive way. In other words, no time-slicing is performed automatically. A “light thread” will keep running exclusively on the CPU until<br>a (nonblocking) I/O operation cannot be completed in a single run,<br>it calls coroutine.yield to actively give up execution, or<br>it is aborted by a Lua error or an invocation of ngx.exit, ngx.exec, ngx.redirect, or ngx.req.set_uri(uri, true).<br>For the first two cases, the “light thread” will usually be resumed later by the ngx_lua scheduler unless a “stop-the-world” event happens.</p>
<p>User “light threads” can create “light threads” themselves. And normal user coroutines created by coroutine.create can also create “light threads”. The coroutine (be it a normal Lua coroutine or a “light thread”) that directly spawns the “light thread” is called the “parent coroutine” for the “light thread” newly spawned.</p>
<p>The “parent coroutine” can call ngx.thread.wait to wait on the termination of its child “light thread”.</p>
<p>You can call coroutine.status() and coroutine.yield() on the “light thread” coroutines.</p>
<p>The status of the “light thread” coroutine can be “zombie” if</p>
<p>the current “light thread” already terminates (either successfully or with an error),<br>its parent coroutine is still alive, and<br>its parent coroutine is not waiting on it with ngx.thread.wait.<br>The following example demonstrates the use of coroutine.yield() in the “light thread” coroutines to do manual time-slicing:</p>
</div><div class="tags"><a href="/tags/Lua/">Lua</a><a href="/tags/Vanilla/">Vanilla</a><a href="/tags/中文文档/">中文文档</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/blog/2018/08/01/nginx-book/" class="next">Nginx初探</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNjk1MS8xMzQ4Nw=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0、前言"><span class="toc-text">0、前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1、安装"><span class="toc-text">0.1、安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2、快速开始"><span class="toc-text">0.2、快速开始</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、快速上手"><span class="toc-text">1、快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、Hello-World"><span class="toc-text">1.1、Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1、Vanilla-的安装"><span class="toc-text">1.1.1、Vanilla 的安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2、如何调试"><span class="toc-text">1.2、如何调试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1、Vanilla-的-调试"><span class="toc-text">1.2.1、Vanilla 的 调试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3、如何新增一个Controller"><span class="toc-text">1.3、如何新增一个Controller</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1、Vanilla-的-controller"><span class="toc-text">1.3.1、Vanilla 的 controller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2、新添加一个-Controller"><span class="toc-text">1.3.2、新添加一个 Controller</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4、如何使用Models-Dao"><span class="toc-text">1.4、如何使用Models/Dao</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1、Vanilla-的-DAO"><span class="toc-text">1.4.1、Vanilla 的 DAO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5、如何使用Models-Service"><span class="toc-text">1.5、如何使用Models/Service</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1、Vanilla-的-Service"><span class="toc-text">1.5.1、Vanilla 的 Service</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、APIs"><span class="toc-text">2、APIs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、配置"><span class="toc-text">2.1、配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1、App配置"><span class="toc-text">2.1.1、App配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2、Nginx配置"><span class="toc-text">2.1.2、Nginx配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3、WAF配置"><span class="toc-text">2.1.3、WAF配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、Bootstrap"><span class="toc-text">2.2、Bootstrap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1、使用-Bootstrap-来做服务初始化"><span class="toc-text">2.2.1、使用 Bootstrap 来做服务初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、Controllers"><span class="toc-text">2.3、Controllers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1、Vanilla-的-controller"><span class="toc-text">2.3.1、Vanilla 的 controller</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、模板引擎"><span class="toc-text">2.4、模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1、Vanilla-的视图引擎"><span class="toc-text">2.4.1、Vanilla 的视图引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5、插件"><span class="toc-text">2.5、插件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1、Vanilla-的插件体系"><span class="toc-text">2.5.1、Vanilla 的插件体系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6、路由"><span class="toc-text">2.6、路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1、Vanilla-的路由体系"><span class="toc-text">2.6.1、Vanilla 的路由体系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7、异常处理"><span class="toc-text">2.7、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1、Vanilla-的错误处理"><span class="toc-text">2.7.1、Vanilla 的错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8、内建类"><span class="toc-text">2.8、内建类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1、Vanilla-的內建变量和方法"><span class="toc-text">2.8.1、Vanilla 的內建变量和方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Libs"><span class="toc-text">3、Libs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、Cookie"><span class="toc-text">3.1、Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1、Vanilla-中使用-Cookie"><span class="toc-text">3.1.1、Vanilla 中使用 Cookie</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、进阶"><span class="toc-text">4、进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1、页缓存"><span class="toc-text">4.1、页缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1、Vanilla-的-Page-Cache"><span class="toc-text">4.1.1、Vanilla 的 Page Cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2、面向对象"><span class="toc-text">4.2、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1、面向对象的-Vanilla"><span class="toc-text">4.2.1、面向对象的 Vanilla</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3、Vanilla-包开发"><span class="toc-text">4.3、Vanilla 包开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1、Vanilla-的包开发"><span class="toc-text">4.3.1、Vanilla 的包开发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、OpenResty"><span class="toc-text">5、OpenResty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1、OR文档精炼"><span class="toc-text">5.1、OR文档精炼</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1、描述-Description"><span class="toc-text">5.1.1、描述 / Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2、ngx-timer"><span class="toc-text">5.1.2、ngx.timer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3、ngx-config"><span class="toc-text">5.1.3、ngx.config</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-4、coroutine"><span class="toc-text">5.1.4、coroutine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-5、ngx-thread"><span class="toc-text">5.1.5、ngx.thread</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/blog/2018/09/19/quick-start-Vanilla-lua-web-framework/">Vanilla （lua web framework）中文文档 [2018.09.19]</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/08/01/nginx-book/">Nginx初探</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/05/18/automatic-investment-plan-by-golang/">基于Go语言的简易基金定投系统</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/04/20/a-bite-of-golang/">A Bite of Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/03/15/taste-gdb/">GDB抓虫之旅</a></li><li class="post-list-item"><a class="post-list-link" href="/blog/2018/01/12/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/Go语言/" style="font-size: 15px;">Go语言</a> <a href="/tags/基金/" style="font-size: 15px;">基金</a> <a href="/tags/定投/" style="font-size: 15px;">定投</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/基础概念/" style="font-size: 15px;">基础概念</a> <a href="/tags/GDB/" style="font-size: 15px;">GDB</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/Vanilla/" style="font-size: 15px;">Vanilla</a> <a href="/tags/中文文档/" style="font-size: 15px;">中文文档</a> <a href="/tags/入门/" style="font-size: 15px;">入门</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">ShengGuocun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e3ed45ce04d57be9fec7dd674aec65e0";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>